<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>manna的笔记</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-04-26T07:26:55.630Z</updated>
  <id>http://yoursite.com/</id>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>hexo git提交出现验证报错问题解决</title>
    <link href="http://yoursite.com/2020/04/16/hexo%20git%E6%8F%90%E4%BA%A4/"/>
    <id>http://yoursite.com/2020/04/16/hexo git提交/</id>
    <published>2020-04-16T03:35:15.000Z</published>
    <updated>2020-04-26T07:26:55.630Z</updated>
    
    <content type="html"><![CDATA[<p>安装hexo对于git的部署工具。<br>npm install hexo-deployer-git –save </p>
<h3 id="执行-hexo-deploy-后-出现"><a href="#执行-hexo-deploy-后-出现" class="headerlink" title="执行 hexo deploy 后,出现"></a>执行 hexo deploy 后,出现</h3><p>验证报错报错verification failed：<br>Error: Host key verification failed.<br>fatal: Could not read from remote repository.<br>Please make sure you have the correct access rights and the repository exists.</p>
<h3 id="解决方法：条件SSHkey"><a href="#解决方法：条件SSHkey" class="headerlink" title="解决方法：条件SSHkey"></a>解决方法：条件SSHkey</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ ssh-keygen -t rsa -C &quot;邮箱&quot;</div></pre></td></tr></table></figure>
<p>三次回车，即可设置密码为空</p>
<p>将生成的C:\Users\your_user_director.ssh目录下的id_rsa.pub添加到github上</p>
<p>再测试是否可以连接到github上，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ ssh git@github.com</div></pre></td></tr></table></figure></p>
<p>Hi imsofter! You’ve successfully authenticated, but GitHub does not provide shell access.<br>Connection to github.com closed.</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;安装hexo对于git的部署工具。&lt;br&gt;npm install hexo-deployer-git –save &lt;/p&gt;
&lt;h3 id=&quot;执行-hexo-deploy-后-出现&quot;&gt;&lt;a href=&quot;#执行-hexo-deploy-后-出现&quot; class=&quot;headerli
    
    </summary>
    
      <category term="git" scheme="http://yoursite.com/categories/git/"/>
    
    
      <category term="git" scheme="http://yoursite.com/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>面试总结</title>
    <link href="http://yoursite.com/2019/11/13/%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2019/11/13/面试总结/</id>
    <published>2019-11-13T10:06:34.000Z</published>
    <updated>2020-04-26T07:26:55.652Z</updated>
    
    <content type="html"><![CDATA[<h3 id="HTML5新特性"><a href="#HTML5新特性" class="headerlink" title="HTML5新特性"></a>HTML5新特性</h3><ol>
<li>新增canvas、video、audio等新标签元素，新增特殊内容元素：article、footer、header、nav、section等，新增表单控件：Calendar、date、time、email、url、search</li>
<li>HTML5地理定位<br>HTML5 Geolocation API 用于获得用户的地理位置。</li>
<li>新增webSocket/webWork技术</li>
<li>HTML5 Web 存储<br>Web Storage DOM API 为Web应用提供了一个能够替代cookie的Javascript解决方案<br>sessionStorage—客户端数据存储，只能维持在当前会话范围内。sessionStorage 方法针对一个 session 进行数据存储。当用户关闭浏览器窗口后，数据会被删除。<br>localStorage—客户端数据存储，能维持在多个会话范围内。localStorage 对象存储的数据没有时间限制。第二天、第二周或下一年之后，数据依然可用。</li>
</ol>
<h3 id="let-const-var-区别"><a href="#let-const-var-区别" class="headerlink" title="let const var 区别"></a>let const var 区别</h3><ol>
<li>var定义的变量，没有块的概念，可以跨块访问, 不能跨函数访问。   变量提升</li>
<li>let定义的变量，只能在块作用域里访问，不能跨块访问，也不能跨函数访问。</li>
<li>const用来定义常量，使用时必须初始化(即必须赋值)，只能在块作用域里访问，而且不能修改。</li>
<li>同一个变量只能使用一种方式声明，不然会报错</li>
</ol>
<h3 id="JavaScript-变量提升"><a href="#JavaScript-变量提升" class="headerlink" title="JavaScript 变量提升"></a>JavaScript 变量提升</h3><ul>
<li>JavaScript 中，函数及变量的声明都将被提升到函数的最顶部。</li>
<li>JavaScript 中，变量可以在使用后声明，也就是变量可以先使用再声明。</li>
</ul>
<a id="more"></a>
<h3 id="json对象合并的方法"><a href="#json对象合并的方法" class="headerlink" title="json对象合并的方法"></a>json对象合并的方法</h3><ol>
<li><p>循环遍历法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">function extend() &#123;</div><div class="line">    var length = arguments.length;</div><div class="line">    if(length == 0)return &#123;&#125;;</div><div class="line">    if(length == 1)return arguments[0];</div><div class="line">    var target = arguments[0] || &#123;&#125;;</div><div class="line">    for (var i = 1; i &lt; length; i++) &#123;</div><div class="line">        var source = arguments[i];</div><div class="line">        for (var key in source) &#123;</div><div class="line">            if (source.hasOwnProperty(key)) &#123;</div><div class="line">                target[key] = source[key];</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">     </div><div class="line">    return target;</div><div class="line">&#125;</div><div class="line">const obj1 = &#123; a: 1, b: 2 &#125;;</div><div class="line">const obj2 = &#123; b: 3, c: 4, d: 5 &#125;;</div><div class="line">const result = extend(obj1, obj2);</div><div class="line">console.log(result);//&#123; a: 1, b: 3, c: 4, d: 5 &#125;</div></pre></td></tr></table></figure>
</li>
<li><p>Object.assign()</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">const obj1 = &#123; a: 1, b: 2 &#125;;</div><div class="line">const obj2 = &#123; b: 3, c: 4, d: 5 &#125;;</div><div class="line">const result = Object.assign(obj1, obj2);</div><div class="line">console.log(result);//&#123; a: 1, b: 3, c: 4, d: 5 &#125;</div></pre></td></tr></table></figure>
</li>
<li><p>jQuery   $.extend</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">const obj1 = &#123; a: 1, b: 2 &#125;;</div><div class="line">const obj2 = &#123; b: 3, c: 4, d: 5 &#125;;</div><div class="line">const result = $.extend(obj1, obj2);</div><div class="line">console.log(result);//&#123; a: 1, b: 3, c: 4, d: 5 &#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="JS中的扩展运算符…"><a href="#JS中的扩展运算符…" class="headerlink" title="JS中的扩展运算符…"></a>JS中的扩展运算符…</h3><p>JS中的扩展运算符一般用于以下情况：</p>
<ol>
<li>数组和对象的深拷贝（仅限单层数组或对象的深拷贝，实际上对于数组和对象的嵌套来说还是浅拷贝）<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">let arr = [&apos;a&apos;,&apos;b&apos;]</div><div class="line">let arr1 = [...arr]</div><div class="line">let [...arr2] = arr</div><div class="line">console.log(arr1,arr2)  //输出[&apos;a&apos;,&apos;b&apos;] [&apos;a&apos;,&apos;b&apos;]</div></pre></td></tr></table></figure>
</li>
</ol>
<p>这里数组arr和arr1和arr2存储在不同的对内存地址中，互相之间不会产生任何影响。</p>
<ol>
<li>数组或对象的拼接</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">let arr = [&apos;a&apos;,&apos;b&apos;]</div><div class="line">let arr1 = [&apos;c&apos;]</div><div class="line">let arr2 = [...arr,...arr1]</div><div class="line">console.log(arr2) //输出[&apos;a&apos;,&apos;b&apos;,&apos;c&apos;]</div></pre></td></tr></table></figure>
<p>要注意的是：如果是对象的拼接，对于同一个key的键值对，后面的会覆盖前面的，如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">let obj = &#123;name:&apos;xyp&apos;,age:18&#125;</div><div class="line">let obj = &#123;name:&apos;zyp&apos;&#125;</div><div class="line">let obj3 = &#123;...obj1, ...obj2&#125;</div><div class="line">console.log(obj3) //输出结果为：&#123;name:&quot;zyp&quot;,age:18&#125;</div></pre></td></tr></table></figure></p>
<ol>
<li>函数传参（结构赋值）</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">function add(...arr)&#123;</div><div class="line">  let sum = 0</div><div class="line">  arr[0] = 11</div><div class="line">  sum = arr.reduce((prev,cur) =&gt; &#123;</div><div class="line">    return prev + cur</div><div class="line">  &#125;,0)</div><div class="line">  return sum</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">let arr = [1,2]</div><div class="line">let sum = add(...arr)</div><div class="line">console.log(sum) //得到的值是13</div><div class="line">console。log(arr) //得到的值依然是[1,2]</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;HTML5新特性&quot;&gt;&lt;a href=&quot;#HTML5新特性&quot; class=&quot;headerlink&quot; title=&quot;HTML5新特性&quot;&gt;&lt;/a&gt;HTML5新特性&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;新增canvas、video、audio等新标签元素，新增特殊内容元素：article、footer、header、nav、section等，新增表单控件：Calendar、date、time、email、url、search&lt;/li&gt;
&lt;li&gt;HTML5地理定位&lt;br&gt;HTML5 Geolocation API 用于获得用户的地理位置。&lt;/li&gt;
&lt;li&gt;新增webSocket/webWork技术&lt;/li&gt;
&lt;li&gt;HTML5 Web 存储&lt;br&gt;Web Storage DOM API 为Web应用提供了一个能够替代cookie的Javascript解决方案&lt;br&gt;sessionStorage—客户端数据存储，只能维持在当前会话范围内。sessionStorage 方法针对一个 session 进行数据存储。当用户关闭浏览器窗口后，数据会被删除。&lt;br&gt;localStorage—客户端数据存储，能维持在多个会话范围内。localStorage 对象存储的数据没有时间限制。第二天、第二周或下一年之后，数据依然可用。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;let-const-var-区别&quot;&gt;&lt;a href=&quot;#let-const-var-区别&quot; class=&quot;headerlink&quot; title=&quot;let const var 区别&quot;&gt;&lt;/a&gt;let const var 区别&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;var定义的变量，没有块的概念，可以跨块访问, 不能跨函数访问。   变量提升&lt;/li&gt;
&lt;li&gt;let定义的变量，只能在块作用域里访问，不能跨块访问，也不能跨函数访问。&lt;/li&gt;
&lt;li&gt;const用来定义常量，使用时必须初始化(即必须赋值)，只能在块作用域里访问，而且不能修改。&lt;/li&gt;
&lt;li&gt;同一个变量只能使用一种方式声明，不然会报错&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;JavaScript-变量提升&quot;&gt;&lt;a href=&quot;#JavaScript-变量提升&quot; class=&quot;headerlink&quot; title=&quot;JavaScript 变量提升&quot;&gt;&lt;/a&gt;JavaScript 变量提升&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;JavaScript 中，函数及变量的声明都将被提升到函数的最顶部。&lt;/li&gt;
&lt;li&gt;JavaScript 中，变量可以在使用后声明，也就是变量可以先使用再声明。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="面试" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>CSS固定宽高图片裁剪居中显示</title>
    <link href="http://yoursite.com/2019/09/10/CSS%E5%9B%BA%E5%AE%9A%E5%AE%BD%E9%AB%98%E5%9B%BE%E7%89%87%E8%A3%81%E5%89%AA%E5%B1%85%E4%B8%AD%E6%98%BE%E7%A4%BA/"/>
    <id>http://yoursite.com/2019/09/10/CSS固定宽高图片裁剪居中显示/</id>
    <published>2019-09-10T13:45:31.000Z</published>
    <updated>2020-04-26T07:26:55.612Z</updated>
    
    <content type="html"><![CDATA[<h3 id="使用background实现；具体代码"><a href="#使用background实现；具体代码" class="headerlink" title="使用background实现；具体代码"></a>使用background实现；具体代码</h3><p>HTML<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;div class=&quot;cover-box&quot; style=&quot;background-image:url(&apos;图片地址&apos;)&quot;&gt;&lt;/div&gt;</div></pre></td></tr></table></figure></p>
<p>CSS<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">width: 200px;</div><div class="line">height: 200px;</div><div class="line">background-size: cover;</div><div class="line">background-repeat: no-repeat;</div><div class="line">background-position: center;</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;使用background实现；具体代码&quot;&gt;&lt;a href=&quot;#使用background实现；具体代码&quot; class=&quot;headerlink&quot; title=&quot;使用background实现；具体代码&quot;&gt;&lt;/a&gt;使用background实现；具体代码&lt;/h3&gt;&lt;p&gt;HT
    
    </summary>
    
      <category term="前端笔记" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="CSS" scheme="http://yoursite.com/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>Webpack学习笔记</title>
    <link href="http://yoursite.com/2019/09/10/Webpack%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2019/09/10/Webpack学习笔记/</id>
    <published>2019-09-10T12:28:45.000Z</published>
    <updated>2020-04-26T07:26:55.628Z</updated>
    
    <content type="html"><![CDATA[<h3 id="安装Webpack"><a href="#安装Webpack" class="headerlink" title="安装Webpack"></a>安装Webpack</h3><p>新建一个空文件夹 ，打开cmd运行命令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">//全局安装</div><div class="line">npm install -g webpack</div><div class="line">//安装到你的项目目录</div><div class="line">npm install --save-dev webpack</div></pre></td></tr></table></figure></p>
<a id="more"></a>
<h3 id="新建package-json"><a href="#新建package-json" class="headerlink" title="新建package.json"></a>新建package.json</h3><p>在上述练习文件夹中创建一个package.json文件，这是一个标准的npm说明文件，里面蕴含了丰富的信息，包括当前项目的依赖模块，自定义的脚本任务等等。在终端中使用npm init命令可以自动创建这个package.json文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm init</div></pre></td></tr></table></figure></p>
<p>package.json 里这个name 不能使用所需要安装包的名字！ </p>
<h3 id="创建新文件夹存放文件"><a href="#创建新文件夹存放文件" class="headerlink" title="创建新文件夹存放文件"></a>创建新文件夹存放文件</h3><p>回到之前的空文件夹，并在里面创建两个文件夹,source文件夹和public文件夹，source文件夹用来存放原始数据和我们将写的JavaScript模块，public文件夹用来存放之后供浏览器读取的文件（包括使用webpack打包生成的js文件以及一个index.html文件）。接下来我们再创建三个文件:<br>index.html –放在public文件夹中;<br>Greeter.js– 放在source文件夹中;<br>main.js– 放在source文件夹中;</p>
<h3 id="index-html-代码"><a href="#index-html-代码" class="headerlink" title="index.html 代码"></a>index.html 代码</h3><p>在index.html文件中写入最基础的html代码，它在这里目的在于引入打包后的js文件。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">&lt;!-- index.html --&gt;</div><div class="line">&lt;!DOCTYPE html&gt;</div><div class="line">&lt;html lang=&quot;en&quot;&gt;</div><div class="line">  &lt;head&gt;</div><div class="line">    &lt;meta charset=&quot;utf-8&quot;&gt;</div><div class="line">    &lt;title&gt;Webpack Sample Project&lt;/title&gt;</div><div class="line">  &lt;/head&gt;</div><div class="line">  &lt;body&gt;</div><div class="line">    &lt;div id=&apos;root&apos;&gt;</div><div class="line">    &lt;/div&gt;</div><div class="line">    &lt;script src=&quot;bundle.js&quot;&gt;&lt;/script&gt;</div><div class="line">  &lt;/body&gt;</div><div class="line">&lt;/html&gt;</div></pre></td></tr></table></figure></p>
<h3 id="Greeter-js"><a href="#Greeter-js" class="headerlink" title="Greeter.js"></a>Greeter.js</h3><p>在Greeter.js中定义一个返回包含问候信息的html元素的函数,并依据CommonJS规范导出这个函数为一个模块<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">// Greeter.js</div><div class="line">module.exports = function() &#123;</div><div class="line">  var greet = document.createElement(&apos;div&apos;);</div><div class="line">  greet.textContent = &quot;Hello World&quot;;</div><div class="line">  return greet;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<h3 id="main-js"><a href="#main-js" class="headerlink" title="main.js"></a>main.js</h3><p>在main.js文件中写入下述代码，用以把Greeter模块返回的节点插入页面。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">//main.js </div><div class="line">const greeter = require(&apos;./Greeter.js&apos;);</div><div class="line">document.querySelector(&quot;#root&quot;).appendChild(greeter());</div></pre></td></tr></table></figure></p>
<h3 id="通过配置文件来使用Webpack"><a href="#通过配置文件来使用Webpack" class="headerlink" title="通过配置文件来使用Webpack"></a>通过配置文件来使用Webpack</h3><p>在当前练习文件夹的根目录下新建一个名为webpack.config.js的文件，在其中写入如下所示的简单配置代码，目前的配置主要涉及到的内容是入口文件路径和打包后文件的存放路径。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">module.exports = &#123;</div><div class="line">  entry:  __dirname + &quot;/app/main.js&quot;,//唯一入口文件</div><div class="line">  output: &#123;</div><div class="line">    path: __dirname + &quot;/public&quot;,//打包后的文件存放的地方</div><div class="line">    filename: &quot;bundle.js&quot;//打包后输出文件的文件名</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="更快捷的执行打包任务"><a href="#更快捷的执行打包任务" class="headerlink" title="更快捷的执行打包任务"></a>更快捷的执行打包任务</h3><p>对npm进行配置后可以在命令行中使用简单的npm start命令打包任务。在package.json中对scripts对象进行相关设置即可，设置方法如下。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  &quot;name&quot;: &quot;webpackDemo&quot;,</div><div class="line">  &quot;version&quot;: &quot;1.0.0&quot;,</div><div class="line">  &quot;description&quot;: &quot;&quot;,</div><div class="line">  &quot;main&quot;: &quot;index.js&quot;,</div><div class="line">  &quot;scripts&quot;: &#123;</div><div class="line">    &quot;start&quot;: &quot;webpack&quot;</div><div class="line">  &#125;,</div><div class="line">  &quot;author&quot;: &quot;wangmanna&quot;,</div><div class="line">  &quot;license&quot;: &quot;ISC&quot;,</div><div class="line">  &quot;devDependencies&quot;: &#123;</div><div class="line">    &quot;webpack&quot;: &quot;^4.39.3&quot;,</div><div class="line">    &quot;webpack-cli&quot;: &quot;^3.3.8&quot;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>npm的start命令是一个特殊的脚本名称，其特殊性表现在，在命令行中使用npm start就可以执行其对于的命令，如果对应的此脚本名称不是start，想要在命令行中运行时，需要这样用npm run {script name}如npm run build，在命令行中输入npm start，输出结果如下：<br><img src="/images/posts/cmd_npm_start.png" alt=""></p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;安装Webpack&quot;&gt;&lt;a href=&quot;#安装Webpack&quot; class=&quot;headerlink&quot; title=&quot;安装Webpack&quot;&gt;&lt;/a&gt;安装Webpack&lt;/h3&gt;&lt;p&gt;新建一个空文件夹 ，打开cmd运行命令&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;//全局安装&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;npm install -g webpack&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;//安装到你的项目目录&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;npm install --save-dev webpack&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="前端笔记" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Webpack" scheme="http://yoursite.com/tags/Webpack/"/>
    
  </entry>
  
  <entry>
    <title>ios input输入框光标掉落问题</title>
    <link href="http://yoursite.com/2019/09/10/ios%20input%E8%BE%93%E5%85%A5%E6%A1%86%E5%85%89%E6%A0%87%E6%8E%89%E8%90%BD%E9%97%AE%E9%A2%98/"/>
    <id>http://yoursite.com/2019/09/10/ios input输入框光标掉落问题/</id>
    <published>2019-09-10T04:34:51.000Z</published>
    <updated>2020-04-26T07:26:55.631Z</updated>
    
    <content type="html"><![CDATA[<p>最近在做的一个移动端页面在ios手机上，输入框的光标出现了一个问题，</p>
<p>页面是一个弹出的评论弹窗，用的是position:fixed;定位<br>输入框的在ios11手机上出现光标掉落的问题</p>
<p>解决方法<br>修改body的定位为fixed<br>关闭弹框之后得将body的定位修改回去</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近在做的一个移动端页面在ios手机上，输入框的光标出现了一个问题，&lt;/p&gt;
&lt;p&gt;页面是一个弹出的评论弹窗，用的是position:fixed;定位&lt;br&gt;输入框的在ios11手机上出现光标掉落的问题&lt;/p&gt;
&lt;p&gt;解决方法&lt;br&gt;修改body的定位为fixed&lt;br&gt;关
    
    </summary>
    
      <category term="浏览器兼容" scheme="http://yoursite.com/categories/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%85%BC%E5%AE%B9/"/>
    
    
      <category term="移动端兼容问题" scheme="http://yoursite.com/tags/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E5%85%BC%E5%AE%B9%E9%97%AE%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>js 99乘法表</title>
    <link href="http://yoursite.com/2018/09/18/js-99%E4%B9%98%E6%B3%95%E8%A1%A8/"/>
    <id>http://yoursite.com/2018/09/18/js-99乘法表/</id>
    <published>2018-09-18T05:23:10.000Z</published>
    <updated>2020-04-26T07:26:55.642Z</updated>
    
    <content type="html"><![CDATA[<p>代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">//九九乘法表</div><div class="line">  function multiplication_table()&#123;</div><div class="line">      for(var i=1;i&lt;=9;i++)&#123;</div><div class="line">          for(var j=1;j&lt;=i;j++)&#123;</div><div class="line">              document.write(j+&quot;×&quot;+i+&quot;=&quot;+i*j+&quot;&amp;nbsp;&amp;nbsp;&amp;nbsp;&quot;);</div><div class="line">          &#125;</div><div class="line">          document.write(&quot;&lt;br&gt;&quot;)</div><div class="line">      &#125;</div><div class="line">  &#125;</div><div class="line">  multiplication_table();</div></pre></td></tr></table></figure></p>
<p>效果<br><img src="/images/posts/2019-09-18 132510.png" alt=""></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;代码&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;li
    
    </summary>
    
      <category term="前端笔记" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>Router路由</title>
    <link href="http://yoursite.com/2018/09/03/React%E8%B7%AF%E7%94%B1/"/>
    <id>http://yoursite.com/2018/09/03/React路由/</id>
    <published>2018-09-03T13:43:57.000Z</published>
    <updated>2020-04-26T07:26:55.625Z</updated>
    
    <content type="html"><![CDATA[<p>路由<br>根据请求不同返回不同页面</p>
<p>React插件 React-router</p>
<h4 id="准备React组件"><a href="#准备React组件" class="headerlink" title="准备React组件"></a>准备React组件</h4><h5 id="React-Router-npm安装"><a href="#React-Router-npm安装" class="headerlink" title="React Router npm安装"></a>React Router npm安装</h5><blockquote>
<p>npm install react-router –save-dev</p>
</blockquote>
<h5 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">improt &#123;Router，Route，hasHistory&#125; from &quot;react-router&quot;</div></pre></td></tr></table></figure>
<p>上面的代码相当于<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">import ReactRouter from &quot;react-router&quot;</div><div class="line">var Router = ReactRouter.Router;</div><div class="line">var Route = ReactRouter.Route;</div><div class="line">var hasHistory = ReactRouter.hasHistory;</div></pre></td></tr></table></figure></p>
<p>Router是整个大的路由<br>Route代表一个路由项</p>
<p><font color="blue">Router</font>组件本身只是个容器，真正的路由要通过Route组件定义<br><a id="more"></a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">render()&#123;</div><div class="line">    return(</div><div class="line">        &lt;Router history=&#123;hasHistory&#125;&gt;</div><div class="line">            &lt;Route path=&quot;/&quot; component=&#123;IndexComponent&#125; /&gt;</div><div class="line">            &lt;Route path=&quot;/&quot; component=&#123;DetailComponent&#125; /&gt;</div><div class="line">        &lt;/Router&gt;</div><div class="line">        )</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>上面Router组件有一个参数history,它的值hasHistory表示，路由的切换由url的hash变化决定，即URL的#部分发生变化。举例来说，用户访问<a href="http://www.example.com/" target="_blank" rel="external">http://www.example.com/</a> , 实际上会看到的是<a href="http://www.example.com/#/" target="_blank" rel="external">http://www.example.com/#/</a>.<br>Router组件定义了URL路径与组件的对应关系。可以使用多个Route组件。</p>
<h4 id="路由嵌套"><a href="#路由嵌套" class="headerlink" title="路由嵌套"></a>路由嵌套</h4><p>Route组件还可以嵌套<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&lt;Router history=&#123;hashHistory&#125;&gt;</div><div class="line">  &lt;Route path=&quot;/&quot; component=&#123;App&#125;&gt;</div><div class="line">    &lt;Route path=&quot;/repos&quot; component=&#123;Repos&#125;/&gt;</div><div class="line">    &lt;Route path=&quot;/about&quot; component=&#123;About&#125;/&gt;</div><div class="line">  &lt;/Route&gt;</div><div class="line">&lt;/Router&gt;</div></pre></td></tr></table></figure></p>
<p>上面的代码中，用户访问/repos时，会先加载APP组件，然后再在它内部再加载Repos组件。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;App&gt;</div><div class="line">    &lt;Repos /&gt;</div><div class="line">&lt;/App&gt;</div></pre></td></tr></table></figure></p>
<p>App组件要写成下面的样子<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">export default React.createClass(&#123;</div><div class="line">  render() &#123;</div><div class="line">    return &lt;div&gt;</div><div class="line">      &#123;this.props.children&#125;</div><div class="line">    &lt;/div&gt;</div><div class="line">  &#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<p>上面的代码中，App组件的this.props.children属性就是子组件。<br>子路由也可以不写在Router组件里面，单独传入Router组件的routes属性。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">let routes = &lt;Route path=&quot;/&quot; component=&#123;App&#125;&gt;</div><div class="line">  &lt;Route path=&quot;/repos&quot; component=&#123;Repos&#125;/&gt;</div><div class="line">  &lt;Route path=&quot;/about&quot; component=&#123;About&#125;/&gt;</div><div class="line">&lt;/Route&gt;;</div><div class="line"></div><div class="line">&lt;Router routes=&#123;routes&#125; history=&#123;browserHistory&#125;/&gt;</div></pre></td></tr></table></figure></p>
<h4 id="path属性"><a href="#path属性" class="headerlink" title="path属性"></a>path属性</h4><p>Route组件的path属性指定路由的匹配规则。这个属性是可以省略的，这样的话，不管路径是否匹配，总是会加载指定组件。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;Route path=&quot;inbox&quot; component=&#123;Inbox&#125;&gt;</div><div class="line">    &lt;Route path=&quot;message/:id&quot; component=&#123;Message&#125; /&gt;</div><div class="line">&lt;/Route&gt;</div></pre></td></tr></table></figure></p>
<p>上面的代码中，当用户访问/inbox/message/:id时，会加载下面的组件。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;Inbox&gt;</div><div class="line">    &lt;Message /&gt;</div><div class="line">&lt;/Inbox&gt;</div></pre></td></tr></table></figure></p>
<p>如果是省略外层Route的path参数，写成下面的样子。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;Route component=&#123;Inbox&#125;&gt;</div><div class="line">    &lt;Route path=&quot;inbox/message/:id&quot; component=&#123;Message&#125; /&gt;</div><div class="line">&lt;/Route&gt;</div></pre></td></tr></table></figure></p>
<p>现在用户访问/inbox/message/:id时，组件加载还是原来的样子</p>
<h4 id="通配符"><a href="#通配符" class="headerlink" title="通配符"></a>通配符</h4><p>path属性可以使用通配符<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">&lt;Route path=&quot;/hello/:name&quot;&gt;</div><div class="line">//匹配 /hello/michael</div><div class="line">//匹配 /hello/rerf</div><div class="line"></div><div class="line">&lt;Route path=&quot;/hello(/:name)&quot;&gt;</div><div class="line">//匹配 /hello</div><div class="line">//匹配 /hello/asda</div><div class="line"></div><div class="line">&lt;Route path=&quot;/files/*.*&quot;&gt;</div><div class="line">//匹配 /files/hello.jpg</div><div class="line">//匹配 /files/hello.html</div><div class="line"></div><div class="line">&lt;Route path=&quot;/files/*&quot;&gt;</div><div class="line">//匹配 /files/</div><div class="line">//匹配 /files/a</div><div class="line">//匹配 /files/a/s</div><div class="line"></div><div class="line">&lt;Route path=&quot;/**/*.jpg&quot;&gt;</div><div class="line">// 匹配 /files/hello.jpg</div><div class="line">// 匹配 /files/path/to/file.jpg</div></pre></td></tr></table></figure></p>
<p>通配符的规则如下。</p>
<ol>
<li>:paramName<br>:paramName匹配URL的一个部分，直到遇到下一个/、?、#为止。这个路径参数可以通过this.props.params.paramName取出。</li>
<li>()<br>()表示URL的这个部分是可选的。</li>
<li>*<br>*匹配任意字符，直到模式里面的下一个字符为止。匹配方式是非贪婪模式。</li>
<li>**<br>** 匹配任意字符，直到下一个/、?、#为止。匹配方式是贪婪模式。<br>path属性也可以使用相对路径（不以/开头），匹配时就会相对于父组件的路径，可以参考上一节的例子。嵌套路由如果想摆脱这个规则，可以使用绝对路由。<br>路由匹配规则是从上到下执行，一旦发现匹配，就不再其余的规则了。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&lt;Route path=&quot;/comments&quot; ... /&gt;</div><div class="line">&lt;Route path=&quot;/comments&quot; ... /&gt;</div></pre></td></tr></table></figure>
</li>
</ol>
<p>上面代码中，路径/comments同时匹配两个规则，第二个规则不会生效。<br>设置路径参数时，需要特别小心这一点。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;Router&gt;</div><div class="line">  &lt;Route path=&quot;/:userName/:id&quot; component=&#123;UserPage&#125;/&gt;</div><div class="line">  &lt;Route path=&quot;/about/me&quot; component=&#123;About&#125;/&gt;</div><div class="line">&lt;/Router&gt;</div></pre></td></tr></table></figure></p>
<p>上面代码中，用户访问/about/me时，不会触发第二个路由规则，因为它会匹配/:userName/:id这个规则。因此，带参数的路径一般要写在路由规则的底部。<br>此外，URL的查询字符串/foo?bar=baz，可以用this.props.location.query.bar获取。</p>
<h4 id="IndexRoute-组件"><a href="#IndexRoute-组件" class="headerlink" title="IndexRoute 组件"></a>IndexRoute 组件</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&lt;Router&gt;</div><div class="line">  &lt;Route path=&quot;/&quot; component=&#123;App&#125;&gt;</div><div class="line">    &lt;Route path=&quot;accounts&quot; component=&#123;Accounts&#125;/&gt;</div><div class="line">    &lt;Route path=&quot;statements&quot; component=&#123;Statements&#125;/&gt;</div><div class="line">  &lt;/Route&gt;</div><div class="line">&lt;/Router&gt;</div></pre></td></tr></table></figure>
<p>上面代码中，访问根路径/，不会加载任何子组件。也就是说，App组件的this.props.children，这时是undefined。<br>因此，通常会采用{this.props.children || <home>}这样的写法。这时，Home明明是Accounts和Statements的同级组件，却没有写在Route中。<br>IndexRoute就是解决这个问题，显式指定Home是根路由的子组件，即指定默认情况下加载的子组件。你可以把IndexRoute想象成某个路径的index.html。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&lt;Router&gt;</div><div class="line">  &lt;Route path=&quot;/&quot; component=&#123;App&#125;&gt;</div><div class="line">    &lt;IndexRoute component=&#123;Home&#125;/&gt;</div><div class="line">    &lt;Route path=&quot;accounts&quot; component=&#123;Accounts&#125;/&gt;</div><div class="line">    &lt;Route path=&quot;statements&quot; component=&#123;Statements&#125;/&gt;</div><div class="line">  &lt;/Route&gt;</div><div class="line">&lt;/Router&gt;</div></pre></td></tr></table></figure></home></p>
<p>现在，用户访问/的时候，加载的组件结构如下。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;App&gt;</div><div class="line">  &lt;Home/&gt;</div><div class="line">&lt;/App&gt;</div></pre></td></tr></table></figure></p>
<p>这种组件结构就很清晰了：App只包含下级组件的共有元素，本身的展示内容则由Home组件定义。这样有利于代码分离，也有利于使用React Router提供的各种API。<br>注意，IndexRoute组件没有路径参数path。</p>
<h4 id="Redirect-组件"><a href="#Redirect-组件" class="headerlink" title="Redirect 组件"></a>Redirect 组件</h4><p><redirect>组件用于路由的跳转，即用户访问一个路由，会自动跳转到另一个路由。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;Route path=&quot;inbox&quot; component=&#123;Inbox&#125;&gt;</div><div class="line">  &#123;/* 从 /inbox/messages/:id 跳转到 /messages/:id */&#125;</div><div class="line">  ＜Redirect from=&quot;messages/:id&quot; to=&quot;/messages/:id&quot; /&gt;</div><div class="line">&lt;/Route&gt;</div></pre></td></tr></table></figure></redirect></p>
<p>现在访问/inbox/messages/5，会自动跳转到/messages/5。</p>
<h4 id="IndexRedirect-组件"><a href="#IndexRedirect-组件" class="headerlink" title="IndexRedirect 组件"></a>IndexRedirect 组件</h4><p>IndexRedirect组件用于访问根路由的时候，将用户重定向到某个子组件。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;Route path=&quot;/&quot; component=&#123;App&#125;&gt;</div><div class="line">  &lt;IndexRedirect to=&quot;/welcome&quot; /&gt;</div><div class="line">  &lt;Route path=&quot;welcome&quot; component=&#123;Welcome&#125; /&gt;</div><div class="line">  &lt;Route path=&quot;about&quot; component=&#123;About&#125; /&gt;</div><div class="line">&lt;/Route&gt;</div></pre></td></tr></table></figure></p>
<p>上面代码中，用户访问根路径时，将自动重定向到子组件welcome。</p>
<h4 id="Link"><a href="#Link" class="headerlink" title="Link"></a>Link</h4><p>Link组件用于取代<a>元素，生成一个链接，允许用户点击后跳转到另一个路由。它基本上就是<a>元素的React 版本，可以接收Router的状态。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">render() &#123;</div><div class="line">  return &lt;div&gt;</div><div class="line">    &lt;ul role=&quot;nav&quot;&gt;</div><div class="line">      &lt;li&gt;&lt;Link to=&quot;/about&quot;&gt;About&lt;/Link&gt;&lt;/li&gt;</div><div class="line">      &lt;li&gt;&lt;Link to=&quot;/repos&quot;&gt;Repos&lt;/Link&gt;&lt;/li&gt;</div><div class="line">    &lt;/ul&gt;</div><div class="line">  &lt;/div&gt;</div><div class="line">&#125;</div></pre></td></tr></table></figure></a></a></p>
<p>如果希望当前的路由与其他路由有不同样式，这时可以使用Link组件的activeStyle属性。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&lt;Link to=&quot;/about&quot; activeStyle=&#123;&#123;color: &apos;red&apos;&#125;&#125;&gt;About&lt;/Link&gt;</div><div class="line">&lt;Link to=&quot;/repos&quot; activeStyle=&#123;&#123;color: &apos;red&apos;&#125;&#125;&gt;Repos&lt;/Link&gt;</div></pre></td></tr></table></figure></p>
<p>上面代码中，当前页面的链接会红色显示。<br>另一种做法是，使用activeClassName指定当前路由的Class。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&lt;Link to=&quot;/about&quot; activeClassName=&quot;active&quot;&gt;About&lt;/Link&gt;</div><div class="line">&lt;Link to=&quot;/repos&quot; activeClassName=&quot;active&quot;&gt;Repos&lt;/Link&gt;</div></pre></td></tr></table></figure></p>
<p>上面代码中，当前页面的链接的class会包含active。<br>在Router组件之外，导航到路由页面，可以使用浏览器的History API，像下面这样写。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">import &#123; browserHistory &#125; from &apos;react-router&apos;;</div><div class="line">browserHistory.push(&apos;/some/path&apos;);</div></pre></td></tr></table></figure></p>
<h4 id="IndexLink"><a href="#IndexLink" class="headerlink" title="IndexLink"></a>IndexLink</h4><p>如果链接到根路由/，不要使用Link组件，而要使用IndexLink组件。<br>这是因为对于根路由来说，activeStyle和activeClassName会失效，或者说总是生效，因为/会匹配任何子路由。而IndexLink组件会使用路径的精确匹配。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;IndexLink to=&quot;/&quot; activeClassName=&quot;active&quot;&gt;</div><div class="line">  Home</div><div class="line">&lt;/IndexLink&gt;</div></pre></td></tr></table></figure></p>
<p>上面代码中，根路由只会在精确匹配时，才具有activeClassName。<br>另一种方法是使用Link组件的onlyActiveOnIndex属性，也能达到同样效果。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;Link to=&quot;/&quot; activeClassName=&quot;active&quot; onlyActiveOnIndex=&#123;true&#125;&gt;</div><div class="line">  Home</div><div class="line">&lt;/Link&gt;</div></pre></td></tr></table></figure></p>
<p>实际上，IndexLink就是对Link组件的onlyActiveOnIndex属性的包装。</p>
<h4 id="histroy-属性"><a href="#histroy-属性" class="headerlink" title="histroy 属性"></a>histroy 属性</h4><p>Router组件的history属性，用来监听浏览器地址栏的变化，并将URL解析成一个地址对象，供 React Router 匹配。<br>history属性，一共可以设置三种值。</p>
<blockquote>
<p>browserHistory<br>hashHistory<br>createMemoryHistory</p>
</blockquote>
<p>如果设为hashHistory，路由将通过URL的hash部分（#）切换，URL的形式类似example.com/#/some/path。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">import &#123; hashHistory &#125; from &apos;react-router&apos;</div><div class="line"></div><div class="line">render(</div><div class="line">  &lt;Router history=&#123;hashHistory&#125; routes=&#123;routes&#125; /&gt;,</div><div class="line">  document.getElementById(&apos;app&apos;)</div><div class="line">)</div></pre></td></tr></table></figure></p>
<p>如果设为browserHistory，浏览器的路由就不再通过Hash完成了，而显示正常的路径example.com/some/path，背后调用的是浏览器的History API。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">import &#123; browserHistory &#125; from &apos;react-router&apos;</div><div class="line"></div><div class="line">render(</div><div class="line">  &lt;Router history=&#123;browserHistory&#125; routes=&#123;routes&#125; /&gt;,</div><div class="line">  document.getElementById(&apos;app&apos;)</div><div class="line">)</div></pre></td></tr></table></figure></p>
<p>但是，这种情况需要对服务器改造。否则用户直接向服务器请求某个子路由，会显示网页找不到的404错误。<br>如果开发服务器使用的是webpack-dev-server，加上–history-api-fallback参数就可以了。</p>
<blockquote>
<p>$ webpack-dev-server –inline –content-base . –history-api-fallback<br>createMemoryHistory主要用于服务器渲染。它创建一个内存中的history对象，不与浏览器URL互动。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">const history = createMemoryHistory(location)</div></pre></td></tr></table></figure>
<h4 id="表单处理"><a href="#表单处理" class="headerlink" title="表单处理"></a>表单处理</h4><p>Link组件用于正常的用户点击跳转，但是有时还需要表单跳转、点击按钮跳转等操作。这些情况怎么跟React Router对接呢？<br>下面是一个表单。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;form onSubmit=&#123;this.handleSubmit&#125;&gt;</div><div class="line">  &lt;input type=&quot;text&quot; placeholder=&quot;userName&quot;/&gt;</div><div class="line">  &lt;input type=&quot;text&quot; placeholder=&quot;repo&quot;/&gt;</div><div class="line">  &lt;button type=&quot;submit&quot;&gt;Go&lt;/button&gt;</div><div class="line">&lt;/form&gt;</div></pre></td></tr></table></figure></p>
<p>第一种方法是使用browserHistory.push<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">import &#123; browserHistory &#125; from &apos;react-router&apos;</div><div class="line"></div><div class="line">// ...</div><div class="line">  handleSubmit(event) &#123;</div><div class="line">    event.preventDefault()</div><div class="line">    const userName = event.target.elements[0].value</div><div class="line">    const repo = event.target.elements[1].value</div><div class="line">    const path = `/repos/$&#123;userName&#125;/$&#123;repo&#125;`</div><div class="line">    browserHistory.push(path)</div><div class="line">  &#125;,</div></pre></td></tr></table></figure></p>
<p>第二种方法是使用context对象。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">export default React.createClass(&#123;</div><div class="line"></div><div class="line">  // ask for `router` from context</div><div class="line">  contextTypes: &#123;</div><div class="line">    router: React.PropTypes.object</div><div class="line">  &#125;,</div><div class="line"></div><div class="line">  handleSubmit(event) &#123;</div><div class="line">    // ...</div><div class="line">    this.context.router.push(path)</div><div class="line">  &#125;,</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<h4 id="路由的钩子"><a href="#路由的钩子" class="headerlink" title="路由的钩子"></a>路由的钩子</h4><p>每个路由都有Enter和Leave钩子，用户进入或离开该路由时触发。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;Route path=&quot;about&quot; component=&#123;About&#125; /&gt;</div><div class="line">&lt;Route path=&quot;inbox&quot; component=&#123;Inbox&#125;&gt;</div><div class="line">    &lt;Redirect from=&quot;messages/:id&quot; to=&quot;/messages/:id&quot; /&gt;</div><div class="line">&lt;/Route&gt;</div></pre></td></tr></table></figure></p>
<p>上面的代码中，如果用户离开/messages/:id，进入/about时，会依次触发以下的钩子。<br>/messages/:id的onLeave<br>/inbox的onLeave<br>/about的onEnter<br>下面是一个例子，使用onEnter钩子替代<redirect>组件。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&lt;Route path=&quot;inbox&quot; component=&#123;Inbox&#125;&gt;</div><div class="line">  &lt;Route</div><div class="line">    path=&quot;messages/:id&quot;</div><div class="line">    onEnter=&#123;</div><div class="line">      (&#123;params&#125;, replace) =&gt; replace(`/messages/$&#123;params.id&#125;`)</div><div class="line">    &#125;</div><div class="line">  /&gt;</div><div class="line">&lt;/Route&gt;</div></pre></td></tr></table></figure></redirect></p>
<p>onEnter钩子还可以用来做认证。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">const requireAuth = (nextState, replace) =&gt; &#123;</div><div class="line">    if (!auth.isAdmin()) &#123;</div><div class="line">        // Redirect to Home page if not an Admin</div><div class="line">        replace(&#123; pathname: &apos;/&apos; &#125;)</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">export const AdminRoutes = () =&gt; &#123;</div><div class="line">  return (</div><div class="line">     &lt;Route path=&quot;/admin&quot; component=&#123;Admin&#125; onEnter=&#123;requireAuth&#125; /&gt;</div><div class="line">  )</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>下面是一个高级应用，当用户离开一个路径的时候，跳出一个提示框，要求用户确认是否离开。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">const Home = withRouter(</div><div class="line">  React.createClass(&#123;</div><div class="line">    componentDidMount() &#123;</div><div class="line">      this.props.router.setRouteLeaveHook(</div><div class="line">        this.props.route,</div><div class="line">        this.routerWillLeave</div><div class="line">      )</div><div class="line">    &#125;,</div><div class="line"></div><div class="line">    routerWillLeave(nextLocation) &#123;</div><div class="line">      // 返回 false 会继续停留当前页面，</div><div class="line">      // 否则，返回一个字符串，会显示给用户，让其自己决定</div><div class="line">      if (!this.state.isSaved)</div><div class="line">        return &apos;确认要离开？&apos;;</div><div class="line">    &#125;,</div><div class="line">  &#125;)</div><div class="line">)</div></pre></td></tr></table></figure></p>
<p>上面代码中，setRouteLeaveHook方法为Leave钩子指定routerWillLeave函数。该方法如果返回false，将阻止路由的切换，否则就返回一个字符串，提示用户决定是否要切换。</p>
<p>用browserHistory到一个子页面刷新页面不好使<br>在webpack.configz中配置,加上    historyApiFallback: true,</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;路由&lt;br&gt;根据请求不同返回不同页面&lt;/p&gt;
&lt;p&gt;React插件 React-router&lt;/p&gt;
&lt;h4 id=&quot;准备React组件&quot;&gt;&lt;a href=&quot;#准备React组件&quot; class=&quot;headerlink&quot; title=&quot;准备React组件&quot;&gt;&lt;/a&gt;准备React组件&lt;/h4&gt;&lt;h5 id=&quot;React-Router-npm安装&quot;&gt;&lt;a href=&quot;#React-Router-npm安装&quot; class=&quot;headerlink&quot; title=&quot;React Router npm安装&quot;&gt;&lt;/a&gt;React Router npm安装&lt;/h5&gt;&lt;blockquote&gt;
&lt;p&gt;npm install react-router –save-dev&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h5 id=&quot;引入&quot;&gt;&lt;a href=&quot;#引入&quot; class=&quot;headerlink&quot; title=&quot;引入&quot;&gt;&lt;/a&gt;引入&lt;/h5&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;improt &amp;#123;Router，Route，hasHistory&amp;#125; from &amp;quot;react-router&amp;quot;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;上面的代码相当于&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;import ReactRouter from &amp;quot;react-router&amp;quot;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;var Router = ReactRouter.Router;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;var Route = ReactRouter.Route;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;var hasHistory = ReactRouter.hasHistory;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;Router是整个大的路由&lt;br&gt;Route代表一个路由项&lt;/p&gt;
&lt;p&gt;&lt;font color=&quot;blue&quot;&gt;Router&lt;/font&gt;组件本身只是个容器，真正的路由要通过Route组件定义&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="React" scheme="http://yoursite.com/categories/React/"/>
    
    
      <category term="React" scheme="http://yoursite.com/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>vue全局组件和局部组件</title>
    <link href="http://yoursite.com/2018/09/03/vue%E5%85%A8%E5%B1%80%E7%BB%84%E4%BB%B6%E5%92%8C%E5%B1%80%E9%83%A8%E7%BB%84%E4%BB%B6/"/>
    <id>http://yoursite.com/2018/09/03/vue全局组件和局部组件/</id>
    <published>2018-09-03T04:29:28.000Z</published>
    <updated>2020-04-26T07:26:55.646Z</updated>
    
    <content type="html"><![CDATA[<h3 id="全局组件"><a href="#全局组件" class="headerlink" title="全局组件"></a>全局组件</h3><p>全局组件的实现</p>
<ol>
<li><p>注册全局组件<br>使用Vue.component(tagName,options)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Vue.component(&apos;my-component&apos;,&#123;</div><div class="line">    //选项</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
</li>
<li><p>注册完成后，在父实例的模板中使用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;div id=&quot;example&quot;&gt;</div><div class="line">    &lt;my-component&gt;&lt;/my-component&gt;</div><div class="line">&lt;/div&gt;</div></pre></td></tr></table></figure>
</li>
</ol>
<a id="more"></a>
<h3 id="局部注册"><a href="#局部注册" class="headerlink" title="局部注册"></a>局部注册</h3><p>不用在全局注册每个组件。通过使用组件实例选项注册，可以使组件仅在另一个实例/组件的作用域中可用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">var Child = &#123;</div><div class="line">    template: &apos;&apos;</div><div class="line">&#125;</div><div class="line">new Vue(&#123;</div><div class="line">    components: &#123;</div><div class="line">        &apos;my-component&apos;: Child</div><div class="line">    &#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<h3 id="全局组件和局部组件的区别"><a href="#全局组件和局部组件的区别" class="headerlink" title="全局组件和局部组件的区别"></a>全局组件和局部组件的区别</h3><ul>
<li>全局组件：Vue中所有的实例都能使用该组件</li>
<li>局部组件： 只能在当前实例中使用该组件</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;全局组件&quot;&gt;&lt;a href=&quot;#全局组件&quot; class=&quot;headerlink&quot; title=&quot;全局组件&quot;&gt;&lt;/a&gt;全局组件&lt;/h3&gt;&lt;p&gt;全局组件的实现&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;注册全局组件&lt;br&gt;使用Vue.component(tagName,options)&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;Vue.component(&amp;apos;my-component&amp;apos;,&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    //选项&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;)&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;注册完成后，在父实例的模板中使用&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&amp;lt;div id=&amp;quot;example&amp;quot;&amp;gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;lt;my-component&amp;gt;&amp;lt;/my-component&amp;gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;lt;/div&amp;gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="Vue" scheme="http://yoursite.com/categories/Vue/"/>
    
    
      <category term="Vue" scheme="http://yoursite.com/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>React-虚拟DOM</title>
    <link href="http://yoursite.com/2018/08/15/React-%E8%99%9A%E6%8B%9FDOM/"/>
    <id>http://yoursite.com/2018/08/15/React-虚拟DOM/</id>
    <published>2018-08-15T00:36:50.000Z</published>
    <updated>2020-04-26T07:26:55.622Z</updated>
    
    <content type="html"><![CDATA[<h4 id="虚拟DOM"><a href="#虚拟DOM" class="headerlink" title="虚拟DOM"></a>虚拟DOM</h4><p>虚拟DOM是React的基石，<br>DOM操作非常昂贵。在前端开发中，性能消耗最大的就是DOM操作，而且这部分代码会让整体项目的代码变得难以维护。React把真实DOM树转换成JavaScript对象树，也就是Virtual DOM。<br>React之所以快，是因为他不直接操作DOM。React将DOM结构存储在内存中，然后同render()的返回内容进行比较，计算出需要改动的地方，最后才反映到DOM中。<br>此外，React实现了一套完整的事件合成机制，能够保持事件冒泡的一致性，跨浏览器执行。甚至可以在IE8中使用HTML5的事件。</p>
<h4 id="Refs和findDOMNode"><a href="#Refs和findDOMNode" class="headerlink" title="Refs和findDOMNode()"></a>Refs和findDOMNode()</h4><p>为了同浏览器交互，我们有时候需要获取到真实的DOM节点。我们可以通过调用React的React.findDOMNode(component)获取到组件中真实的DOM。</p>
<blockquote>
<p>React.findDOMNode()只在mounted组件中调用，mounted组件就是已经渲染在浏览器DOM结构中的组件。如果你在组件的render()方法中调用React.findDOMNode()就会抛出异常。</p>
</blockquote>
<p>大部分情况下，我们都是在构建React的组件，也就是操作虚拟DOM。但是有时候我们需要访问底层的API，可能或通过使用第三方的插件来实现我们的功能，如jQuery。React也提供了接口让我们操作底层API。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;虚拟DOM&quot;&gt;&lt;a href=&quot;#虚拟DOM&quot; class=&quot;headerlink&quot; title=&quot;虚拟DOM&quot;&gt;&lt;/a&gt;虚拟DOM&lt;/h4&gt;&lt;p&gt;虚拟DOM是React的基石，&lt;br&gt;DOM操作非常昂贵。在前端开发中，性能消耗最大的就是DOM操作，而且这部分代码
    
    </summary>
    
      <category term="React" scheme="http://yoursite.com/categories/React/"/>
    
    
      <category term="React" scheme="http://yoursite.com/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>Redux基本用法</title>
    <link href="http://yoursite.com/2018/08/14/Redux%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95/"/>
    <id>http://yoursite.com/2018/08/14/Redux基本用法/</id>
    <published>2018-08-14T12:00:01.000Z</published>
    <updated>2020-04-26T07:26:55.626Z</updated>
    
    <content type="html"><![CDATA[<p>React和Redux之间的关系</p>
<h4 id="Redux是什么？"><a href="#Redux是什么？" class="headerlink" title="Redux是什么？"></a>Redux是什么？</h4><p>Redux是Facebook提出的flux架构的一种优秀实现；而且不局限于为react提供数据处理状态。它是零依赖的，可以配合其他任何框架或类库一起使用。要想配合react，还得引入react-redux。<br>Redux简单的说就是一个事件分发器和全局state控制台。</p>
<h4 id="什么时候使用Redux"><a href="#什么时候使用Redux" class="headerlink" title="什么时候使用Redux"></a>什么时候使用Redux</h4><p>首先，Redux是一个有用的框架，但不是非用不可。事实上，大多数情况下，可以不用他，只用React就够了</p>
<a id="more"></a>
<p>曾经有人过这样一句话。</p>
<blockquote>
<p>“如果你不知道是否需要 Redux，那就是不需要它。”</p>
</blockquote>
<p>Redux 的创造者 Dan Abramov 又补充了一句。</p>
<blockquote>
<p>“只有遇到 React 实在解决不了的问题，你才需要 Redux 。”</p>
</blockquote>
<p>简单滴来说，如果UI层设计的非常简单，没有很多互动，Redux就是不必要的，用了反而增加了复杂性</p>
<ul>
<li>用户的使用方式非常简单</li>
<li>用户之间没有协作</li>
<li>不需要与服务器大量交互，也没有使用Websocket</li>
<li>视图层(view)只从单一来源获取数据</li>
</ul>
<p>以上这些情况，都不需要使用Redux。</p>
<ul>
<li>用户的使用方式复杂</li>
<li>不同身份的用户有不同的使用方式(比如普通用户和管理员)</li>
<li>多个用户可以协作</li>
<li>与服务器大量交互，或者使用了WebSocket</li>
<li>View要从多个来源获取数据</li>
</ul>
<p>上面这些情况才是Redux的适用场景：多交互，多数据源。</p>
<p>从组件的角度看，如果应用中有一下场景，可以考虑使用Redux</p>
<ul>
<li>某个组件的状态，需要共享</li>
<li>某个状态需要在任何地方都可以拿到</li>
<li>一个组件需要改变全局状态</li>
<li>一个组件需要改变另一个组件的状态</li>
</ul>
<p>发生上面的情况时，如果不使用Redux或者其他状态管理工具，不按照一定的规律处理状态的读写，代码很快就会变成一团乱麻。你需要一种机制，可以在同一个地方查询状态，改变状态，传播状态的变化。<br>总而言之，Redux只是Web架构的一种解决方案，也可以选择其他方案。</p>
<h4 id="三大原则"><a href="#三大原则" class="headerlink" title="三大原则"></a>三大原则</h4><p><strong>1. 单一的数据源</strong><br>整个应用的state被存储在一棵Object tree中，并且这个Object tree只存在于唯一一个store中。<br>这让同构应用开发变得非常容易。来自服务端的state可以在无需编写更多代码的情况下被序列化并注入到客户端中。由于是单一的state tree，调试也变得非常容易。在开发中可以把应用的state保存在本地，从而加快开发速度。此外，受益于单一的state tree，以前难以实现的如“撤销/重做”这类功能也变得轻而易举。</p>
<p><strong>2. state是只读的</strong><br>唯一改变state的方法就是触发action，action是一个用于描述已发生事件的普通对象。<br>这样确保了视图和网络请求都不能直接修改state，相反它们只能表达想要修改的意图。因为所有的修改都被集中化处理，且严格按照一个接一个的顺序执行，因此不用担心race condition的出现。Action就是普通对象而已，因此它们可以被日志打印，序列化，存储，后期调试或测试时回放出来。</p>
<p><strong>3. 使用纯函数来执行修改</strong><br>为了描述action如何改变statetree，需要编写reducers，只要是同样的输入，必定要得到同样的输出</p>
<h4 id="Redux设计思想"><a href="#Redux设计思想" class="headerlink" title="Redux设计思想"></a>Redux设计思想</h4><ol>
<li>web应用是一个状态机，视图与状态是一一对应的。</li>
<li>所有的状态，保存在一个对象里面</li>
</ol>
<h4 id="基本API"><a href="#基本API" class="headerlink" title="基本API"></a>基本API</h4><p>用户通过View，dispatch 相应的action，store调用reducer获取最新的state，并触发通过subscribe订阅的监听函数，监听函数中我们通过store的getState方法获取最新的state，更新view。<br>工作流程图<br><img src="http://upload-images.jianshu.io/upload_images/6982694-4bd3aeccdde1c1f3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p><strong>1.Store</strong><br>Store就是保存数据的地方，可以把它看成一个容器。整个应用只能有一个store。<br>Redux提供createStore这个函数，用来生成Store。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">import &#123;createStore&#125; form &quot;redux&quot;;</div><div class="line">const store = createStore(fn);</div></pre></td></tr></table></figure></p>
<p>上面的代码中，createStore函数接收另一个参数作为参数，返回新的Store对象。</p>
<p><strong>2. State</strong><br>Store对象包含所有数据。如果想得到某个时点的数据，就要对Store生成快照。这种时点数据集合，就叫做State。当前时刻的State，可以通过store.getState()拿到。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">const state = store.getState();</div></pre></td></tr></table></figure></p>
<p>Redux规定，一个State对应一个View。只要State相同，view就相同。知道state，就能够知道view是什么样的，反之亦然。<br><strong>3. Action</strong><br>State的变化，会导致view的变化。但是，用户接触不到state，只能接触到view。所以，state的变化必须是view导致的。Action就是View发出的通知，表示State应该要发生变化了。<br>Action是一个对象。其中type属性四必须的，表示Action的名称。其他属性可以自由设置。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">const action = &#123;</div><div class="line">    type:&apos;ADD_TODO&apos;,</div><div class="line">    payload:&apos;Learn Redux&apos;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>上面代码中，Action的名称是ADD_TODO，他携带的信息字符串是Learn Redux。<br>可以这样理解，Action描述当前发生的事情。改变State的唯一变化，就是使用Action。他会运送数据到Store。</p>
<p><strong>4. Action Creator</strong><br>View要发送多少种消息，就会有多少种Action。如果都手写，会很麻烦。可以定义一个函数来生成Action，这个函数就叫Action Creator<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">const ADD_TODO = &quot;添加 TODO&quot;;</div><div class="line">function addToDo(text)&#123;</div><div class="line">    return &#123;</div><div class="line">        type:ADD_TODO,</div><div class="line">        text</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">const actioon = addTodo(&apos;Learn Redux&apos;);</div></pre></td></tr></table></figure></p>
<p>上面代码中，addTodo函数就是一个Action Creator。</p>
<p><strong>5. store.dispatch()</strong><br>store.dispatch()是View发出Action的唯一方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">import &#123;createStore&#125;from &apos;redux&apos;;</div><div class="line">const store = createStore(fn);</div><div class="line">store.dispatch(&#123;</div><div class="line">    type:&apos;ADD_TODO&apos;,</div><div class="line">    payload:&apos;Learn Redux&apos;</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>上面的代码中，store.dispatch接收一个Action对象作为参数，将他发送出去。<br>结合Action Creator,这段代码可以改写如下。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">store.dispath(addTodo(&quot;Learn Redux&quot;));</div></pre></td></tr></table></figure></p>
<p><strong>6. Reducer</strong><br>Store收到Action以后，必须给出一个新的State，这样View才会发生变化。这种State的计算过程就叫做Reducer.<br>Reducer是一个函数，他接受Action和当前State作为参数，返回一个新的State。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">const reducer = function(state,action)&#123;</div><div class="line">    //...</div><div class="line">    return new_sate;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>整个应用的初始状态，可以作为State的默认值。下面是一个实际的例子。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">const defaultState = 0;</div><div class="line">const reducer = (state = defaultState,action)=&gt;&#123;</div><div class="line">    switch(action.type)&#123;</div><div class="line">        case &apos;ADD&apos;:</div><div class="line">            return state+action.payload;</div><div class="line">        default:</div><div class="line">            return state;</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">const state = reducer(1,&#123;type:&apos;ADD&apos;,payload:2&#125;);</div></pre></td></tr></table></figure></p>
<p>上面代码中，reducer函数收到名为ADD的Action以后，就返回一个新的State，作为加法的计算结果。其他运算的逻辑(比如减法),也可以根据Action的不同来实现。<br>实际应用中，Reducer函数不用像上面这样手动调用，store.dispath方法会触发Reducer的自动执行。为此，Store需要知道Reducer函数，做法就是再生成Store的时候，将Reducer传入createStore方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">import &#123; createStore &#125; from &apos;redux&apos;;</div><div class="line">const store = createStore(reducer);</div><div class="line">`</div></pre></td></tr></table></figure></p>
<p>上面代码中，createStore接受 Reducer 作为参数，生成一个新的 Store。以后每当store.dispatch发送过来一个新的 Action，就会自动调用 Reducer，得到新的 State。<br>为什么这个函数叫做 Reducer 呢？因为它可以作为数组的reduce方法的参数。请看下面的例子，一系列 Action 对象按照顺序作为一个数组。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">const actions = [</div><div class="line">  &#123; type: &apos;ADD&apos;, payload: 0 &#125;,</div><div class="line">  &#123; type: &apos;ADD&apos;, payload: 1 &#125;,</div><div class="line">  &#123; type: &apos;ADD&apos;, payload: 2 &#125;</div><div class="line">];</div><div class="line">const total = actions.reduce(reducer, 0); // 3</div></pre></td></tr></table></figure></p>
<p>上面代码中，数组actions表示依次有三个 Action，分别是加0、加1和加2。数组的reduce方法接受 Reducer 函数作为参数，就可以直接得到最终的状态3。<br><strong>7. 纯函数</strong><br>Reducer 函数最重要的特征是，它是一个纯函数。也就是说，只要是同样的输入，必定得到同样的输出。</p>
<ul>
<li>纯函数是函数式编程的概念，必须遵守以下一些约束。</li>
<li>不得改写参数</li>
<li>不能调用系统 I/O 的API</li>
<li>不能调用Date.now()或者Math.random()等不纯的方法，因为每次会得到不一样的结果<br>由于 Reducer 是纯函数，就可以保证同样的State，必定得到同样的 View。但也正因为这一点，Reducer 函数里面不能改变 State，必须返回一个全新的对象，请参考下面的写法。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">// State 是一个对象</div><div class="line">function reducer(state, action) &#123;</div><div class="line">  return Object.assign(&#123;&#125;, state, &#123; thingToChange &#125;);</div><div class="line">  // 或者</div><div class="line">  return &#123; ...state, ...newState &#125;;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// State 是一个数组</div><div class="line">function reducer(state, action) &#123;</div><div class="line">  return [...state, newItem];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>最好把 State 对象设成只读。你没法改变它，要得到新的 State，唯一办法就是生成一个新对象。这样的好处是，任何时候，与某个 View 对应的 State 总是一个不变的对象。<br><strong>8. store.subscribe()</strong><br>Store 允许使用store.subscribe方法设置监听函数，一旦 State 发生变化，就自动执行这个函数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">import &#123; createStore &#125; from &apos;redux&apos;;</div><div class="line">const store = createStore(reducer);</div><div class="line"></div><div class="line">store.subscribe(listener);</div></pre></td></tr></table></figure></p>
<p>显然，只要把 View 的更新函数（对于 React 项目，就是组件的render方法或setState方法）放入listen，就会实现 View 的自动渲染。<br>store.subscribe方法返回一个函数，调用这个函数就可以解除监听。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">let unsubscribe = store.subscribe(() =&gt;</div><div class="line">  console.log(store.getState())</div><div class="line">);</div><div class="line"></div><div class="line">unsubscribe();</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;React和Redux之间的关系&lt;/p&gt;
&lt;h4 id=&quot;Redux是什么？&quot;&gt;&lt;a href=&quot;#Redux是什么？&quot; class=&quot;headerlink&quot; title=&quot;Redux是什么？&quot;&gt;&lt;/a&gt;Redux是什么？&lt;/h4&gt;&lt;p&gt;Redux是Facebook提出的flux架构的一种优秀实现；而且不局限于为react提供数据处理状态。它是零依赖的，可以配合其他任何框架或类库一起使用。要想配合react，还得引入react-redux。&lt;br&gt;Redux简单的说就是一个事件分发器和全局state控制台。&lt;/p&gt;
&lt;h4 id=&quot;什么时候使用Redux&quot;&gt;&lt;a href=&quot;#什么时候使用Redux&quot; class=&quot;headerlink&quot; title=&quot;什么时候使用Redux&quot;&gt;&lt;/a&gt;什么时候使用Redux&lt;/h4&gt;&lt;p&gt;首先，Redux是一个有用的框架，但不是非用不可。事实上，大多数情况下，可以不用他，只用React就够了&lt;/p&gt;
    
    </summary>
    
      <category term="React" scheme="http://yoursite.com/categories/React/"/>
    
    
      <category term="React" scheme="http://yoursite.com/tags/React/"/>
    
      <category term="Redux" scheme="http://yoursite.com/tags/Redux/"/>
    
  </entry>
  
  <entry>
    <title>React-Flux</title>
    <link href="http://yoursite.com/2018/08/10/React-flux/"/>
    <id>http://yoursite.com/2018/08/10/React-flux/</id>
    <published>2018-08-10T06:05:57.000Z</published>
    <updated>2020-04-26T07:26:55.621Z</updated>
    
    <content type="html"><![CDATA[<p>React是一个视图层的框架<br>Flux是一种设计思想<br>配合数据架构flux可以开发大型项目<br>RedUx就是flux具体实现<br>单例模式的举例：Flux<br>只把公共的数据放在store中，<br>如果某一个数据只在一个组件中使用，如果这个数据放在store中当这个数据改变所有组件都会改变，非常消耗性能。<br>如果所有数据都放在store中，如果不同的组件触发不同的事件可以解决消耗性能这个问题。同时带来的自动化测试非常便捷的好处。</p>
<h4 id="Flux是什么"><a href="#Flux是什么" class="headerlink" title="Flux是什么"></a>Flux是什么</h4><p>Flux是Facebook用来构建客户端Web应用的应用架构。他利用单向数据流的方式来组合React中的视图组件。他更像一个模式而不是一个正式的框架，开发者不需要太多的新代码就可以上手。</p>
<h4 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h4><p><strong>Flux将一个应用分成四个部分</strong></p>
<ul>
<li>View: 视图层</li>
<li>Action(动作): 视图层发出的消息(比如mouseClick)</li>
<li>Dispatcher(派发器): 用来接收Action、执行回调函数</li>
<li>Store(数据层): 用来存放应用的状态，一旦发生变动，就提醒Views要更新页面</li>
</ul>
<p>流程图：<br><img src="/images/posts/6982694-3d24f46bf0dc754c.png" alt=""></p>
<p>Flux的最大特点，就是数据的”单向流动”。</p>
<ol>
<li>用户访问View</li>
<li>View发出用户的Action</li>
<li>Dispatcher收到Action，要求Store进行相应的更新</li>
<li>Store更新后，发出一个”change”事件</li>
<li>View收到”Change”事件后，更新页面</li>
</ol>
<p>上面的过程中，数据总是”单向流动”，任何相邻的部分都不会发生数据的”双向流动”。这保证了流程的清晰。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;React是一个视图层的框架&lt;br&gt;Flux是一种设计思想&lt;br&gt;配合数据架构flux可以开发大型项目&lt;br&gt;RedUx就是flux具体实现&lt;br&gt;单例模式的举例：Flux&lt;br&gt;只把公共的数据放在store中，&lt;br&gt;如果某一个数据只在一个组件中使用，如果这个数据放在st
    
    </summary>
    
      <category term="React" scheme="http://yoursite.com/categories/React/"/>
    
    
      <category term="React" scheme="http://yoursite.com/tags/React/"/>
    
      <category term="Flux" scheme="http://yoursite.com/tags/Flux/"/>
    
  </entry>
  
  <entry>
    <title>React生命周期</title>
    <link href="http://yoursite.com/2018/08/02/React%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
    <id>http://yoursite.com/2018/08/02/React生命周期/</id>
    <published>2018-08-02T01:43:57.000Z</published>
    <updated>2020-04-26T07:26:55.623Z</updated>
    
    <content type="html"><![CDATA[<h3 id="React生命周期"><a href="#React生命周期" class="headerlink" title="React生命周期"></a>React生命周期</h3><p><img src="http://upload-images.jianshu.io/upload_images/6982694-dafcf61dd511152e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>在组件的整个生命周期中，随着该组件的props或者state发生改变，其DOM表现也会有相应的变化。一个组件就是一个状态机，对于特定地输入，他总会返回一致的输出。</p>
<p><font color="red"><strong>一个React组件的生命周期分为三个部分：实例化、存在期和销毁时</strong></font></p>
<h4 id="实例化"><a href="#实例化" class="headerlink" title="实例化"></a>实例化</h4><p>当组件在客户端被实例化，第一次被创建时，一下方法依次被调用：<br>可以用constructor(props)来构造</p>
<ol>
<li>getDefaultProps</li>
<li>getIntialState</li>
<li>componentWillMount</li>
<li>render</li>
<li>componentDidMount</li>
</ol>
<a id="more"></a>
<p>实例化完成后的更新</p>
<ol>
<li>getIntialState</li>
<li>componentWillMount</li>
<li>render</li>
<li>componentDidMount<br>componentDidMount不会在服务端被渲染的过程中调用</li>
</ol>
<h4 id="存在期"><a href="#存在期" class="headerlink" title="存在期"></a>存在期</h4><p>组件已存在时的状态改变</p>
<ol>
<li>componentWillReceiveProps</li>
<li>shouldComponentUpdate</li>
<li>componentWillUpdate</li>
<li>render</li>
<li>componentDidUpdate</li>
</ol>
<h4 id="销毁时"><a href="#销毁时" class="headerlink" title="销毁时"></a>销毁时</h4><p>componentWillUnmount</p>
<h4 id="生命周期10个不同的API"><a href="#生命周期10个不同的API" class="headerlink" title="生命周期10个不同的API"></a>生命周期10个不同的API</h4><p><strong>1. getDefaultProps</strong><br>作用于组件类，只调用一次，返回对象用于设置默认的props，对于引用值，会在实例中共享<br><strong>2. getIntialState</strong><br>作用于组件的实例，在实例创建时调用一次，用于初始化每个实例的state，此时可以访问this.props.<br><strong>3. componentWillMount</strong><br>在完成首次渲染之前调用，此时仍可以修改组件的state<br><strong>4. render</strong><br>必选的方法，创建虚拟DOM，该方法具有特殊的规则：</p>
<ul>
<li>只能通过this.props和this.state访问数据</li>
<li>可以返回null、false或任何React组件</li>
<li>只可能出现一个顶级组件(不能返回数组)</li>
<li>不能改变组件的状态</li>
<li>不能修改DOM的输出</li>
</ul>
<p><strong>5. componentDidMount</strong><br>真实的DOM被渲染出来后调用，在该方法中可以通过this.getDOMNode()访问到真实的DOM元素。此时已可以使用其他类库来操作这个DOM。<br>在服务端中，该方法不会被调用。<br><strong>6. componentWillReceiveProps</strong><br>组件接收到新的props时调用，并将其作为参数nextProps使用，此时可以更改组件props及state。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">componentWillReceiveProps: function(nextProps) &#123;</div><div class="line">     if (nextProps.bool) &#123;</div><div class="line">         this.setState(&#123;</div><div class="line">             bool: true</div><div class="line">         &#125;);</div><div class="line">     &#125;</div><div class="line"> &#125;</div></pre></td></tr></table></figure></p>
<p><strong>7. shouldComponentUpdate</strong><br>组件是否应当渲染新的props或state，返回false表示跳过后续的生命周期方法，通常不需要使用以避免出现bug。再出现应用的瓶颈时，可通过该方法进行适当的优化。<br>在首次渲染期间或者调用了forceUpdate方法后，该方法不会被调用<br><strong>8. componentWillUpdate</strong><br>接收到新的props或者state后，进行渲染之前调用，此时不允许更新props或state。<br><strong>9. componentDidUpdate</strong><br>完成渲染新的props或者state后调用，此时可以访问到新的DOM元素<br><strong>10. componentWillUnmount</strong><br>组件被移除之前被调用，可以用于做一些清理工作，在componentDidMount方法中添加的所有任务都需要在该方法中撤销，比如创建的定时器或添加的事件监听器。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;React生命周期&quot;&gt;&lt;a href=&quot;#React生命周期&quot; class=&quot;headerlink&quot; title=&quot;React生命周期&quot;&gt;&lt;/a&gt;React生命周期&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/6982694-dafcf61dd511152e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;在组件的整个生命周期中，随着该组件的props或者state发生改变，其DOM表现也会有相应的变化。一个组件就是一个状态机，对于特定地输入，他总会返回一致的输出。&lt;/p&gt;
&lt;p&gt;&lt;font color=&quot;red&quot;&gt;&lt;strong&gt;一个React组件的生命周期分为三个部分：实例化、存在期和销毁时&lt;/strong&gt;&lt;/font&gt;&lt;/p&gt;
&lt;h4 id=&quot;实例化&quot;&gt;&lt;a href=&quot;#实例化&quot; class=&quot;headerlink&quot; title=&quot;实例化&quot;&gt;&lt;/a&gt;实例化&lt;/h4&gt;&lt;p&gt;当组件在客户端被实例化，第一次被创建时，一下方法依次被调用：&lt;br&gt;可以用constructor(props)来构造&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;getDefaultProps&lt;/li&gt;
&lt;li&gt;getIntialState&lt;/li&gt;
&lt;li&gt;componentWillMount&lt;/li&gt;
&lt;li&gt;render&lt;/li&gt;
&lt;li&gt;componentDidMount&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="React" scheme="http://yoursite.com/categories/React/"/>
    
    
      <category term="React" scheme="http://yoursite.com/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>TCP-三次握手与四次挥手</title>
    <link href="http://yoursite.com/2018/06/15/TCP-%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E4%B8%8E%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/"/>
    <id>http://yoursite.com/2018/06/15/TCP-三次握手与四次挥手/</id>
    <published>2018-06-15T07:31:20.000Z</published>
    <updated>2020-04-26T07:26:55.627Z</updated>
    
    <content type="html"><![CDATA[<h4 id="TCP三次握手"><a href="#TCP三次握手" class="headerlink" title="TCP三次握手"></a>TCP三次握手</h4><p>所谓三次握手(Three-Way Handshake)即建立TCP连接，就是指建立一个TCP连接时，需要客户端和服务端总共发送3个包已确认连接的建立。在socket编程中，这一过程由客户端执行connect来触发。整个流程如下图所示：</p>
<p><img src="/images/posts/2964446-aa923712d5218eeb.png" alt=""><br>（1）第一次握手：Client将标志位SYN置为1，随机产生一个值seq=J，并将该数据包发送给Server，Client进入SYN_SENT状态，等待Server确认。</p>
<p>（2）第二次握手：Server收到数据包后由标志位SYN=1知道Client请求建立连接，Server将标志位SYN和ACK都置为1，ack=J+1，随机产生一个值seq=K，并将该数据包发送给Client以确认连接请求，Server进入SYN_RCVD状态。</p>
<p>（3）第三次握手：Client收到确认后，检查ack是否为J+1，ACK是否为1，如果正确则将标志位ACK置为1，ack=K+1，并将该数据包发送给Server，Server检查ack是否为K+1，ACK是否为1，如果正确则连接建立成功，Client和Server进入ESTABLISHED状态，完成三次握手，随后Client与Server之间可以开始传输数据了。</p>
<a id="more"></a>
<ol>
<li>第一次握手：建立连接时，客户端发送SYN包(SYN=i)到服务器，并进入到SYN-SEND状态，等待服务器确认</li>
<li>服务器收到SYN包，必须确认客户的SYN(ack=i+1)，同时自己也发送一个SYN包(SYN=k),即SYN+ACK包，此时服务器进入SYN-RECV状态</li>
<li>客户端收到服务器的SYN+ACK包，向服务器发送确认报ACK(ack=k+1),此包发送完毕，客户端和服务端进入ESTABLISHED状态，完成三次握手，客户端与服务器开始传送数据。<br><strong>SYN攻击：</strong><br>在三次握手过程中，Server发送SYN-ACK之后，收到Client的ACK之前的TCP连接称为半连接（half-open connect），此时Server处于SYN_RCVD状态，当收到ACK后，Server转入ESTABLISHED状态。SYN攻击就是Client在短时间内伪造大量不存在的IP地址，并向Server不断地发送SYN包，Server回复确认包，并等待Client的确认，由于源地址是不存在的，因此，Server需要不断重发直至超时，这些伪造的SYN包将产时间占用未连接队列，导致正常的SYN请求因为队列满而被丢弃，从而引起网络堵塞甚至系统瘫痪。SYN攻击时一种典型的DDOS攻击，检测SYN攻击的方式非常简单，即当Server上有大量半连接状态且源IP地址是随机的，则可以断定遭到SYN攻击了，使用如下命令可以让之现行：<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">#netstat -nap | grep SYN_RECV</div></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="TCP四次挥手"><a href="#TCP四次挥手" class="headerlink" title="TCP四次挥手"></a>TCP四次挥手</h4><p>所谓四次挥手(Four-Way Wavehand)即终止TCP连接，就是指断开一个TCP连接时，需要客户端和服务端总共发四个包以确认连接的断开。在socket编程中，这一过程由客户端或服务器端任一方执行close来触发,整个流程如下图所示<br><img src="/images/posts/2964446-2b9562b3a8b72fb2.png" alt=""><br>由于TCP连接时全双工的，因此，每个方向都必须要单独进行关闭，这一原则是当一方完成数据发送任务后。发送一个FIN来终止这一方向的连接，收到一个FIN只是意味着这一方向上没有数据流动了，即不会在收到数据了，但是在这个TCP连接上仍然能够发送数据，知道这一方向也发送了FIN。首先进行关闭的一方将执行主动关闭，而另一方则执行被动关闭，上图描述的即是如此</p>
<ol>
<li>第一次挥手：Client发送一个FIN，用来关闭Client到Server的数据传送，Client进入FIN_WAIT_1状态。</li>
<li>第二次挥手：Server收到FIN后，发送一个ACK给Client，确认序号为收到序号+1(与SYN相同，一个FIN占用一个序号)，Server进入LAST_ACK状态。</li>
<li><p>第三次挥手：Server发送一个FIN，用来关闭Server到Silent的数据传送，Server进入LAST_ACK状态。</p>
</li>
<li><p>第四次挥手：Client收到FIN后，Client进入TIME_WAIT状态，接着发送一个ACK给Server，确认序号为收到序号+1，Server进入CLOSED状态，完成四次挥手。</p>
</li>
</ol>
<h4 id="为什么建立连接是三次握手，而关闭连接却是四次挥手呢？"><a href="#为什么建立连接是三次握手，而关闭连接却是四次挥手呢？" class="headerlink" title="为什么建立连接是三次握手，而关闭连接却是四次挥手呢？"></a>为什么建立连接是三次握手，而关闭连接却是四次挥手呢？</h4><p>这是因为服务端在LISTEN状态下，收到建立连接请求的SYN报文后，把ACK和SYN放在一个报文里发送给客户端。而关闭连接时，当收到对方的FIN报文时，仅仅表示对方不再发送数据了但是还能接收数据，己方也未必全部数据都发送给对方了，所以己方可以立即close，也可以发送一些数据给对方后，再发送FIN报文给对方来表示同意现在关闭连接，因此，己方ACK和FIN一般都会分开发送。</p>
<h4 id="为什么TIME-WAIT状态需要经过2MSL-最大报文段生存时间-才能返回到CLOSE状态？"><a href="#为什么TIME-WAIT状态需要经过2MSL-最大报文段生存时间-才能返回到CLOSE状态？" class="headerlink" title="为什么TIME_WAIT状态需要经过2MSL(最大报文段生存时间)才能返回到CLOSE状态？"></a>为什么TIME_WAIT状态需要经过2MSL(最大报文段生存时间)才能返回到CLOSE状态？</h4><p>原因有二：<br>一、保证TCP协议的全双工连接能够可靠关闭<br>二、保证这次连接的重复数据段从网络中消失</p>
<p>先说第一点，如果Client直接CLOSED了，那么由于IP协议的不可靠性或者是其它网络原因，导致Server没有收到Client最后回复的ACK。那么Server就会在超时之后继续发送FIN，此时由于Client已经CLOSED了，就找不到与重发的FIN对应的连接，最后Server就会收到RST而不是ACK，Server就会以为是连接错误把问题报告给高层。这样的情况虽然不会造成数据丢失，但是却导致TCP协议不符合可靠连接的要求。所以，Client不是直接进入CLOSED，而是要保持TIME_WAIT，当再次收到FIN的时候，能够保证对方收到ACK，最后正确的关闭连接。</p>
<p>再说第二点，如果Client直接CLOSED，然后又再向Server发起一个新连接，我们不能保证这个新连接与刚关闭的连接的端口号是不同的。也就是说有可能新连接和老连接的端口号是相同的。一般来说不会发生什么问题，但是还是有特殊情况出现：假设新连接和已经关闭的老连接端口号是一样的，如果前一次连接的某些数据仍然滞留在网络中，这些延迟数据在建立新连接之后才到达Server，由于新连接和老连接的端口号是一样的，又因为TCP协议判断不同连接的依据是socket pair，于是，TCP协议就认为那个延迟的数据是属于新连接的，这样就和真正的新连接的数据包发生混淆了。所以TCP连接还要在TIME_WAIT状态等待2倍MSL，这样可以保证本次连接的所有数据都从网络中消失。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;TCP三次握手&quot;&gt;&lt;a href=&quot;#TCP三次握手&quot; class=&quot;headerlink&quot; title=&quot;TCP三次握手&quot;&gt;&lt;/a&gt;TCP三次握手&lt;/h4&gt;&lt;p&gt;所谓三次握手(Three-Way Handshake)即建立TCP连接，就是指建立一个TCP连接时，需要客户端和服务端总共发送3个包已确认连接的建立。在socket编程中，这一过程由客户端执行connect来触发。整个流程如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/posts/2964446-aa923712d5218eeb.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;（1）第一次握手：Client将标志位SYN置为1，随机产生一个值seq=J，并将该数据包发送给Server，Client进入SYN_SENT状态，等待Server确认。&lt;/p&gt;
&lt;p&gt;（2）第二次握手：Server收到数据包后由标志位SYN=1知道Client请求建立连接，Server将标志位SYN和ACK都置为1，ack=J+1，随机产生一个值seq=K，并将该数据包发送给Client以确认连接请求，Server进入SYN_RCVD状态。&lt;/p&gt;
&lt;p&gt;（3）第三次握手：Client收到确认后，检查ack是否为J+1，ACK是否为1，如果正确则将标志位ACK置为1，ack=K+1，并将该数据包发送给Server，Server检查ack是否为K+1，ACK是否为1，如果正确则连接建立成功，Client和Server进入ESTABLISHED状态，完成三次握手，随后Client与Server之间可以开始传输数据了。&lt;/p&gt;
    
    </summary>
    
      <category term="网络" scheme="http://yoursite.com/categories/%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="TCP" scheme="http://yoursite.com/tags/TCP/"/>
    
  </entry>
  
  <entry>
    <title>javascript-原型链继承</title>
    <link href="http://yoursite.com/2017/09/02/javascript-%E5%8E%9F%E5%9E%8B%E9%93%BE%E7%BB%A7%E6%89%BF/"/>
    <id>http://yoursite.com/2017/09/02/javascript-原型链继承/</id>
    <published>2017-09-02T11:46:19.000Z</published>
    <updated>2020-04-26T07:26:55.641Z</updated>
    
    <content type="html"><![CDATA[<h4 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h4><p>利用原型让每一个引用类型继承另一个引用类型的属性和方法。</p>
<h4 id="构造函数、原型和实例的关系"><a href="#构造函数、原型和实例的关系" class="headerlink" title="构造函数、原型和实例的关系"></a>构造函数、原型和实例的关系</h4><p>每一个构造函数都有一个原型对象，原型对象都包含一个指向构造函数的指针，而实例都包含一个指向原型对象的内部指针，那么。假如让原型对象等于另一个类型的实例，结果会怎么样呢？显然，此时的原型对象将包含一个指向另一个原型的指针，相应地，另一个原型中也包含着一个指向另一个构造函数的指针。假如另一个原型又是另一个类型的实例，那么上述关系依然成立，如此层层递进，就构成了实例与原型的链条。这就是所谓原型链的基本概念<br><a id="more"></a></p>
<p>实现原型链有一种基本模式，其代码大致如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">function SuperType() &#123;</div><div class="line">    this.property = true;</div><div class="line">&#125;</div><div class="line">SuperType.prototype.getSuperValue = function() &#123;</div><div class="line">    return this.property;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">function SubType() &#123;</div><div class="line">    this.subproperty = false;</div><div class="line">&#125;</div><div class="line">//继承了SuperType</div><div class="line">SubType.prototype = new SuperType();</div><div class="line">SubType.prototype.getSubValue = function() &#123;</div><div class="line">    return this.subproperty;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">var instance = new SubType();</div><div class="line">alert(instance.getSuperValue()); //true</div></pre></td></tr></table></figure></p>
<p>以上代码中定义了两个类型：SuperType和SubType。实现继承的本质是重写原型对象，代之一个新类型的实例。换句话说，原来存在于SuperType的实例中的所有属性和方法，现在也存在于subType.prototype中了。而在继承了SuperType的属性和方法后，SubType用定义了新的方法。<br>在上面的代码中，并没有使用SubType默认提供的原型，而是给它换了一个新的原型；这个新原型就是SupperType的实例。于是，新原型不仅具有作为一个SupperType的实例所拥有的全部属性和方法，而且其内部还有一个指针，指向了SupperType的原型。<br>最终结果是这样的<br>instance指向SubType的原型。SubType的原型有指向了SupperType的原型。getSuperValue()方法仍然还在SuperType.prototype中，但property则位于SubType.prototype中。这是因为property是一个实例属性，而getSuperValue()则是一个原型方法。</p>
<p><font color="red">注意：instance.constructor现在指向的是SuperType,这是因为原来SubType.prototype被重写了的缘故</font><br>实际上，不是SuperType的原型的constructor属性被重写了，而是SubType的原型指向了另一个对象————SuperType的原型，而这个原型对象的constructor属性指向的是SuperType<br><strong>原型链搜索机制</strong><br>当以读取模式访问一个实例属性时，首先会在实例中搜索该属性。如果没有找到该属性，则会继续搜索实例的原型。在通过原型链实现继承的情况下，搜索过程就得沿着原型链继续向上<br>上面的例子在调用instance.getSuperValue()会经历三个搜索步骤：</p>
<ol>
<li>搜索实例</li>
<li>搜索SubType.prototype;</li>
<li>搜索SuperType.prototype,最后一步才会找到该方法。再找不到属性或方法的情况下，搜索过程总是要一环一环地前行到原型链末端才会停下来</li>
</ol>
<h5 id="别忘记默认的原型"><a href="#别忘记默认的原型" class="headerlink" title="别忘记默认的原型"></a>别忘记默认的原型</h5><p>事实上，前面例子中展示的原型链还少一环。我们都知道，所有的引用类型默认都继承了object，而这个继承也是通过原型链实现的。所有的函数默认的原型都是Object的实例。因此默认原型都会包含一个内部指针，指向object.prototype。这也正是所有自定义类型都会继承toString()、valueOf()等默认方法的根本原因。<br>一句话，SubType继承了SuperType,而SuperType继承了object。当调用instance.toString()时，实际上调用的是保存在Object.prototype中的那个方法</p>
<h5 id="确定原型与实例的关系"><a href="#确定原型与实例的关系" class="headerlink" title="确定原型与实例的关系"></a>确定原型与实例的关系</h5><p>可以通过两种方式来确定原型和实例间的关系。</p>
<ol>
<li>使用instanceof操作符。<br>只要用这个操作符来测试实例与原型链中出现过得构造函数，结果就会返回true</li>
<li>使用isPrototypeOf()方法。<br>同样，只要是原型链中出现过的原型都可以说是该原型链所派生的实例的原型，</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;基本思想&quot;&gt;&lt;a href=&quot;#基本思想&quot; class=&quot;headerlink&quot; title=&quot;基本思想&quot;&gt;&lt;/a&gt;基本思想&lt;/h4&gt;&lt;p&gt;利用原型让每一个引用类型继承另一个引用类型的属性和方法。&lt;/p&gt;
&lt;h4 id=&quot;构造函数、原型和实例的关系&quot;&gt;&lt;a href=&quot;#构造函数、原型和实例的关系&quot; class=&quot;headerlink&quot; title=&quot;构造函数、原型和实例的关系&quot;&gt;&lt;/a&gt;构造函数、原型和实例的关系&lt;/h4&gt;&lt;p&gt;每一个构造函数都有一个原型对象，原型对象都包含一个指向构造函数的指针，而实例都包含一个指向原型对象的内部指针，那么。假如让原型对象等于另一个类型的实例，结果会怎么样呢？显然，此时的原型对象将包含一个指向另一个原型的指针，相应地，另一个原型中也包含着一个指向另一个构造函数的指针。假如另一个原型又是另一个类型的实例，那么上述关系依然成立，如此层层递进，就构成了实例与原型的链条。这就是所谓原型链的基本概念&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="前端笔记" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>target和currentTarget学习笔记</title>
    <link href="http://yoursite.com/2017/08/31/target%E5%92%8CcurrentTarget%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2017/08/31/target和currentTarget学习笔记/</id>
    <published>2017-08-31T01:21:51.000Z</published>
    <updated>2020-04-26T07:26:55.645Z</updated>
    
    <content type="html"><![CDATA[<p>target和currentTarget都是event上面的属性</p>
<h4 id="currentTarget"><a href="#currentTarget" class="headerlink" title="currentTarget"></a>currentTarget</h4><p>事件类型：Element<br>表示其事件处理程序当前正在处理事件的那个元素</p>
<h4 id="target"><a href="#target" class="headerlink" title="target"></a>target</h4><p>事件类型：Element<br>表示事件的目标</p>
<h2 id=""><a href="#" class="headerlink" title=""></a><a id="more"></a></h2><p>在事件处理程序内部，对象this始终等于currentTarget的值，而target则只包含事件的实际目标。如果直接将事件处理程序指定给了目标元素,则this、currentTarget和target包含相同的值。</p>
<p>例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">var btn = document.getElementById(&quot;myBtn&quot;);</div><div class="line">btn.onclick = function(event)&#123;</div><div class="line">    console.log(event.currentTarget === this);  //true</div><div class="line">    console.log(event.target === this);         //true</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>上面的例子检测了currentTarget和target与this的值。由于click事件的目标是按钮，因此这三个值是相等的。如果事件处理程序存在于按钮的父节点中(例如document.body),那么这些值是不相同的。比如下面的例子<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">document.body.onclick = function(event)&#123;</div><div class="line">    console.log(event.currentTarget === document.body); //true</div><div class="line">    console.log(this === document.body);</div><div class="line">    console.log(event.target === document.getElementById(&quot;myBtn&quot;)); //true</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>当点击这个例子中的按钮时，this和currentTarget都等于document.body,因为事件处理程序是注册到这个元素上的。然而,target元素却等于按钮元素，因为它是click事件的真正目标。由于按钮上没有注册事件处理程序，结果click事件就冒泡到了document.body,在那里事件才得到了处理</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;target和currentTarget都是event上面的属性&lt;/p&gt;
&lt;h4 id=&quot;currentTarget&quot;&gt;&lt;a href=&quot;#currentTarget&quot; class=&quot;headerlink&quot; title=&quot;currentTarget&quot;&gt;&lt;/a&gt;currentTarget&lt;/h4&gt;&lt;p&gt;事件类型：Element&lt;br&gt;表示其事件处理程序当前正在处理事件的那个元素&lt;/p&gt;
&lt;h4 id=&quot;target&quot;&gt;&lt;a href=&quot;#target&quot; class=&quot;headerlink&quot; title=&quot;target&quot;&gt;&lt;/a&gt;target&lt;/h4&gt;&lt;p&gt;事件类型：Element&lt;br&gt;表示事件的目标&lt;/p&gt;
&lt;h2 id=&quot;&quot;&gt;&lt;a href=&quot;#&quot; class=&quot;headerlink&quot; title=&quot;&quot;&gt;&lt;/a&gt;&lt;/h2&gt;
    
    </summary>
    
      <category term="前端笔记" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>从浏览器的URL中获取参数信息笔记</title>
    <link href="http://yoursite.com/2017/08/23/%E4%BB%8E%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84URL%E4%B8%AD%E8%8E%B7%E5%8F%96%E5%8F%82%E6%95%B0%E4%BF%A1%E6%81%AF%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2017/08/23/从浏览器的URL中获取参数信息笔记/</id>
    <published>2017-08-23T00:37:33.000Z</published>
    <updated>2020-04-26T07:26:55.647Z</updated>
    
    <content type="html"><![CDATA[<p>浏览器的宿主环境中，有一个location对象，同时这个window对象和document对象的属性<br>location对象提供了与当前窗口加载的文档有关的信息，即URL信息<br>例如</p>
<blockquote>
<p>浏览器地址栏的信息显示的是<br><a href="https://www.zhihu.com/search?type=content&amp;q=123#3" target="_blank" rel="external">https://www.zhihu.com/search?type=content&amp;q=123#3</a><br>location.href : 完整的url<br>location.protocol : 返回协议(https:)<br>location.host : 返回服务器名称和端口号(Www.zhihu.com)<br>location.hostname : 返回服务器名称(www.zhihu.com)<br>location.port : 返回服务器端口号(http默认80，https默认443)<br>location.pathname : 返回URL中的目录和文件名(/search)<br>location.search : 返回查询字符串(?type=content&amp;q=123)<br>locatin.hash : 返回值#3</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;浏览器的宿主环境中，有一个location对象，同时这个window对象和document对象的属性&lt;br&gt;location对象提供了与当前窗口加载的文档有关的信息，即URL信息&lt;br&gt;例如&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;浏览器地址栏的信息显示的是&lt;br&gt;&lt;a h
    
    </summary>
    
      <category term="前端笔记" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>关于Object.defineProperty方法的利用</title>
    <link href="http://yoursite.com/2017/08/21/%E5%85%B3%E4%BA%8EObject.defineProperty%E6%96%B9%E6%B3%95%E7%9A%84%E5%88%A9%E7%94%A8/"/>
    <id>http://yoursite.com/2017/08/21/关于Object.defineProperty方法的利用/</id>
    <published>2017-08-21T03:30:39.000Z</published>
    <updated>2020-04-26T07:26:55.648Z</updated>
    
    <content type="html"><![CDATA[<h4 id="Object-defineProperty"><a href="#Object-defineProperty" class="headerlink" title="Object.defineProperty()"></a>Object.defineProperty()</h4><p>语法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Object.defineProperty(obj,prop,descriptor)</div></pre></td></tr></table></figure></p>
<p>参数:</p>
<ul>
<li>obj:目标对象</li>
<li>prop:需要定义的属性或方法的名字</li>
<li>descriptor: 目标属性所拥有的特性<a id="more"></a>
descriptor参数说明<br>该参数有以下取值</li>
<li>value: 属性的值</li>
<li>writable: 是否可写，如果为false，属性的值就不能被重写，只能为只读</li>
<li>configurable: 总开关，一旦设置为false，就不能在设置它的(value , writable,configurable)</li>
<li>enumerable: 是否能在for…in循环遍历出来或在Object.keys中列举出来</li>
<li>get: 获取属性值的方法</li>
<li>set: 设置属性值的方法</li>
</ul>
<p><strong><font color="red">注意：</font><br>当使用get和set方法，不允许使用writable和value这两个属性<br>get和set不是必须成对出现，任意其一就可以。如果不设置方法，则get和set的默认值为undefined。configurable和enumerable一样</strong></p>
<h4 id="兼容性"><a href="#兼容性" class="headerlink" title="兼容性"></a>兼容性</h4><p>在ie8下只能在DOM对象上使用，尝试在原生的对象使用Object.defineProperty()会报错</p>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;Object-defineProperty&quot;&gt;&lt;a href=&quot;#Object-defineProperty&quot; class=&quot;headerlink&quot; title=&quot;Object.defineProperty()&quot;&gt;&lt;/a&gt;Object.defineProperty()&lt;/h4&gt;&lt;p&gt;语法：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;Object.defineProperty(obj,prop,descriptor)&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;参数:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;obj:目标对象&lt;/li&gt;
&lt;li&gt;prop:需要定义的属性或方法的名字&lt;/li&gt;
&lt;li&gt;descriptor: 目标属性所拥有的特性&lt;/li&gt;&lt;/ul&gt;
    
    </summary>
    
      <category term="前端笔记" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>vue简介</title>
    <link href="http://yoursite.com/2017/08/21/vue%E7%AE%80%E4%BB%8B/"/>
    <id>http://yoursite.com/2017/08/21/vue简介/</id>
    <published>2017-08-21T02:30:39.000Z</published>
    <updated>2020-04-26T07:26:55.646Z</updated>
    
    <content type="html"><![CDATA[<p>vue 是不支持IE8及以下版本</p>
<p>defineProperty<br>getter<br>setter</p>
<h4 id="Vue是什么"><a href="#Vue是什么" class="headerlink" title="Vue是什么"></a>Vue是什么</h4><p>Vue采用自底向上增量开发的设计。Vue的核心库只关注视图层</p>
<a id="more"></a>
<p>React和Vue的相似之处</p>
<ul>
<li>React里面有react-route</li>
<li>Vue里面有Vue-route</li>
<li>React里面有react-redux</li>
<li>Vue里面有vuex</li>
</ul>
<ol>
<li><p>开发时构建<br>可以支持所有的语法</p>
</li>
<li><p>运行时构建<br>对template支持有问题，因为源码中不包含</p>
</li>
</ol>
<p>扩展<br>awesome-react<br>包括react比较靠谱的各种插件<br>awesome-vue<br>推荐Vue比较靠谱的各种插件</p>
<p>开发步骤</p>
<ol>
<li>新建项目</li>
<li>创建HTML文件</li>
<li>引入vue.js     vue使用建议把script放在body上面</li>
<li>创建Vue组件<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">new Vue(&#123;</div><div class="line">    el:&quot;#root&quot;,</div><div class="line">    //模板将message里面的数据挂载在页面，react里面需要&#123;&#125;,vue里面需要&#123;&#123;&#125;&#125;</div><div class="line">    template:&quot;&lt;div&gt;&#123;&#123;message&#125;&#125;&lt;/div&gt;&quot;,</div><div class="line">    //data和React里面的state一样都是存储数据</div><div class="line">    data:&#123;</div><div class="line">        message:&quot;hello vue!&quot;</div><div class="line">    &#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
</li>
</ol>
<p>vue里面数据放在data里，方法放在methods里</p>
<h4 id="vue指令"><a href="#vue指令" class="headerlink" title="vue指令"></a>vue指令</h4><p>指令(Directives是带有v-前缀的特殊属性)。指令的预期值是单个JavaScript表达式。指令的职责是，当表达式的值改变时，将其产生的连带影响，响应式地作用于DOM</p>
<ul>
<li>v-bind 可以简写成(:)<br>通过这个指令可以把vue实例里的数据绑定在dom元素的属性上，例如title 、 src v-bind:title=”message”</li>
<li>v-if<br>控制这个DOM元素存不存在</li>
<li>v-show<br>通过show这个变量判断当前DOM元素是显示还是隐藏,通过display控制</li>
<li>v-for<br>循环</li>
<li>v-on 简写(@)<br>在元素上绑定事件，例如 v-on:click=”handleClick”</li>
<li>v-model<br>数据的双向绑定<br>例如：<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;input type=&quot;text&quot; v-model=&quot;message&quot;/&gt;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>input的变化会使数据变化，数据的变化也会让input的数据变化，v-model实际上是一个语法糖，没有它我们一样可以实现数据双向绑定</p>
<ul>
<li>v-html<br>不转义文本</li>
</ul>
<h4 id="todolist"><a href="#todolist" class="headerlink" title="todolist"></a>todolist</h4><p>vue里面非父子组件传值使用vuex<br>父组件通过属性的方式向子组件传值，子组件向父组件传值，子组件需要触发一个事件，父组件监听这个事件</p>
<h4 id="创建一个组件"><a href="#创建一个组件" class="headerlink" title="创建一个组件"></a>创建一个组件</h4><p>创建一个<font color="red">全局</font>的组件，名字叫做todo-item<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Vue.component(&quot;todo-item&quot;,&#123;</div><div class="line">    template:&quot;&lt;li&gt;hello&lt;/li&gt;&quot;</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<p>vue.extend</p>
<h5 id="computed"><a href="#computed" class="headerlink" title="computed"></a>computed</h5><p>代表后面函数计算出来的结果<br>computed里面的键名对应的值指的是后面的方法返回的结果<br>computed不是计算一次就完事了，他依赖的变量一旦变化，就会重新计算<br>computed是除非依赖的变量发生变化，才重新计算，否则使用上一次计算的缓存值</p>
<h4 id="methods"><a href="#methods" class="headerlink" title="methods"></a>methods</h4><p>methods里面的键名对应的值指的是后面的方法<br>methods每一次渲染的时候都会重新计算一遍</p>
<h4 id="watch"><a href="#watch" class="headerlink" title="watch"></a>watch</h4><p>watch监控变量变化的时候，监控函数里面会接收到当前变量的最新值</p>
<h4 id="computed-methods-watch-比较"><a href="#computed-methods-watch-比较" class="headerlink" title="computed methods watch 比较"></a>computed methods watch 比较</h4><p>性能：methods性能最低</p>
<p>data和computed的属性名不能重复</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;vue 是不支持IE8及以下版本&lt;/p&gt;
&lt;p&gt;defineProperty&lt;br&gt;getter&lt;br&gt;setter&lt;/p&gt;
&lt;h4 id=&quot;Vue是什么&quot;&gt;&lt;a href=&quot;#Vue是什么&quot; class=&quot;headerlink&quot; title=&quot;Vue是什么&quot;&gt;&lt;/a&gt;Vue是什么&lt;/h4&gt;&lt;p&gt;Vue采用自底向上增量开发的设计。Vue的核心库只关注视图层&lt;/p&gt;
    
    </summary>
    
      <category term="Vue" scheme="http://yoursite.com/categories/Vue/"/>
    
    
      <category term="Vue" scheme="http://yoursite.com/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>Ajax学习笔记</title>
    <link href="http://yoursite.com/2017/08/15/Ajax%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2017/08/15/Ajax学习笔记/</id>
    <published>2017-08-15T01:25:04.000Z</published>
    <updated>2020-04-26T07:26:55.610Z</updated>
    
    <content type="html"><![CDATA[<p>AJAX是Asynchronous JavaScript And XMl(异步的JavaScript与XML技术)的缩写，让数据在后台进行异步传输。常见的使用场景：对网页的局部数据进行更新时，不需要刷新整个网页，以节省宽带资源。ajax也是黑客进行web客户端攻击常用的技术，因为这样就可以悄无声息地在浏览器后台进行，做到”杀人无形”</p>
<h4 id="什么是ajax："><a href="#什么是ajax：" class="headerlink" title="什么是ajax："></a>什么是ajax：</h4><p>异步的JavaScript and XML 通过ajax向服务器提交少量数据，完成页面的局部刷新(整个页面无刷新效果);<br><strong>优点</strong></p>
<ol>
<li>页面无刷新</li>
<li>响应速度快</li>
<li>用户体验好</li>
<li>节省带宽</li>
</ol>
<p><strong>缺点</strong></p>
<ol>
<li>ajax不支持浏览器back按钮</li>
<li>安全问题AJAX暴露了与服务器交互的细节</li>
<li>对搜索引擎的支持比较弱</li>
<li>破坏了程序的异常机制</li>
<li>不容易调试</li>
</ol>
<h4 id="ajax工作原理"><a href="#ajax工作原理" class="headerlink" title="ajax工作原理"></a>ajax工作原理</h4><p><img src="/images/posts/6982694-7107848c8277a2b6.png" alt=""></p>
<a id="more"></a>
<p>异步：同时执行（生活中的同步）<br>同步：按照一定的顺序来执行（顺序执行）</p>
<h4 id="线程和进程"><a href="#线程和进程" class="headerlink" title="线程和进程"></a>线程和进程</h4><p>程序从开始到结束的过程 称为一个进程。进程中包括多个线程，多线程是异步执行</p>
<h4 id="ajax的请求方式"><a href="#ajax的请求方式" class="headerlink" title="ajax的请求方式"></a>ajax的请求方式</h4><p>一般用get方式<br><strong>1. get</strong></p>
<ul>
<li>get从服务器获取</li>
<li>一般是通过地址url传值</li>
<li>传递量小</li>
<li>安全性低</li>
</ul>
<p><strong>post</strong></p>
<ul>
<li>向服务器提交数据</li>
<li>传递数据量大没有限制</li>
<li>安全性高</li>
</ul>
<h4 id="ajax的请求过程"><a href="#ajax的请求过程" class="headerlink" title="ajax的请求过程"></a>ajax的请求过程</h4><p>ajax请求过程</p>
<p><font color="red">1. 创建ajax对象</font><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">var ajax = new XMLHttpRequest();  //高版本浏览器</div><div class="line">var ajax = new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;);//IE9以下</div><div class="line">//XMLHTTPRequest()有兼容</div><div class="line">兼容性写法</div><div class="line">if(window.XMLHttpRequest)&#123;</div><div class="line">    ajax = new XMLHttpRequest();</div><div class="line">&#125;else&#123;</div><div class="line">    ajax = new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><font color="red">2. 建立和服务器的连接 通过open()方法实现</font><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ajax.open(&quot;请求方式&quot;,&quot;请求的路径&quot;,ture)第三个参数ture表示异步</div></pre></td></tr></table></figure></p>
<p><font color="red">3. 向服务器发送请求 通过send()方法</font><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ajax.send()</div></pre></td></tr></table></figure></p>
<p><font color="red">4. 服务器响应客户端的请求并将处理的结果返回到客户端</font><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">通过onreadystatechange事件来完成</div><div class="line">响应的过程是异步的</div><div class="line">ajax.onreadystatechange=function()&#123;</div><div class="line">    //判断状态值为4并且状态码为200表示本次请求成功了</div><div class="line">    if(ajax.readyState==4&amp;&amp;ajax.status==200)&#123;</div><div class="line">        console.log(ajax.responseText);//获取服务器响应数据</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="ajax在IE中出现的问题"><a href="#ajax在IE中出现的问题" class="headerlink" title="ajax在IE中出现的问题"></a>ajax在IE中出现的问题</h4><p>ie容易出现缓存问题：<br>解决方法：路径上加一个参数 参数值保证随机<br>路径改变</p>
<ol>
<li>“1.txt?id=”Math.random();</li>
<li>“1.txt?id=”new Date().getTime();<br>数据没有及时的更新<br>eval()和JSON.parse()<br>eval()转对象转json格式的字符串报错，json格式的字符串用JSON.parse</li>
</ol>
<h4 id="ajx封装"><a href="#ajx封装" class="headerlink" title="ajx封装"></a>ajx封装</h4><p>get<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">function getAjax(url,callback,data)&#123;</div><div class="line">    var ajax;</div><div class="line">    //创建ajax对象，处理兼容</div><div class="line">    if(windown.XMLHttpRequest)&#123;</div><div class="line">        ajax = new XMLHTTPRequest();//高版本浏览器</div><div class="line">    &#125;else&#123;</div><div class="line">        ajax = new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;);//ie9以下</div><div class="line">    &#125;</div><div class="line">    if(data)&#123;</div><div class="line">        //如果data参数存在，传入的url后面加上data，字符串连接</div><div class="line">        url=url+&quot;?&quot;+data;</div><div class="line">    &#125;</div><div class="line">    //建立与服务器建立连接</div><div class="line">    ajax.open(&quot;GET&quot;,url,ture);</div><div class="line">    //向服务器发送请求</div><div class="line">    ajax.send();</div><div class="line">    //处理服务器响应客户端的请求，并将处理的结果返回客户端</div><div class="line">    ajax.onreadystatechange=function()&#123;</div><div class="line">        if(ajax.readyState==4&amp;&amp;ajax.status==200)&#123;</div><div class="line">            //通过回调函数的方式接受服务器处理的结果</div><div class="line">            callback(ajax.responseText);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>post方式<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">function postAjax(url,data,callback)&#123;</div><div class="line">    var ajax;</div><div class="line">    //创建ajax对象，处理兼容</div><div class="line">    if(window.XMLHttpRequest)&#123;</div><div class="line">        ajax = new XMLHttpRequest();//高版本浏览器</div><div class="line">    &#125;else&#123;</div><div class="line">        ajax = new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;);//ie9以下</div><div class="line">    &#125;</div><div class="line">    //建立与服务器建立连接</div><div class="line">    ajax.open(&quot;POST&quot;, url);</div><div class="line">    //设置请求头</div><div class="line">    ajax.setRequestHeader(&quot;Content-Type&quot;,&quot;application/x-www-form-urlencoded&quot;);</div><div class="line">    ajax.send(data);</div><div class="line">    //处理服务器响应客户端的请求，并将处理的结果返回客户端</div><div class="line">    ajax.onreadystatechange = function() &#123;</div><div class="line">        if(ajax.readyState == 4 &amp;&amp; ajax.status == 200) &#123;</div><div class="line">            //通过回调函数的方式接收服务器处理的结果</div><div class="line">            callback(ajax.responseText);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong>ajax get方式和post方式区别：</strong></p>
<blockquote>
<p>post需要在send方法之前设置文件头<br>post send方法里面需要传入请求的数据</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;AJAX是Asynchronous JavaScript And XMl(异步的JavaScript与XML技术)的缩写，让数据在后台进行异步传输。常见的使用场景：对网页的局部数据进行更新时，不需要刷新整个网页，以节省宽带资源。ajax也是黑客进行web客户端攻击常用的技术，因为这样就可以悄无声息地在浏览器后台进行，做到”杀人无形”&lt;/p&gt;
&lt;h4 id=&quot;什么是ajax：&quot;&gt;&lt;a href=&quot;#什么是ajax：&quot; class=&quot;headerlink&quot; title=&quot;什么是ajax：&quot;&gt;&lt;/a&gt;什么是ajax：&lt;/h4&gt;&lt;p&gt;异步的JavaScript and XML 通过ajax向服务器提交少量数据，完成页面的局部刷新(整个页面无刷新效果);&lt;br&gt;&lt;strong&gt;优点&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;页面无刷新&lt;/li&gt;
&lt;li&gt;响应速度快&lt;/li&gt;
&lt;li&gt;用户体验好&lt;/li&gt;
&lt;li&gt;节省带宽&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;缺点&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;ajax不支持浏览器back按钮&lt;/li&gt;
&lt;li&gt;安全问题AJAX暴露了与服务器交互的细节&lt;/li&gt;
&lt;li&gt;对搜索引擎的支持比较弱&lt;/li&gt;
&lt;li&gt;破坏了程序的异常机制&lt;/li&gt;
&lt;li&gt;不容易调试&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&quot;ajax工作原理&quot;&gt;&lt;a href=&quot;#ajax工作原理&quot; class=&quot;headerlink&quot; title=&quot;ajax工作原理&quot;&gt;&lt;/a&gt;ajax工作原理&lt;/h4&gt;&lt;p&gt;&lt;img src=&quot;/images/posts/6982694-7107848c8277a2b6.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="前端笔记" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Ajax" scheme="http://yoursite.com/tags/Ajax/"/>
    
  </entry>
  
  <entry>
    <title>HTTP-状态码</title>
    <link href="http://yoursite.com/2017/08/10/HTTP-%E7%8A%B6%E6%80%81%E7%A0%81/"/>
    <id>http://yoursite.com/2017/08/10/HTTP-状态码/</id>
    <published>2017-08-10T00:09:25.000Z</published>
    <updated>2020-04-26T07:26:55.613Z</updated>
    
    <content type="html"><![CDATA[<p>HTTP状态码被分成五大类</p>
<h4 id="1-100-199——信息性状态码"><a href="#1-100-199——信息性状态码" class="headerlink" title="1. 100~199——信息性状态码"></a>1. 100~199——信息性状态码</h4><p>表示临时响应并需要请求者继续执行操作的状态码</p>
<table>
<thead>
<tr>
<th style="text-align:left">状态码</th>
<th style="text-align:left">原因短语</th>
<th style="text-align:left">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">100</td>
<td style="text-align:left">Continue (继续)</td>
<td style="text-align:left">请求者应当继续提出请求。 服务器返回此代码表示已收到请求的第一部分，正在等待其余部分。</td>
</tr>
<tr>
<td style="text-align:left">101</td>
<td style="text-align:left">Switching Protocols (切换协议)</td>
<td style="text-align:left">请求者已要求服务器切换协议，服务器已确认并准备切换。</td>
</tr>
</tbody>
</table>
<a id="more"></a>
<h4 id="2-200-299——成功状态码"><a href="#2-200-299——成功状态码" class="headerlink" title="2. 200~299——成功状态码"></a>2. 200~299——成功状态码</h4><p>表示成功处理了请求的状态码</p>
<table>
<thead>
<tr>
<th style="text-align:left">状态码</th>
<th style="text-align:left">原因短语</th>
<th style="text-align:left">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">200</td>
<td style="text-align:left">OK(成功)</td>
<td style="text-align:left">请求没问题，实体的主体部分包含了所请求的资源</td>
</tr>
<tr>
<td style="text-align:left">201</td>
<td style="text-align:left">Created(已创建)</td>
<td style="text-align:left">请求成功并且服务器创建了新的资源</td>
</tr>
<tr>
<td style="text-align:left">202</td>
<td style="text-align:left">Accepted(已接收)</td>
<td style="text-align:left">服务器已接收请求，但尚未处理</td>
</tr>
<tr>
<td style="text-align:left">203</td>
<td style="text-align:left">Non-Authoritative Information(非授权信息)</td>
<td style="text-align:left">服务器已成功处理了请求，但返回的信息可能来自另一资源</td>
</tr>
<tr>
<td style="text-align:left">204</td>
<td style="text-align:left">No Content(无内容)</td>
<td style="text-align:left">服务器成功处理了请求，但没有返回任何内容</td>
</tr>
<tr>
<td style="text-align:left">205</td>
<td style="text-align:left">Reset Content(重置内容)</td>
<td style="text-align:left">服务器成功处理了请求，但没有返回任何内容</td>
</tr>
<tr>
<td style="text-align:left">206</td>
<td style="text-align:left">Partial Content(部分内容)</td>
<td style="text-align:left">服务器成功处理了部分GET请求</td>
</tr>
</tbody>
</table>
<h4 id="3-300-399——重定向状态码"><a href="#3-300-399——重定向状态码" class="headerlink" title="3. 300~399——重定向状态码"></a>3. 300~399——重定向状态码</h4><p>表示要完成请求，需要进一步操作。通常，这些状态码用来重定向</p>
<table>
<thead>
<tr>
<th style="text-align:left">状态码</th>
<th style="text-align:left">原因短语</th>
<th style="text-align:left">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">300</td>
<td style="text-align:left">Multiple Choices（多种选择）</td>
<td style="text-align:left">针对请求，服务器可执行多种操作。 服务器可根据请求者 (user agent) 选择一项操作，或提供操作列表供请求者选择。</td>
</tr>
<tr>
<td style="text-align:left">301</td>
<td style="text-align:left">Moved Permanently (永久移除)</td>
<td style="text-align:left">请求的网页已永久移动到新的位置。服务器返回此响应(对GET和HEAD请求的响应)时，会自动将请求者转到新位置</td>
</tr>
<tr>
<td style="text-align:left">302</td>
<td style="text-align:left">Found(临时移动)</td>
<td style="text-align:left">服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。</td>
</tr>
<tr>
<td style="text-align:left">303</td>
<td style="text-align:left">See Other(查看其它位置)</td>
<td style="text-align:left">请求者应当对不同的位置使用单独的GET请求来检索响应时，服务器返回此代码</td>
</tr>
<tr>
<td style="text-align:left">304</td>
<td style="text-align:left">Not Modified (未修改)</td>
<td style="text-align:left">自从上次请求后，请求的网页未修改过。服务器返回此响应时，不会返回网页内容</td>
</tr>
<tr>
<td style="text-align:left">305</td>
<td style="text-align:left">Use Proxy (使用代理)</td>
<td style="text-align:left">请求者只能使用代理访问请求的网页。 如果服务器返回此响应，还表示请求者应使用代理。</td>
</tr>
<tr>
<td style="text-align:left">307</td>
<td style="text-align:left">Temporary Redirect（临时重定向）</td>
<td style="text-align:left">服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。</td>
</tr>
</tbody>
</table>
<h4 id="4-400-499——客户端错误状态码"><a href="#4-400-499——客户端错误状态码" class="headerlink" title="4. 400~499——客户端错误状态码"></a>4. 400~499——客户端错误状态码</h4><p>表示请求可能出错，妨碍了服务器的处理</p>
<table>
<thead>
<tr>
<th style="text-align:left">状态码</th>
<th style="text-align:left">原因短语</th>
<th style="text-align:left">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">400</td>
<td style="text-align:left">Bad Request (请求错误)</td>
<td style="text-align:left">服务器不理解请求的语法。</td>
</tr>
<tr>
<td style="text-align:left">401</td>
<td style="text-align:left">Unauthorized (未授权)</td>
<td style="text-align:left">请求要求身份验证。 对于需要登录的网页，服务器可能返回此响应</td>
</tr>
<tr>
<td style="text-align:left">402</td>
<td style="text-align:left">Payment Required</td>
<td style="text-align:left">状态码还未使用，保留，以作未来之用</td>
</tr>
<tr>
<td style="text-align:left">403</td>
<td style="text-align:left">Forbidden (禁止)</td>
<td style="text-align:left">服务器拒绝请求</td>
</tr>
<tr>
<td style="text-align:left">404</td>
<td style="text-align:left">Not Found (未找到)</td>
<td style="text-align:left">服务器找不到请求的网页</td>
</tr>
<tr>
<td style="text-align:left">405</td>
<td style="text-align:left">Method Not Allowed (方法禁用)</td>
<td style="text-align:left">禁用请求中指定的方法</td>
</tr>
<tr>
<td style="text-align:left">406</td>
<td style="text-align:left">Not Acceptable (不接受)</td>
<td style="text-align:left">无法使用请求的内容特性响应请求的网页。</td>
</tr>
<tr>
<td style="text-align:left">407</td>
<td style="text-align:left">Proxy Authentication Required (需要代理授权)</td>
<td style="text-align:left">此状态代码与 401（未授权）类似，但指定请求者应当授权使用代理。</td>
</tr>
<tr>
<td style="text-align:left">408</td>
<td style="text-align:left">Request Timeout (请求超时)</td>
<td style="text-align:left">服务器等候请求时发生超时。</td>
</tr>
<tr>
<td style="text-align:left">409</td>
<td style="text-align:left">Conflict (冲突)</td>
<td style="text-align:left">服务器在完成请求时发生冲突。 服务器必须在响应中包含有关冲突的信息。</td>
</tr>
<tr>
<td style="text-align:left">410</td>
<td style="text-align:left">Gone (已删除)</td>
<td style="text-align:left">如果请求的资源已永久删除，服务器就会返回此响应。</td>
</tr>
<tr>
<td style="text-align:left">411</td>
<td style="text-align:left">Length Required (需要有效长度)</td>
<td style="text-align:left">服务器不接受不含有效内容长度标头字段的请求。</td>
</tr>
<tr>
<td style="text-align:left">412</td>
<td style="text-align:left">Precondition Failed (未满足前提条件)</td>
<td style="text-align:left">服务器未满足请求者在请求中设置的其中一个前提条件。</td>
</tr>
<tr>
<td style="text-align:left">413</td>
<td style="text-align:left">Request Entity Too Large (请求实体过大)</td>
<td style="text-align:left">服务器无法处理请求，因为请求实体过大，超出服务器的处理能力。</td>
</tr>
<tr>
<td style="text-align:left">414</td>
<td style="text-align:left">Request URL Too Long (请求的 URI 过长)</td>
<td style="text-align:left">请求的 URI（通常为网址）过长，服务器无法处理</td>
</tr>
<tr>
<td style="text-align:left">415</td>
<td style="text-align:left">Unsupported Media Type (不支持的媒体类型)</td>
<td style="text-align:left">请求的格式不受请求页面的支持。</td>
</tr>
<tr>
<td style="text-align:left">416</td>
<td style="text-align:left">Requested Range Not Satisfiable (请求范围不符合要求)</td>
<td style="text-align:left">如果页面无法提供请求的范围，则服务器会返回此状态代码。</td>
</tr>
<tr>
<td style="text-align:left">417</td>
<td style="text-align:left">Expectation Failed (未满足期望值)</td>
<td style="text-align:left">服务器未满足”期望”请求标头字段的要求</td>
</tr>
</tbody>
</table>
<h4 id="5-500-599——服务端错误状态码"><a href="#5-500-599——服务端错误状态码" class="headerlink" title="5. 500~599——服务端错误状态码"></a>5. 500~599——服务端错误状态码</h4><p>表示服务器在尝试处理请求时发生内部错误。 这些错误可能是服务器本身的错误，而不是请求出错。</p>
<table>
<thead>
<tr>
<th style="text-align:left">状态码</th>
<th style="text-align:left">原因短语</th>
<th style="text-align:left">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">500</td>
<td style="text-align:left">Internal Server Error (服务器内部错误)</td>
<td style="text-align:left">服务器遇到错误，无法完成请求</td>
</tr>
<tr>
<td style="text-align:left">501</td>
<td style="text-align:left">Not Implemented (尚未实施)</td>
<td style="text-align:left">服务器不具备完成请求的功能。 例如，服务器无法识别请求方法时可能会返回此代码。</td>
</tr>
<tr>
<td style="text-align:left">502</td>
<td style="text-align:left">Bad Gateway (错误网关)</td>
<td style="text-align:left">服务器作为网关或代理，从上游服务器收到无效响应。</td>
</tr>
<tr>
<td style="text-align:left">503</td>
<td style="text-align:left">Service Unavailable (服务不可用)</td>
<td style="text-align:left">服务器目前无法使用（由于超载或停机维护）。 通常，这只是暂时状态。</td>
</tr>
<tr>
<td style="text-align:left">504</td>
<td style="text-align:left">Gateway Timeout (网关超时)</td>
<td style="text-align:left">服务器作为网关或代理，但是没有及时从上游服务器收到请求。</td>
</tr>
<tr>
<td style="text-align:left">505</td>
<td style="text-align:left">HTTP Version Not Supported (HTTP 版本不受支持)</td>
<td style="text-align:left">服务器不支持请求中所用的 HTTP 协议版本。</td>
</tr>
</tbody>
</table>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;HTTP状态码被分成五大类&lt;/p&gt;
&lt;h4 id=&quot;1-100-199——信息性状态码&quot;&gt;&lt;a href=&quot;#1-100-199——信息性状态码&quot; class=&quot;headerlink&quot; title=&quot;1. 100~199——信息性状态码&quot;&gt;&lt;/a&gt;1. 100~199——信息性状态码&lt;/h4&gt;&lt;p&gt;表示临时响应并需要请求者继续执行操作的状态码&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&quot;text-align:left&quot;&gt;状态码&lt;/th&gt;
&lt;th style=&quot;text-align:left&quot;&gt;原因短语&lt;/th&gt;
&lt;th style=&quot;text-align:left&quot;&gt;含义&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;100&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;Continue (继续)&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;请求者应当继续提出请求。 服务器返回此代码表示已收到请求的第一部分，正在等待其余部分。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;101&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;Switching Protocols (切换协议)&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;请求者已要求服务器切换协议，服务器已确认并准备切换。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
    
    </summary>
    
      <category term="网络" scheme="http://yoursite.com/categories/%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="HTTP" scheme="http://yoursite.com/tags/HTTP/"/>
    
  </entry>
  
</feed>
