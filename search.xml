<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[hexo git提交出现验证报错问题解决]]></title>
    <url>%2F2020%2F04%2F16%2Fhexo%20git%E6%8F%90%E4%BA%A4%2F</url>
    <content type="text"><![CDATA[安装hexo对于git的部署工具。npm install hexo-deployer-git –save 执行 hexo deploy 后,出现验证报错报错verification failed：Error: Host key verification failed.fatal: Could not read from remote repository.Please make sure you have the correct access rights and the repository exists. 解决方法：条件SSHkey1$ ssh-keygen -t rsa -C &quot;邮箱&quot; 三次回车，即可设置密码为空 将生成的C:\Users\your_user_director.ssh目录下的id_rsa.pub添加到github上 再测试是否可以连接到github上，1$ ssh git@github.com Hi imsofter! You’ve successfully authenticated, but GitHub does not provide shell access.Connection to github.com closed.]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面试总结]]></title>
    <url>%2F2019%2F11%2F13%2F%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[HTML5新特性 新增canvas、video、audio等新标签元素，新增特殊内容元素：article、footer、header、nav、section等，新增表单控件：Calendar、date、time、email、url、search HTML5地理定位HTML5 Geolocation API 用于获得用户的地理位置。 新增webSocket/webWork技术 HTML5 Web 存储Web Storage DOM API 为Web应用提供了一个能够替代cookie的Javascript解决方案sessionStorage—客户端数据存储，只能维持在当前会话范围内。sessionStorage 方法针对一个 session 进行数据存储。当用户关闭浏览器窗口后，数据会被删除。localStorage—客户端数据存储，能维持在多个会话范围内。localStorage 对象存储的数据没有时间限制。第二天、第二周或下一年之后，数据依然可用。 let const var 区别 var定义的变量，没有块的概念，可以跨块访问, 不能跨函数访问。 变量提升 let定义的变量，只能在块作用域里访问，不能跨块访问，也不能跨函数访问。 const用来定义常量，使用时必须初始化(即必须赋值)，只能在块作用域里访问，而且不能修改。 同一个变量只能使用一种方式声明，不然会报错 JavaScript 变量提升 JavaScript 中，函数及变量的声明都将被提升到函数的最顶部。 JavaScript 中，变量可以在使用后声明，也就是变量可以先使用再声明。 json对象合并的方法 循环遍历法 1234567891011121314151617181920function extend() &#123; var length = arguments.length; if(length == 0)return &#123;&#125;; if(length == 1)return arguments[0]; var target = arguments[0] || &#123;&#125;; for (var i = 1; i &lt; length; i++) &#123; var source = arguments[i]; for (var key in source) &#123; if (source.hasOwnProperty(key)) &#123; target[key] = source[key]; &#125; &#125; &#125; return target;&#125;const obj1 = &#123; a: 1, b: 2 &#125;;const obj2 = &#123; b: 3, c: 4, d: 5 &#125;;const result = extend(obj1, obj2);console.log(result);//&#123; a: 1, b: 3, c: 4, d: 5 &#125; Object.assign() 1234const obj1 = &#123; a: 1, b: 2 &#125;;const obj2 = &#123; b: 3, c: 4, d: 5 &#125;;const result = Object.assign(obj1, obj2);console.log(result);//&#123; a: 1, b: 3, c: 4, d: 5 &#125; jQuery $.extend 1234const obj1 = &#123; a: 1, b: 2 &#125;;const obj2 = &#123; b: 3, c: 4, d: 5 &#125;;const result = $.extend(obj1, obj2);console.log(result);//&#123; a: 1, b: 3, c: 4, d: 5 &#125; JS中的扩展运算符…JS中的扩展运算符一般用于以下情况： 数组和对象的深拷贝（仅限单层数组或对象的深拷贝，实际上对于数组和对象的嵌套来说还是浅拷贝）1234let arr = [&apos;a&apos;,&apos;b&apos;]let arr1 = [...arr]let [...arr2] = arrconsole.log(arr1,arr2) //输出[&apos;a&apos;,&apos;b&apos;] [&apos;a&apos;,&apos;b&apos;] 这里数组arr和arr1和arr2存储在不同的对内存地址中，互相之间不会产生任何影响。 数组或对象的拼接 1234let arr = [&apos;a&apos;,&apos;b&apos;]let arr1 = [&apos;c&apos;]let arr2 = [...arr,...arr1]console.log(arr2) //输出[&apos;a&apos;,&apos;b&apos;,&apos;c&apos;] 要注意的是：如果是对象的拼接，对于同一个key的键值对，后面的会覆盖前面的，如：1234let obj = &#123;name:&apos;xyp&apos;,age:18&#125;let obj = &#123;name:&apos;zyp&apos;&#125;let obj3 = &#123;...obj1, ...obj2&#125;console.log(obj3) //输出结果为：&#123;name:&quot;zyp&quot;,age:18&#125; 函数传参（结构赋值） 12345678function add(...arr)&#123; let sum = 0 arr[0] = 11 sum = arr.reduce((prev,cur) =&gt; &#123; return prev + cur &#125;,0) return sum&#125; 1234let arr = [1,2]let sum = add(...arr)console.log(sum) //得到的值是13console。log(arr) //得到的值依然是[1,2]]]></content>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS固定宽高图片裁剪居中显示]]></title>
    <url>%2F2019%2F09%2F10%2FCSS%E5%9B%BA%E5%AE%9A%E5%AE%BD%E9%AB%98%E5%9B%BE%E7%89%87%E8%A3%81%E5%89%AA%E5%B1%85%E4%B8%AD%E6%98%BE%E7%A4%BA%2F</url>
    <content type="text"><![CDATA[使用background实现；具体代码HTML1&lt;div class=&quot;cover-box&quot; style=&quot;background-image:url(&apos;图片地址&apos;)&quot;&gt;&lt;/div&gt; CSS12345width: 200px;height: 200px;background-size: cover;background-repeat: no-repeat;background-position: center;]]></content>
      <categories>
        <category>前端笔记</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Webpack学习笔记]]></title>
    <url>%2F2019%2F09%2F10%2FWebpack%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[安装Webpack新建一个空文件夹 ，打开cmd运行命令1234//全局安装npm install -g webpack//安装到你的项目目录npm install --save-dev webpack 新建package.json在上述练习文件夹中创建一个package.json文件，这是一个标准的npm说明文件，里面蕴含了丰富的信息，包括当前项目的依赖模块，自定义的脚本任务等等。在终端中使用npm init命令可以自动创建这个package.json文件1npm init package.json 里这个name 不能使用所需要安装包的名字！ 创建新文件夹存放文件回到之前的空文件夹，并在里面创建两个文件夹,source文件夹和public文件夹，source文件夹用来存放原始数据和我们将写的JavaScript模块，public文件夹用来存放之后供浏览器读取的文件（包括使用webpack打包生成的js文件以及一个index.html文件）。接下来我们再创建三个文件:index.html –放在public文件夹中;Greeter.js– 放在source文件夹中;main.js– 放在source文件夹中; index.html 代码在index.html文件中写入最基础的html代码，它在这里目的在于引入打包后的js文件。12345678910111213&lt;!-- index.html --&gt;&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;Webpack Sample Project&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&apos;root&apos;&gt; &lt;/div&gt; &lt;script src=&quot;bundle.js&quot;&gt;&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; Greeter.js在Greeter.js中定义一个返回包含问候信息的html元素的函数,并依据CommonJS规范导出这个函数为一个模块123456// Greeter.jsmodule.exports = function() &#123; var greet = document.createElement(&apos;div&apos;); greet.textContent = &quot;Hello World&quot;; return greet;&#125;; main.js在main.js文件中写入下述代码，用以把Greeter模块返回的节点插入页面。123//main.js const greeter = require(&apos;./Greeter.js&apos;);document.querySelector(&quot;#root&quot;).appendChild(greeter()); 通过配置文件来使用Webpack在当前练习文件夹的根目录下新建一个名为webpack.config.js的文件，在其中写入如下所示的简单配置代码，目前的配置主要涉及到的内容是入口文件路径和打包后文件的存放路径。1234567module.exports = &#123; entry: __dirname + &quot;/app/main.js&quot;,//唯一入口文件 output: &#123; path: __dirname + &quot;/public&quot;,//打包后的文件存放的地方 filename: &quot;bundle.js&quot;//打包后输出文件的文件名 &#125;&#125; 更快捷的执行打包任务对npm进行配置后可以在命令行中使用简单的npm start命令打包任务。在package.json中对scripts对象进行相关设置即可，设置方法如下。123456789101112131415&#123; &quot;name&quot;: &quot;webpackDemo&quot;, &quot;version&quot;: &quot;1.0.0&quot;, &quot;description&quot;: &quot;&quot;, &quot;main&quot;: &quot;index.js&quot;, &quot;scripts&quot;: &#123; &quot;start&quot;: &quot;webpack&quot; &#125;, &quot;author&quot;: &quot;wangmanna&quot;, &quot;license&quot;: &quot;ISC&quot;, &quot;devDependencies&quot;: &#123; &quot;webpack&quot;: &quot;^4.39.3&quot;, &quot;webpack-cli&quot;: &quot;^3.3.8&quot; &#125;&#125; npm的start命令是一个特殊的脚本名称，其特殊性表现在，在命令行中使用npm start就可以执行其对于的命令，如果对应的此脚本名称不是start，想要在命令行中运行时，需要这样用npm run {script name}如npm run build，在命令行中输入npm start，输出结果如下：]]></content>
      <categories>
        <category>前端笔记</category>
      </categories>
      <tags>
        <tag>Webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ios input输入框光标掉落问题]]></title>
    <url>%2F2019%2F09%2F10%2Fios%20input%E8%BE%93%E5%85%A5%E6%A1%86%E5%85%89%E6%A0%87%E6%8E%89%E8%90%BD%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[最近在做的一个移动端页面在ios手机上，输入框的光标出现了一个问题， 页面是一个弹出的评论弹窗，用的是position:fixed;定位输入框的在ios11手机上出现光标掉落的问题 解决方法修改body的定位为fixed关闭弹框之后得将body的定位修改回去]]></content>
      <categories>
        <category>浏览器兼容</category>
      </categories>
      <tags>
        <tag>移动端兼容问题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js 99乘法表]]></title>
    <url>%2F2018%2F09%2F18%2Fjs-99%E4%B9%98%E6%B3%95%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[代码12345678910//九九乘法表 function multiplication_table()&#123; for(var i=1;i&lt;=9;i++)&#123; for(var j=1;j&lt;=i;j++)&#123; document.write(j+&quot;×&quot;+i+&quot;=&quot;+i*j+&quot;&amp;nbsp;&amp;nbsp;&amp;nbsp;&quot;); &#125; document.write(&quot;&lt;br&gt;&quot;) &#125; &#125; multiplication_table(); 效果]]></content>
      <categories>
        <category>前端笔记</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Router路由]]></title>
    <url>%2F2018%2F09%2F03%2FReact%E8%B7%AF%E7%94%B1%2F</url>
    <content type="text"><![CDATA[路由根据请求不同返回不同页面 React插件 React-router 准备React组件React Router npm安装 npm install react-router –save-dev 引入1improt &#123;Router，Route，hasHistory&#125; from &quot;react-router&quot; 上面的代码相当于1234import ReactRouter from &quot;react-router&quot;var Router = ReactRouter.Router;var Route = ReactRouter.Route;var hasHistory = ReactRouter.hasHistory; Router是整个大的路由Route代表一个路由项 Router组件本身只是个容器，真正的路由要通过Route组件定义123456789render()&#123; return( &lt;Router history=&#123;hasHistory&#125;&gt; &lt;Route path=&quot;/&quot; component=&#123;IndexComponent&#125; /&gt; &lt;Route path=&quot;/&quot; component=&#123;DetailComponent&#125; /&gt; &lt;/Router&gt; )&#125; 上面Router组件有一个参数history,它的值hasHistory表示，路由的切换由url的hash变化决定，即URL的#部分发生变化。举例来说，用户访问http://www.example.com/ , 实际上会看到的是http://www.example.com/#/.Router组件定义了URL路径与组件的对应关系。可以使用多个Route组件。 路由嵌套Route组件还可以嵌套123456&lt;Router history=&#123;hashHistory&#125;&gt; &lt;Route path=&quot;/&quot; component=&#123;App&#125;&gt; &lt;Route path=&quot;/repos&quot; component=&#123;Repos&#125;/&gt; &lt;Route path=&quot;/about&quot; component=&#123;About&#125;/&gt; &lt;/Route&gt;&lt;/Router&gt; 上面的代码中，用户访问/repos时，会先加载APP组件，然后再在它内部再加载Repos组件。123&lt;App&gt; &lt;Repos /&gt;&lt;/App&gt; App组件要写成下面的样子1234567export default React.createClass(&#123; render() &#123; return &lt;div&gt; &#123;this.props.children&#125; &lt;/div&gt; &#125;&#125;) 上面的代码中，App组件的this.props.children属性就是子组件。子路由也可以不写在Router组件里面，单独传入Router组件的routes属性。1234567let routes = &lt;Route path=&quot;/&quot; component=&#123;App&#125;&gt; &lt;Route path=&quot;/repos&quot; component=&#123;Repos&#125;/&gt; &lt;Route path=&quot;/about&quot; component=&#123;About&#125;/&gt;&lt;/Route&gt;;&lt;Router routes=&#123;routes&#125; history=&#123;browserHistory&#125;/&gt; path属性Route组件的path属性指定路由的匹配规则。这个属性是可以省略的，这样的话，不管路径是否匹配，总是会加载指定组件。123&lt;Route path=&quot;inbox&quot; component=&#123;Inbox&#125;&gt; &lt;Route path=&quot;message/:id&quot; component=&#123;Message&#125; /&gt;&lt;/Route&gt; 上面的代码中，当用户访问/inbox/message/:id时，会加载下面的组件。123&lt;Inbox&gt; &lt;Message /&gt;&lt;/Inbox&gt; 如果是省略外层Route的path参数，写成下面的样子。123&lt;Route component=&#123;Inbox&#125;&gt; &lt;Route path=&quot;inbox/message/:id&quot; component=&#123;Message&#125; /&gt;&lt;/Route&gt; 现在用户访问/inbox/message/:id时，组件加载还是原来的样子 通配符path属性可以使用通配符1234567891011121314151617181920&lt;Route path=&quot;/hello/:name&quot;&gt;//匹配 /hello/michael//匹配 /hello/rerf&lt;Route path=&quot;/hello(/:name)&quot;&gt;//匹配 /hello//匹配 /hello/asda&lt;Route path=&quot;/files/*.*&quot;&gt;//匹配 /files/hello.jpg//匹配 /files/hello.html&lt;Route path=&quot;/files/*&quot;&gt;//匹配 /files///匹配 /files/a//匹配 /files/a/s&lt;Route path=&quot;/**/*.jpg&quot;&gt;// 匹配 /files/hello.jpg// 匹配 /files/path/to/file.jpg 通配符的规则如下。 :paramName:paramName匹配URL的一个部分，直到遇到下一个/、?、#为止。这个路径参数可以通过this.props.params.paramName取出。 ()()表示URL的这个部分是可选的。 **匹配任意字符，直到模式里面的下一个字符为止。匹配方式是非贪婪模式。 **** 匹配任意字符，直到下一个/、?、#为止。匹配方式是贪婪模式。path属性也可以使用相对路径（不以/开头），匹配时就会相对于父组件的路径，可以参考上一节的例子。嵌套路由如果想摆脱这个规则，可以使用绝对路由。路由匹配规则是从上到下执行，一旦发现匹配，就不再其余的规则了。12&lt;Route path=&quot;/comments&quot; ... /&gt;&lt;Route path=&quot;/comments&quot; ... /&gt; 上面代码中，路径/comments同时匹配两个规则，第二个规则不会生效。设置路径参数时，需要特别小心这一点。1234&lt;Router&gt; &lt;Route path=&quot;/:userName/:id&quot; component=&#123;UserPage&#125;/&gt; &lt;Route path=&quot;/about/me&quot; component=&#123;About&#125;/&gt;&lt;/Router&gt; 上面代码中，用户访问/about/me时，不会触发第二个路由规则，因为它会匹配/:userName/:id这个规则。因此，带参数的路径一般要写在路由规则的底部。此外，URL的查询字符串/foo?bar=baz，可以用this.props.location.query.bar获取。 IndexRoute 组件123456&lt;Router&gt; &lt;Route path=&quot;/&quot; component=&#123;App&#125;&gt; &lt;Route path=&quot;accounts&quot; component=&#123;Accounts&#125;/&gt; &lt;Route path=&quot;statements&quot; component=&#123;Statements&#125;/&gt; &lt;/Route&gt;&lt;/Router&gt; 上面代码中，访问根路径/，不会加载任何子组件。也就是说，App组件的this.props.children，这时是undefined。因此，通常会采用{this.props.children || }这样的写法。这时，Home明明是Accounts和Statements的同级组件，却没有写在Route中。IndexRoute就是解决这个问题，显式指定Home是根路由的子组件，即指定默认情况下加载的子组件。你可以把IndexRoute想象成某个路径的index.html。1234567&lt;Router&gt; &lt;Route path=&quot;/&quot; component=&#123;App&#125;&gt; &lt;IndexRoute component=&#123;Home&#125;/&gt; &lt;Route path=&quot;accounts&quot; component=&#123;Accounts&#125;/&gt; &lt;Route path=&quot;statements&quot; component=&#123;Statements&#125;/&gt; &lt;/Route&gt;&lt;/Router&gt; 现在，用户访问/的时候，加载的组件结构如下。123&lt;App&gt; &lt;Home/&gt;&lt;/App&gt; 这种组件结构就很清晰了：App只包含下级组件的共有元素，本身的展示内容则由Home组件定义。这样有利于代码分离，也有利于使用React Router提供的各种API。注意，IndexRoute组件没有路径参数path。 Redirect 组件组件用于路由的跳转，即用户访问一个路由，会自动跳转到另一个路由。1234&lt;Route path=&quot;inbox&quot; component=&#123;Inbox&#125;&gt; &#123;/* 从 /inbox/messages/:id 跳转到 /messages/:id */&#125; ＜Redirect from=&quot;messages/:id&quot; to=&quot;/messages/:id&quot; /&gt;&lt;/Route&gt; 现在访问/inbox/messages/5，会自动跳转到/messages/5。 IndexRedirect 组件IndexRedirect组件用于访问根路由的时候，将用户重定向到某个子组件。12345&lt;Route path=&quot;/&quot; component=&#123;App&#125;&gt; &lt;IndexRedirect to=&quot;/welcome&quot; /&gt; &lt;Route path=&quot;welcome&quot; component=&#123;Welcome&#125; /&gt; &lt;Route path=&quot;about&quot; component=&#123;About&#125; /&gt;&lt;/Route&gt; 上面代码中，用户访问根路径时，将自动重定向到子组件welcome。 LinkLink组件用于取代元素，生成一个链接，允许用户点击后跳转到另一个路由。它基本上就是元素的React 版本，可以接收Router的状态。12345678render() &#123; return &lt;div&gt; &lt;ul role=&quot;nav&quot;&gt; &lt;li&gt;&lt;Link to=&quot;/about&quot;&gt;About&lt;/Link&gt;&lt;/li&gt; &lt;li&gt;&lt;Link to=&quot;/repos&quot;&gt;Repos&lt;/Link&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&#125; 如果希望当前的路由与其他路由有不同样式，这时可以使用Link组件的activeStyle属性。12&lt;Link to=&quot;/about&quot; activeStyle=&#123;&#123;color: &apos;red&apos;&#125;&#125;&gt;About&lt;/Link&gt;&lt;Link to=&quot;/repos&quot; activeStyle=&#123;&#123;color: &apos;red&apos;&#125;&#125;&gt;Repos&lt;/Link&gt; 上面代码中，当前页面的链接会红色显示。另一种做法是，使用activeClassName指定当前路由的Class。12&lt;Link to=&quot;/about&quot; activeClassName=&quot;active&quot;&gt;About&lt;/Link&gt;&lt;Link to=&quot;/repos&quot; activeClassName=&quot;active&quot;&gt;Repos&lt;/Link&gt; 上面代码中，当前页面的链接的class会包含active。在Router组件之外，导航到路由页面，可以使用浏览器的History API，像下面这样写。12import &#123; browserHistory &#125; from &apos;react-router&apos;;browserHistory.push(&apos;/some/path&apos;); IndexLink如果链接到根路由/，不要使用Link组件，而要使用IndexLink组件。这是因为对于根路由来说，activeStyle和activeClassName会失效，或者说总是生效，因为/会匹配任何子路由。而IndexLink组件会使用路径的精确匹配。123&lt;IndexLink to=&quot;/&quot; activeClassName=&quot;active&quot;&gt; Home&lt;/IndexLink&gt; 上面代码中，根路由只会在精确匹配时，才具有activeClassName。另一种方法是使用Link组件的onlyActiveOnIndex属性，也能达到同样效果。123&lt;Link to=&quot;/&quot; activeClassName=&quot;active&quot; onlyActiveOnIndex=&#123;true&#125;&gt; Home&lt;/Link&gt; 实际上，IndexLink就是对Link组件的onlyActiveOnIndex属性的包装。 histroy 属性Router组件的history属性，用来监听浏览器地址栏的变化，并将URL解析成一个地址对象，供 React Router 匹配。history属性，一共可以设置三种值。 browserHistoryhashHistorycreateMemoryHistory 如果设为hashHistory，路由将通过URL的hash部分（#）切换，URL的形式类似example.com/#/some/path。123456import &#123; hashHistory &#125; from &apos;react-router&apos;render( &lt;Router history=&#123;hashHistory&#125; routes=&#123;routes&#125; /&gt;, document.getElementById(&apos;app&apos;)) 如果设为browserHistory，浏览器的路由就不再通过Hash完成了，而显示正常的路径example.com/some/path，背后调用的是浏览器的History API。123456import &#123; browserHistory &#125; from &apos;react-router&apos;render( &lt;Router history=&#123;browserHistory&#125; routes=&#123;routes&#125; /&gt;, document.getElementById(&apos;app&apos;)) 但是，这种情况需要对服务器改造。否则用户直接向服务器请求某个子路由，会显示网页找不到的404错误。如果开发服务器使用的是webpack-dev-server，加上–history-api-fallback参数就可以了。 $ webpack-dev-server –inline –content-base . –history-api-fallbackcreateMemoryHistory主要用于服务器渲染。它创建一个内存中的history对象，不与浏览器URL互动。 1const history = createMemoryHistory(location) 表单处理Link组件用于正常的用户点击跳转，但是有时还需要表单跳转、点击按钮跳转等操作。这些情况怎么跟React Router对接呢？下面是一个表单。12345&lt;form onSubmit=&#123;this.handleSubmit&#125;&gt; &lt;input type=&quot;text&quot; placeholder=&quot;userName&quot;/&gt; &lt;input type=&quot;text&quot; placeholder=&quot;repo&quot;/&gt; &lt;button type=&quot;submit&quot;&gt;Go&lt;/button&gt;&lt;/form&gt; 第一种方法是使用browserHistory.push12345678910import &#123; browserHistory &#125; from &apos;react-router&apos;// ... handleSubmit(event) &#123; event.preventDefault() const userName = event.target.elements[0].value const repo = event.target.elements[1].value const path = `/repos/$&#123;userName&#125;/$&#123;repo&#125;` browserHistory.push(path) &#125;, 第二种方法是使用context对象。123456789101112export default React.createClass(&#123; // ask for `router` from context contextTypes: &#123; router: React.PropTypes.object &#125;, handleSubmit(event) &#123; // ... this.context.router.push(path) &#125;,&#125;) 路由的钩子每个路由都有Enter和Leave钩子，用户进入或离开该路由时触发。1234&lt;Route path=&quot;about&quot; component=&#123;About&#125; /&gt;&lt;Route path=&quot;inbox&quot; component=&#123;Inbox&#125;&gt; &lt;Redirect from=&quot;messages/:id&quot; to=&quot;/messages/:id&quot; /&gt;&lt;/Route&gt; 上面的代码中，如果用户离开/messages/:id，进入/about时，会依次触发以下的钩子。/messages/:id的onLeave/inbox的onLeave/about的onEnter下面是一个例子，使用onEnter钩子替代组件。12345678&lt;Route path=&quot;inbox&quot; component=&#123;Inbox&#125;&gt; &lt;Route path=&quot;messages/:id&quot; onEnter=&#123; (&#123;params&#125;, replace) =&gt; replace(`/messages/$&#123;params.id&#125;`) &#125; /&gt;&lt;/Route&gt; onEnter钩子还可以用来做认证。1234567891011const requireAuth = (nextState, replace) =&gt; &#123; if (!auth.isAdmin()) &#123; // Redirect to Home page if not an Admin replace(&#123; pathname: &apos;/&apos; &#125;) &#125;&#125;export const AdminRoutes = () =&gt; &#123; return ( &lt;Route path=&quot;/admin&quot; component=&#123;Admin&#125; onEnter=&#123;requireAuth&#125; /&gt; )&#125; 下面是一个高级应用，当用户离开一个路径的时候，跳出一个提示框，要求用户确认是否离开。1234567891011121314151617const Home = withRouter( React.createClass(&#123; componentDidMount() &#123; this.props.router.setRouteLeaveHook( this.props.route, this.routerWillLeave ) &#125;, routerWillLeave(nextLocation) &#123; // 返回 false 会继续停留当前页面， // 否则，返回一个字符串，会显示给用户，让其自己决定 if (!this.state.isSaved) return &apos;确认要离开？&apos;; &#125;, &#125;)) 上面代码中，setRouteLeaveHook方法为Leave钩子指定routerWillLeave函数。该方法如果返回false，将阻止路由的切换，否则就返回一个字符串，提示用户决定是否要切换。 用browserHistory到一个子页面刷新页面不好使在webpack.configz中配置,加上 historyApiFallback: true,]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue全局组件和局部组件]]></title>
    <url>%2F2018%2F09%2F03%2Fvue%E5%85%A8%E5%B1%80%E7%BB%84%E4%BB%B6%E5%92%8C%E5%B1%80%E9%83%A8%E7%BB%84%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[全局组件全局组件的实现 注册全局组件使用Vue.component(tagName,options) 123Vue.component(&apos;my-component&apos;,&#123; //选项&#125;) 注册完成后，在父实例的模板中使用 123&lt;div id=&quot;example&quot;&gt; &lt;my-component&gt;&lt;/my-component&gt;&lt;/div&gt; 局部注册不用在全局注册每个组件。通过使用组件实例选项注册，可以使组件仅在另一个实例/组件的作用域中可用12345678var Child = &#123; template: &apos;&apos;&#125;new Vue(&#123; components: &#123; &apos;my-component&apos;: Child &#125;&#125;) 全局组件和局部组件的区别 全局组件：Vue中所有的实例都能使用该组件 局部组件： 只能在当前实例中使用该组件]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React-虚拟DOM]]></title>
    <url>%2F2018%2F08%2F15%2FReact-%E8%99%9A%E6%8B%9FDOM%2F</url>
    <content type="text"><![CDATA[虚拟DOM虚拟DOM是React的基石，DOM操作非常昂贵。在前端开发中，性能消耗最大的就是DOM操作，而且这部分代码会让整体项目的代码变得难以维护。React把真实DOM树转换成JavaScript对象树，也就是Virtual DOM。React之所以快，是因为他不直接操作DOM。React将DOM结构存储在内存中，然后同render()的返回内容进行比较，计算出需要改动的地方，最后才反映到DOM中。此外，React实现了一套完整的事件合成机制，能够保持事件冒泡的一致性，跨浏览器执行。甚至可以在IE8中使用HTML5的事件。 Refs和findDOMNode()为了同浏览器交互，我们有时候需要获取到真实的DOM节点。我们可以通过调用React的React.findDOMNode(component)获取到组件中真实的DOM。 React.findDOMNode()只在mounted组件中调用，mounted组件就是已经渲染在浏览器DOM结构中的组件。如果你在组件的render()方法中调用React.findDOMNode()就会抛出异常。 大部分情况下，我们都是在构建React的组件，也就是操作虚拟DOM。但是有时候我们需要访问底层的API，可能或通过使用第三方的插件来实现我们的功能，如jQuery。React也提供了接口让我们操作底层API。]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Redux基本用法]]></title>
    <url>%2F2018%2F08%2F14%2FRedux%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95%2F</url>
    <content type="text"><![CDATA[React和Redux之间的关系 Redux是什么？Redux是Facebook提出的flux架构的一种优秀实现；而且不局限于为react提供数据处理状态。它是零依赖的，可以配合其他任何框架或类库一起使用。要想配合react，还得引入react-redux。Redux简单的说就是一个事件分发器和全局state控制台。 什么时候使用Redux首先，Redux是一个有用的框架，但不是非用不可。事实上，大多数情况下，可以不用他，只用React就够了 曾经有人过这样一句话。 “如果你不知道是否需要 Redux，那就是不需要它。” Redux 的创造者 Dan Abramov 又补充了一句。 “只有遇到 React 实在解决不了的问题，你才需要 Redux 。” 简单滴来说，如果UI层设计的非常简单，没有很多互动，Redux就是不必要的，用了反而增加了复杂性 用户的使用方式非常简单 用户之间没有协作 不需要与服务器大量交互，也没有使用Websocket 视图层(view)只从单一来源获取数据 以上这些情况，都不需要使用Redux。 用户的使用方式复杂 不同身份的用户有不同的使用方式(比如普通用户和管理员) 多个用户可以协作 与服务器大量交互，或者使用了WebSocket View要从多个来源获取数据 上面这些情况才是Redux的适用场景：多交互，多数据源。 从组件的角度看，如果应用中有一下场景，可以考虑使用Redux 某个组件的状态，需要共享 某个状态需要在任何地方都可以拿到 一个组件需要改变全局状态 一个组件需要改变另一个组件的状态 发生上面的情况时，如果不使用Redux或者其他状态管理工具，不按照一定的规律处理状态的读写，代码很快就会变成一团乱麻。你需要一种机制，可以在同一个地方查询状态，改变状态，传播状态的变化。总而言之，Redux只是Web架构的一种解决方案，也可以选择其他方案。 三大原则1. 单一的数据源整个应用的state被存储在一棵Object tree中，并且这个Object tree只存在于唯一一个store中。这让同构应用开发变得非常容易。来自服务端的state可以在无需编写更多代码的情况下被序列化并注入到客户端中。由于是单一的state tree，调试也变得非常容易。在开发中可以把应用的state保存在本地，从而加快开发速度。此外，受益于单一的state tree，以前难以实现的如“撤销/重做”这类功能也变得轻而易举。 2. state是只读的唯一改变state的方法就是触发action，action是一个用于描述已发生事件的普通对象。这样确保了视图和网络请求都不能直接修改state，相反它们只能表达想要修改的意图。因为所有的修改都被集中化处理，且严格按照一个接一个的顺序执行，因此不用担心race condition的出现。Action就是普通对象而已，因此它们可以被日志打印，序列化，存储，后期调试或测试时回放出来。 3. 使用纯函数来执行修改为了描述action如何改变statetree，需要编写reducers，只要是同样的输入，必定要得到同样的输出 Redux设计思想 web应用是一个状态机，视图与状态是一一对应的。 所有的状态，保存在一个对象里面 基本API用户通过View，dispatch 相应的action，store调用reducer获取最新的state，并触发通过subscribe订阅的监听函数，监听函数中我们通过store的getState方法获取最新的state，更新view。工作流程图 1.StoreStore就是保存数据的地方，可以把它看成一个容器。整个应用只能有一个store。Redux提供createStore这个函数，用来生成Store。12import &#123;createStore&#125; form &quot;redux&quot;;const store = createStore(fn); 上面的代码中，createStore函数接收另一个参数作为参数，返回新的Store对象。 2. StateStore对象包含所有数据。如果想得到某个时点的数据，就要对Store生成快照。这种时点数据集合，就叫做State。当前时刻的State，可以通过store.getState()拿到。1const state = store.getState(); Redux规定，一个State对应一个View。只要State相同，view就相同。知道state，就能够知道view是什么样的，反之亦然。3. ActionState的变化，会导致view的变化。但是，用户接触不到state，只能接触到view。所以，state的变化必须是view导致的。Action就是View发出的通知，表示State应该要发生变化了。Action是一个对象。其中type属性四必须的，表示Action的名称。其他属性可以自由设置。1234const action = &#123; type:&apos;ADD_TODO&apos;, payload:&apos;Learn Redux&apos;&#125; 上面代码中，Action的名称是ADD_TODO，他携带的信息字符串是Learn Redux。可以这样理解，Action描述当前发生的事情。改变State的唯一变化，就是使用Action。他会运送数据到Store。 4. Action CreatorView要发送多少种消息，就会有多少种Action。如果都手写，会很麻烦。可以定义一个函数来生成Action，这个函数就叫Action Creator12345678const ADD_TODO = &quot;添加 TODO&quot;;function addToDo(text)&#123; return &#123; type:ADD_TODO, text &#125;&#125;const actioon = addTodo(&apos;Learn Redux&apos;); 上面代码中，addTodo函数就是一个Action Creator。 5. store.dispatch()store.dispatch()是View发出Action的唯一方法123456import &#123;createStore&#125;from &apos;redux&apos;;const store = createStore(fn);store.dispatch(&#123; type:&apos;ADD_TODO&apos;, payload:&apos;Learn Redux&apos;&#125;); 上面的代码中，store.dispatch接收一个Action对象作为参数，将他发送出去。结合Action Creator,这段代码可以改写如下。1store.dispath(addTodo(&quot;Learn Redux&quot;)); 6. ReducerStore收到Action以后，必须给出一个新的State，这样View才会发生变化。这种State的计算过程就叫做Reducer.Reducer是一个函数，他接受Action和当前State作为参数，返回一个新的State。1234const reducer = function(state,action)&#123; //... return new_sate;&#125; 整个应用的初始状态，可以作为State的默认值。下面是一个实际的例子。1234567891011const defaultState = 0;const reducer = (state = defaultState,action)=&gt;&#123; switch(action.type)&#123; case &apos;ADD&apos;: return state+action.payload; default: return state; &#125;&#125;;const state = reducer(1,&#123;type:&apos;ADD&apos;,payload:2&#125;); 上面代码中，reducer函数收到名为ADD的Action以后，就返回一个新的State，作为加法的计算结果。其他运算的逻辑(比如减法),也可以根据Action的不同来实现。实际应用中，Reducer函数不用像上面这样手动调用，store.dispath方法会触发Reducer的自动执行。为此，Store需要知道Reducer函数，做法就是再生成Store的时候，将Reducer传入createStore方法。123import &#123; createStore &#125; from &apos;redux&apos;;const store = createStore(reducer);` 上面代码中，createStore接受 Reducer 作为参数，生成一个新的 Store。以后每当store.dispatch发送过来一个新的 Action，就会自动调用 Reducer，得到新的 State。为什么这个函数叫做 Reducer 呢？因为它可以作为数组的reduce方法的参数。请看下面的例子，一系列 Action 对象按照顺序作为一个数组。123456const actions = [ &#123; type: &apos;ADD&apos;, payload: 0 &#125;, &#123; type: &apos;ADD&apos;, payload: 1 &#125;, &#123; type: &apos;ADD&apos;, payload: 2 &#125;];const total = actions.reduce(reducer, 0); // 3 上面代码中，数组actions表示依次有三个 Action，分别是加0、加1和加2。数组的reduce方法接受 Reducer 函数作为参数，就可以直接得到最终的状态3。7. 纯函数Reducer 函数最重要的特征是，它是一个纯函数。也就是说，只要是同样的输入，必定得到同样的输出。 纯函数是函数式编程的概念，必须遵守以下一些约束。 不得改写参数 不能调用系统 I/O 的API 不能调用Date.now()或者Math.random()等不纯的方法，因为每次会得到不一样的结果由于 Reducer 是纯函数，就可以保证同样的State，必定得到同样的 View。但也正因为这一点，Reducer 函数里面不能改变 State，必须返回一个全新的对象，请参考下面的写法。1234567891011// State 是一个对象function reducer(state, action) &#123; return Object.assign(&#123;&#125;, state, &#123; thingToChange &#125;); // 或者 return &#123; ...state, ...newState &#125;;&#125;// State 是一个数组function reducer(state, action) &#123; return [...state, newItem];&#125; 最好把 State 对象设成只读。你没法改变它，要得到新的 State，唯一办法就是生成一个新对象。这样的好处是，任何时候，与某个 View 对应的 State 总是一个不变的对象。8. store.subscribe()Store 允许使用store.subscribe方法设置监听函数，一旦 State 发生变化，就自动执行这个函数。1234import &#123; createStore &#125; from &apos;redux&apos;;const store = createStore(reducer);store.subscribe(listener); 显然，只要把 View 的更新函数（对于 React 项目，就是组件的render方法或setState方法）放入listen，就会实现 View 的自动渲染。store.subscribe方法返回一个函数，调用这个函数就可以解除监听。12345let unsubscribe = store.subscribe(() =&gt; console.log(store.getState()));unsubscribe();]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
        <tag>Redux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React-Flux]]></title>
    <url>%2F2018%2F08%2F10%2FReact-flux%2F</url>
    <content type="text"><![CDATA[React是一个视图层的框架Flux是一种设计思想配合数据架构flux可以开发大型项目RedUx就是flux具体实现单例模式的举例：Flux只把公共的数据放在store中，如果某一个数据只在一个组件中使用，如果这个数据放在store中当这个数据改变所有组件都会改变，非常消耗性能。如果所有数据都放在store中，如果不同的组件触发不同的事件可以解决消耗性能这个问题。同时带来的自动化测试非常便捷的好处。 Flux是什么Flux是Facebook用来构建客户端Web应用的应用架构。他利用单向数据流的方式来组合React中的视图组件。他更像一个模式而不是一个正式的框架，开发者不需要太多的新代码就可以上手。 基本概念Flux将一个应用分成四个部分 View: 视图层 Action(动作): 视图层发出的消息(比如mouseClick) Dispatcher(派发器): 用来接收Action、执行回调函数 Store(数据层): 用来存放应用的状态，一旦发生变动，就提醒Views要更新页面 流程图： Flux的最大特点，就是数据的”单向流动”。 用户访问View View发出用户的Action Dispatcher收到Action，要求Store进行相应的更新 Store更新后，发出一个”change”事件 View收到”Change”事件后，更新页面 上面的过程中，数据总是”单向流动”，任何相邻的部分都不会发生数据的”双向流动”。这保证了流程的清晰。]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
        <tag>Flux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React生命周期]]></title>
    <url>%2F2018%2F08%2F02%2FReact%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%2F</url>
    <content type="text"><![CDATA[React生命周期 在组件的整个生命周期中，随着该组件的props或者state发生改变，其DOM表现也会有相应的变化。一个组件就是一个状态机，对于特定地输入，他总会返回一致的输出。 一个React组件的生命周期分为三个部分：实例化、存在期和销毁时 实例化当组件在客户端被实例化，第一次被创建时，一下方法依次被调用：可以用constructor(props)来构造 getDefaultProps getIntialState componentWillMount render componentDidMount 实例化完成后的更新 getIntialState componentWillMount render componentDidMountcomponentDidMount不会在服务端被渲染的过程中调用 存在期组件已存在时的状态改变 componentWillReceiveProps shouldComponentUpdate componentWillUpdate render componentDidUpdate 销毁时componentWillUnmount 生命周期10个不同的API1. getDefaultProps作用于组件类，只调用一次，返回对象用于设置默认的props，对于引用值，会在实例中共享2. getIntialState作用于组件的实例，在实例创建时调用一次，用于初始化每个实例的state，此时可以访问this.props.3. componentWillMount在完成首次渲染之前调用，此时仍可以修改组件的state4. render必选的方法，创建虚拟DOM，该方法具有特殊的规则： 只能通过this.props和this.state访问数据 可以返回null、false或任何React组件 只可能出现一个顶级组件(不能返回数组) 不能改变组件的状态 不能修改DOM的输出 5. componentDidMount真实的DOM被渲染出来后调用，在该方法中可以通过this.getDOMNode()访问到真实的DOM元素。此时已可以使用其他类库来操作这个DOM。在服务端中，该方法不会被调用。6. componentWillReceiveProps组件接收到新的props时调用，并将其作为参数nextProps使用，此时可以更改组件props及state。1234567componentWillReceiveProps: function(nextProps) &#123; if (nextProps.bool) &#123; this.setState(&#123; bool: true &#125;); &#125; &#125; 7. shouldComponentUpdate组件是否应当渲染新的props或state，返回false表示跳过后续的生命周期方法，通常不需要使用以避免出现bug。再出现应用的瓶颈时，可通过该方法进行适当的优化。在首次渲染期间或者调用了forceUpdate方法后，该方法不会被调用8. componentWillUpdate接收到新的props或者state后，进行渲染之前调用，此时不允许更新props或state。9. componentDidUpdate完成渲染新的props或者state后调用，此时可以访问到新的DOM元素10. componentWillUnmount组件被移除之前被调用，可以用于做一些清理工作，在componentDidMount方法中添加的所有任务都需要在该方法中撤销，比如创建的定时器或添加的事件监听器。]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TCP-三次握手与四次挥手]]></title>
    <url>%2F2018%2F06%2F15%2FTCP-%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E4%B8%8E%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%2F</url>
    <content type="text"><![CDATA[TCP三次握手所谓三次握手(Three-Way Handshake)即建立TCP连接，就是指建立一个TCP连接时，需要客户端和服务端总共发送3个包已确认连接的建立。在socket编程中，这一过程由客户端执行connect来触发。整个流程如下图所示： （1）第一次握手：Client将标志位SYN置为1，随机产生一个值seq=J，并将该数据包发送给Server，Client进入SYN_SENT状态，等待Server确认。 （2）第二次握手：Server收到数据包后由标志位SYN=1知道Client请求建立连接，Server将标志位SYN和ACK都置为1，ack=J+1，随机产生一个值seq=K，并将该数据包发送给Client以确认连接请求，Server进入SYN_RCVD状态。 （3）第三次握手：Client收到确认后，检查ack是否为J+1，ACK是否为1，如果正确则将标志位ACK置为1，ack=K+1，并将该数据包发送给Server，Server检查ack是否为K+1，ACK是否为1，如果正确则连接建立成功，Client和Server进入ESTABLISHED状态，完成三次握手，随后Client与Server之间可以开始传输数据了。 第一次握手：建立连接时，客户端发送SYN包(SYN=i)到服务器，并进入到SYN-SEND状态，等待服务器确认 服务器收到SYN包，必须确认客户的SYN(ack=i+1)，同时自己也发送一个SYN包(SYN=k),即SYN+ACK包，此时服务器进入SYN-RECV状态 客户端收到服务器的SYN+ACK包，向服务器发送确认报ACK(ack=k+1),此包发送完毕，客户端和服务端进入ESTABLISHED状态，完成三次握手，客户端与服务器开始传送数据。SYN攻击：在三次握手过程中，Server发送SYN-ACK之后，收到Client的ACK之前的TCP连接称为半连接（half-open connect），此时Server处于SYN_RCVD状态，当收到ACK后，Server转入ESTABLISHED状态。SYN攻击就是Client在短时间内伪造大量不存在的IP地址，并向Server不断地发送SYN包，Server回复确认包，并等待Client的确认，由于源地址是不存在的，因此，Server需要不断重发直至超时，这些伪造的SYN包将产时间占用未连接队列，导致正常的SYN请求因为队列满而被丢弃，从而引起网络堵塞甚至系统瘫痪。SYN攻击时一种典型的DDOS攻击，检测SYN攻击的方式非常简单，即当Server上有大量半连接状态且源IP地址是随机的，则可以断定遭到SYN攻击了，使用如下命令可以让之现行：1#netstat -nap | grep SYN_RECV TCP四次挥手所谓四次挥手(Four-Way Wavehand)即终止TCP连接，就是指断开一个TCP连接时，需要客户端和服务端总共发四个包以确认连接的断开。在socket编程中，这一过程由客户端或服务器端任一方执行close来触发,整个流程如下图所示由于TCP连接时全双工的，因此，每个方向都必须要单独进行关闭，这一原则是当一方完成数据发送任务后。发送一个FIN来终止这一方向的连接，收到一个FIN只是意味着这一方向上没有数据流动了，即不会在收到数据了，但是在这个TCP连接上仍然能够发送数据，知道这一方向也发送了FIN。首先进行关闭的一方将执行主动关闭，而另一方则执行被动关闭，上图描述的即是如此 第一次挥手：Client发送一个FIN，用来关闭Client到Server的数据传送，Client进入FIN_WAIT_1状态。 第二次挥手：Server收到FIN后，发送一个ACK给Client，确认序号为收到序号+1(与SYN相同，一个FIN占用一个序号)，Server进入LAST_ACK状态。 第三次挥手：Server发送一个FIN，用来关闭Server到Silent的数据传送，Server进入LAST_ACK状态。 第四次挥手：Client收到FIN后，Client进入TIME_WAIT状态，接着发送一个ACK给Server，确认序号为收到序号+1，Server进入CLOSED状态，完成四次挥手。 为什么建立连接是三次握手，而关闭连接却是四次挥手呢？这是因为服务端在LISTEN状态下，收到建立连接请求的SYN报文后，把ACK和SYN放在一个报文里发送给客户端。而关闭连接时，当收到对方的FIN报文时，仅仅表示对方不再发送数据了但是还能接收数据，己方也未必全部数据都发送给对方了，所以己方可以立即close，也可以发送一些数据给对方后，再发送FIN报文给对方来表示同意现在关闭连接，因此，己方ACK和FIN一般都会分开发送。 为什么TIME_WAIT状态需要经过2MSL(最大报文段生存时间)才能返回到CLOSE状态？原因有二：一、保证TCP协议的全双工连接能够可靠关闭二、保证这次连接的重复数据段从网络中消失 先说第一点，如果Client直接CLOSED了，那么由于IP协议的不可靠性或者是其它网络原因，导致Server没有收到Client最后回复的ACK。那么Server就会在超时之后继续发送FIN，此时由于Client已经CLOSED了，就找不到与重发的FIN对应的连接，最后Server就会收到RST而不是ACK，Server就会以为是连接错误把问题报告给高层。这样的情况虽然不会造成数据丢失，但是却导致TCP协议不符合可靠连接的要求。所以，Client不是直接进入CLOSED，而是要保持TIME_WAIT，当再次收到FIN的时候，能够保证对方收到ACK，最后正确的关闭连接。 再说第二点，如果Client直接CLOSED，然后又再向Server发起一个新连接，我们不能保证这个新连接与刚关闭的连接的端口号是不同的。也就是说有可能新连接和老连接的端口号是相同的。一般来说不会发生什么问题，但是还是有特殊情况出现：假设新连接和已经关闭的老连接端口号是一样的，如果前一次连接的某些数据仍然滞留在网络中，这些延迟数据在建立新连接之后才到达Server，由于新连接和老连接的端口号是一样的，又因为TCP协议判断不同连接的依据是socket pair，于是，TCP协议就认为那个延迟的数据是属于新连接的，这样就和真正的新连接的数据包发生混淆了。所以TCP连接还要在TIME_WAIT状态等待2倍MSL，这样可以保证本次连接的所有数据都从网络中消失。]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>TCP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javascript-原型链继承]]></title>
    <url>%2F2017%2F09%2F02%2Fjavascript-%E5%8E%9F%E5%9E%8B%E9%93%BE%E7%BB%A7%E6%89%BF%2F</url>
    <content type="text"><![CDATA[基本思想利用原型让每一个引用类型继承另一个引用类型的属性和方法。 构造函数、原型和实例的关系每一个构造函数都有一个原型对象，原型对象都包含一个指向构造函数的指针，而实例都包含一个指向原型对象的内部指针，那么。假如让原型对象等于另一个类型的实例，结果会怎么样呢？显然，此时的原型对象将包含一个指向另一个原型的指针，相应地，另一个原型中也包含着一个指向另一个构造函数的指针。假如另一个原型又是另一个类型的实例，那么上述关系依然成立，如此层层递进，就构成了实例与原型的链条。这就是所谓原型链的基本概念 实现原型链有一种基本模式，其代码大致如下123456789101112131415161718function SuperType() &#123; this.property = true;&#125;SuperType.prototype.getSuperValue = function() &#123; return this.property;&#125;;function SubType() &#123; this.subproperty = false;&#125;//继承了SuperTypeSubType.prototype = new SuperType();SubType.prototype.getSubValue = function() &#123; return this.subproperty;&#125;;var instance = new SubType();alert(instance.getSuperValue()); //true 以上代码中定义了两个类型：SuperType和SubType。实现继承的本质是重写原型对象，代之一个新类型的实例。换句话说，原来存在于SuperType的实例中的所有属性和方法，现在也存在于subType.prototype中了。而在继承了SuperType的属性和方法后，SubType用定义了新的方法。在上面的代码中，并没有使用SubType默认提供的原型，而是给它换了一个新的原型；这个新原型就是SupperType的实例。于是，新原型不仅具有作为一个SupperType的实例所拥有的全部属性和方法，而且其内部还有一个指针，指向了SupperType的原型。最终结果是这样的instance指向SubType的原型。SubType的原型有指向了SupperType的原型。getSuperValue()方法仍然还在SuperType.prototype中，但property则位于SubType.prototype中。这是因为property是一个实例属性，而getSuperValue()则是一个原型方法。 注意：instance.constructor现在指向的是SuperType,这是因为原来SubType.prototype被重写了的缘故实际上，不是SuperType的原型的constructor属性被重写了，而是SubType的原型指向了另一个对象————SuperType的原型，而这个原型对象的constructor属性指向的是SuperType原型链搜索机制当以读取模式访问一个实例属性时，首先会在实例中搜索该属性。如果没有找到该属性，则会继续搜索实例的原型。在通过原型链实现继承的情况下，搜索过程就得沿着原型链继续向上上面的例子在调用instance.getSuperValue()会经历三个搜索步骤： 搜索实例 搜索SubType.prototype; 搜索SuperType.prototype,最后一步才会找到该方法。再找不到属性或方法的情况下，搜索过程总是要一环一环地前行到原型链末端才会停下来 别忘记默认的原型事实上，前面例子中展示的原型链还少一环。我们都知道，所有的引用类型默认都继承了object，而这个继承也是通过原型链实现的。所有的函数默认的原型都是Object的实例。因此默认原型都会包含一个内部指针，指向object.prototype。这也正是所有自定义类型都会继承toString()、valueOf()等默认方法的根本原因。一句话，SubType继承了SuperType,而SuperType继承了object。当调用instance.toString()时，实际上调用的是保存在Object.prototype中的那个方法 确定原型与实例的关系可以通过两种方式来确定原型和实例间的关系。 使用instanceof操作符。只要用这个操作符来测试实例与原型链中出现过得构造函数，结果就会返回true 使用isPrototypeOf()方法。同样，只要是原型链中出现过的原型都可以说是该原型链所派生的实例的原型，]]></content>
      <categories>
        <category>前端笔记</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[target和currentTarget学习笔记]]></title>
    <url>%2F2017%2F08%2F31%2Ftarget%E5%92%8CcurrentTarget%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[target和currentTarget都是event上面的属性 currentTarget事件类型：Element表示其事件处理程序当前正在处理事件的那个元素 target事件类型：Element表示事件的目标 在事件处理程序内部，对象this始终等于currentTarget的值，而target则只包含事件的实际目标。如果直接将事件处理程序指定给了目标元素,则this、currentTarget和target包含相同的值。 例如：12345var btn = document.getElementById(&quot;myBtn&quot;);btn.onclick = function(event)&#123; console.log(event.currentTarget === this); //true console.log(event.target === this); //true&#125; 上面的例子检测了currentTarget和target与this的值。由于click事件的目标是按钮，因此这三个值是相等的。如果事件处理程序存在于按钮的父节点中(例如document.body),那么这些值是不相同的。比如下面的例子12345document.body.onclick = function(event)&#123; console.log(event.currentTarget === document.body); //true console.log(this === document.body); console.log(event.target === document.getElementById(&quot;myBtn&quot;)); //true&#125; 当点击这个例子中的按钮时，this和currentTarget都等于document.body,因为事件处理程序是注册到这个元素上的。然而,target元素却等于按钮元素，因为它是click事件的真正目标。由于按钮上没有注册事件处理程序，结果click事件就冒泡到了document.body,在那里事件才得到了处理]]></content>
      <categories>
        <category>前端笔记</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[从浏览器的URL中获取参数信息笔记]]></title>
    <url>%2F2017%2F08%2F23%2F%E4%BB%8E%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84URL%E4%B8%AD%E8%8E%B7%E5%8F%96%E5%8F%82%E6%95%B0%E4%BF%A1%E6%81%AF%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[浏览器的宿主环境中，有一个location对象，同时这个window对象和document对象的属性location对象提供了与当前窗口加载的文档有关的信息，即URL信息例如 浏览器地址栏的信息显示的是https://www.zhihu.com/search?type=content&amp;q=123#3location.href : 完整的urllocation.protocol : 返回协议(https:)location.host : 返回服务器名称和端口号(Www.zhihu.com)location.hostname : 返回服务器名称(www.zhihu.com)location.port : 返回服务器端口号(http默认80，https默认443)location.pathname : 返回URL中的目录和文件名(/search)location.search : 返回查询字符串(?type=content&amp;q=123)locatin.hash : 返回值#3]]></content>
      <categories>
        <category>前端笔记</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于Object.defineProperty方法的利用]]></title>
    <url>%2F2017%2F08%2F21%2F%E5%85%B3%E4%BA%8EObject.defineProperty%E6%96%B9%E6%B3%95%E7%9A%84%E5%88%A9%E7%94%A8%2F</url>
    <content type="text"><![CDATA[Object.defineProperty()语法：1Object.defineProperty(obj,prop,descriptor) 参数: obj:目标对象 prop:需要定义的属性或方法的名字 descriptor: 目标属性所拥有的特性 descriptor参数说明该参数有以下取值 value: 属性的值 writable: 是否可写，如果为false，属性的值就不能被重写，只能为只读 configurable: 总开关，一旦设置为false，就不能在设置它的(value , writable,configurable) enumerable: 是否能在for…in循环遍历出来或在Object.keys中列举出来 get: 获取属性值的方法 set: 设置属性值的方法 注意：当使用get和set方法，不允许使用writable和value这两个属性get和set不是必须成对出现，任意其一就可以。如果不设置方法，则get和set的默认值为undefined。configurable和enumerable一样 兼容性在ie8下只能在DOM对象上使用，尝试在原生的对象使用Object.defineProperty()会报错]]></content>
      <categories>
        <category>前端笔记</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue简介]]></title>
    <url>%2F2017%2F08%2F21%2Fvue%E7%AE%80%E4%BB%8B%2F</url>
    <content type="text"><![CDATA[vue 是不支持IE8及以下版本 definePropertygettersetter Vue是什么Vue采用自底向上增量开发的设计。Vue的核心库只关注视图层 React和Vue的相似之处 React里面有react-route Vue里面有Vue-route React里面有react-redux Vue里面有vuex 开发时构建可以支持所有的语法 运行时构建对template支持有问题，因为源码中不包含 扩展awesome-react包括react比较靠谱的各种插件awesome-vue推荐Vue比较靠谱的各种插件 开发步骤 新建项目 创建HTML文件 引入vue.js vue使用建议把script放在body上面 创建Vue组件123456789new Vue(&#123; el:&quot;#root&quot;, //模板将message里面的数据挂载在页面，react里面需要&#123;&#125;,vue里面需要&#123;&#123;&#125;&#125; template:&quot;&lt;div&gt;&#123;&#123;message&#125;&#125;&lt;/div&gt;&quot;, //data和React里面的state一样都是存储数据 data:&#123; message:&quot;hello vue!&quot; &#125;&#125;) vue里面数据放在data里，方法放在methods里 vue指令指令(Directives是带有v-前缀的特殊属性)。指令的预期值是单个JavaScript表达式。指令的职责是，当表达式的值改变时，将其产生的连带影响，响应式地作用于DOM v-bind 可以简写成(:)通过这个指令可以把vue实例里的数据绑定在dom元素的属性上，例如title 、 src v-bind:title=”message” v-if控制这个DOM元素存不存在 v-show通过show这个变量判断当前DOM元素是显示还是隐藏,通过display控制 v-for循环 v-on 简写(@)在元素上绑定事件，例如 v-on:click=”handleClick” v-model数据的双向绑定例如：1&lt;input type=&quot;text&quot; v-model=&quot;message&quot;/&gt; input的变化会使数据变化，数据的变化也会让input的数据变化，v-model实际上是一个语法糖，没有它我们一样可以实现数据双向绑定 v-html不转义文本 todolistvue里面非父子组件传值使用vuex父组件通过属性的方式向子组件传值，子组件向父组件传值，子组件需要触发一个事件，父组件监听这个事件 创建一个组件创建一个全局的组件，名字叫做todo-item123Vue.component(&quot;todo-item&quot;,&#123; template:&quot;&lt;li&gt;hello&lt;/li&gt;&quot;&#125;) vue.extend computed代表后面函数计算出来的结果computed里面的键名对应的值指的是后面的方法返回的结果computed不是计算一次就完事了，他依赖的变量一旦变化，就会重新计算computed是除非依赖的变量发生变化，才重新计算，否则使用上一次计算的缓存值 methodsmethods里面的键名对应的值指的是后面的方法methods每一次渲染的时候都会重新计算一遍 watchwatch监控变量变化的时候，监控函数里面会接收到当前变量的最新值 computed methods watch 比较性能：methods性能最低 data和computed的属性名不能重复]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ajax学习笔记]]></title>
    <url>%2F2017%2F08%2F15%2FAjax%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[AJAX是Asynchronous JavaScript And XMl(异步的JavaScript与XML技术)的缩写，让数据在后台进行异步传输。常见的使用场景：对网页的局部数据进行更新时，不需要刷新整个网页，以节省宽带资源。ajax也是黑客进行web客户端攻击常用的技术，因为这样就可以悄无声息地在浏览器后台进行，做到”杀人无形” 什么是ajax：异步的JavaScript and XML 通过ajax向服务器提交少量数据，完成页面的局部刷新(整个页面无刷新效果);优点 页面无刷新 响应速度快 用户体验好 节省带宽 缺点 ajax不支持浏览器back按钮 安全问题AJAX暴露了与服务器交互的细节 对搜索引擎的支持比较弱 破坏了程序的异常机制 不容易调试 ajax工作原理 异步：同时执行（生活中的同步）同步：按照一定的顺序来执行（顺序执行） 线程和进程程序从开始到结束的过程 称为一个进程。进程中包括多个线程，多线程是异步执行 ajax的请求方式一般用get方式1. get get从服务器获取 一般是通过地址url传值 传递量小 安全性低 post 向服务器提交数据 传递数据量大没有限制 安全性高 ajax的请求过程ajax请求过程 1. 创建ajax对象123456789var ajax = new XMLHttpRequest(); //高版本浏览器var ajax = new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;);//IE9以下//XMLHTTPRequest()有兼容兼容性写法if(window.XMLHttpRequest)&#123; ajax = new XMLHttpRequest();&#125;else&#123; ajax = new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;);&#125; 2. 建立和服务器的连接 通过open()方法实现1ajax.open(&quot;请求方式&quot;,&quot;请求的路径&quot;,ture)第三个参数ture表示异步 3. 向服务器发送请求 通过send()方法1ajax.send() 4. 服务器响应客户端的请求并将处理的结果返回到客户端12345678通过onreadystatechange事件来完成响应的过程是异步的ajax.onreadystatechange=function()&#123; //判断状态值为4并且状态码为200表示本次请求成功了 if(ajax.readyState==4&amp;&amp;ajax.status==200)&#123; console.log(ajax.responseText);//获取服务器响应数据 &#125;&#125; ajax在IE中出现的问题ie容易出现缓存问题：解决方法：路径上加一个参数 参数值保证随机路径改变 “1.txt?id=”Math.random(); “1.txt?id=”new Date().getTime();数据没有及时的更新eval()和JSON.parse()eval()转对象转json格式的字符串报错，json格式的字符串用JSON.parse ajx封装get123456789101112131415161718192021222324function getAjax(url,callback,data)&#123; var ajax; //创建ajax对象，处理兼容 if(windown.XMLHttpRequest)&#123; ajax = new XMLHTTPRequest();//高版本浏览器 &#125;else&#123; ajax = new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;);//ie9以下 &#125; if(data)&#123; //如果data参数存在，传入的url后面加上data，字符串连接 url=url+&quot;?&quot;+data; &#125; //建立与服务器建立连接 ajax.open(&quot;GET&quot;,url,ture); //向服务器发送请求 ajax.send(); //处理服务器响应客户端的请求，并将处理的结果返回客户端 ajax.onreadystatechange=function()&#123; if(ajax.readyState==4&amp;&amp;ajax.status==200)&#123; //通过回调函数的方式接受服务器处理的结果 callback(ajax.responseText); &#125; &#125;&#125; post方式123456789101112131415161718192021function postAjax(url,data,callback)&#123; var ajax; //创建ajax对象，处理兼容 if(window.XMLHttpRequest)&#123; ajax = new XMLHttpRequest();//高版本浏览器 &#125;else&#123; ajax = new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;);//ie9以下 &#125; //建立与服务器建立连接 ajax.open(&quot;POST&quot;, url); //设置请求头 ajax.setRequestHeader(&quot;Content-Type&quot;,&quot;application/x-www-form-urlencoded&quot;); ajax.send(data); //处理服务器响应客户端的请求，并将处理的结果返回客户端 ajax.onreadystatechange = function() &#123; if(ajax.readyState == 4 &amp;&amp; ajax.status == 200) &#123; //通过回调函数的方式接收服务器处理的结果 callback(ajax.responseText); &#125; &#125;&#125; ajax get方式和post方式区别： post需要在send方法之前设置文件头post send方法里面需要传入请求的数据]]></content>
      <categories>
        <category>前端笔记</category>
      </categories>
      <tags>
        <tag>Ajax</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTTP-状态码]]></title>
    <url>%2F2017%2F08%2F10%2FHTTP-%E7%8A%B6%E6%80%81%E7%A0%81%2F</url>
    <content type="text"><![CDATA[HTTP状态码被分成五大类 1. 100~199——信息性状态码表示临时响应并需要请求者继续执行操作的状态码 状态码 原因短语 含义 100 Continue (继续) 请求者应当继续提出请求。 服务器返回此代码表示已收到请求的第一部分，正在等待其余部分。 101 Switching Protocols (切换协议) 请求者已要求服务器切换协议，服务器已确认并准备切换。 2. 200~299——成功状态码表示成功处理了请求的状态码 状态码 原因短语 含义 200 OK(成功) 请求没问题，实体的主体部分包含了所请求的资源 201 Created(已创建) 请求成功并且服务器创建了新的资源 202 Accepted(已接收) 服务器已接收请求，但尚未处理 203 Non-Authoritative Information(非授权信息) 服务器已成功处理了请求，但返回的信息可能来自另一资源 204 No Content(无内容) 服务器成功处理了请求，但没有返回任何内容 205 Reset Content(重置内容) 服务器成功处理了请求，但没有返回任何内容 206 Partial Content(部分内容) 服务器成功处理了部分GET请求 3. 300~399——重定向状态码表示要完成请求，需要进一步操作。通常，这些状态码用来重定向 状态码 原因短语 含义 300 Multiple Choices（多种选择） 针对请求，服务器可执行多种操作。 服务器可根据请求者 (user agent) 选择一项操作，或提供操作列表供请求者选择。 301 Moved Permanently (永久移除) 请求的网页已永久移动到新的位置。服务器返回此响应(对GET和HEAD请求的响应)时，会自动将请求者转到新位置 302 Found(临时移动) 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。 303 See Other(查看其它位置) 请求者应当对不同的位置使用单独的GET请求来检索响应时，服务器返回此代码 304 Not Modified (未修改) 自从上次请求后，请求的网页未修改过。服务器返回此响应时，不会返回网页内容 305 Use Proxy (使用代理) 请求者只能使用代理访问请求的网页。 如果服务器返回此响应，还表示请求者应使用代理。 307 Temporary Redirect（临时重定向） 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。 4. 400~499——客户端错误状态码表示请求可能出错，妨碍了服务器的处理 状态码 原因短语 含义 400 Bad Request (请求错误) 服务器不理解请求的语法。 401 Unauthorized (未授权) 请求要求身份验证。 对于需要登录的网页，服务器可能返回此响应 402 Payment Required 状态码还未使用，保留，以作未来之用 403 Forbidden (禁止) 服务器拒绝请求 404 Not Found (未找到) 服务器找不到请求的网页 405 Method Not Allowed (方法禁用) 禁用请求中指定的方法 406 Not Acceptable (不接受) 无法使用请求的内容特性响应请求的网页。 407 Proxy Authentication Required (需要代理授权) 此状态代码与 401（未授权）类似，但指定请求者应当授权使用代理。 408 Request Timeout (请求超时) 服务器等候请求时发生超时。 409 Conflict (冲突) 服务器在完成请求时发生冲突。 服务器必须在响应中包含有关冲突的信息。 410 Gone (已删除) 如果请求的资源已永久删除，服务器就会返回此响应。 411 Length Required (需要有效长度) 服务器不接受不含有效内容长度标头字段的请求。 412 Precondition Failed (未满足前提条件) 服务器未满足请求者在请求中设置的其中一个前提条件。 413 Request Entity Too Large (请求实体过大) 服务器无法处理请求，因为请求实体过大，超出服务器的处理能力。 414 Request URL Too Long (请求的 URI 过长) 请求的 URI（通常为网址）过长，服务器无法处理 415 Unsupported Media Type (不支持的媒体类型) 请求的格式不受请求页面的支持。 416 Requested Range Not Satisfiable (请求范围不符合要求) 如果页面无法提供请求的范围，则服务器会返回此状态代码。 417 Expectation Failed (未满足期望值) 服务器未满足”期望”请求标头字段的要求 5. 500~599——服务端错误状态码表示服务器在尝试处理请求时发生内部错误。 这些错误可能是服务器本身的错误，而不是请求出错。 状态码 原因短语 含义 500 Internal Server Error (服务器内部错误) 服务器遇到错误，无法完成请求 501 Not Implemented (尚未实施) 服务器不具备完成请求的功能。 例如，服务器无法识别请求方法时可能会返回此代码。 502 Bad Gateway (错误网关) 服务器作为网关或代理，从上游服务器收到无效响应。 503 Service Unavailable (服务不可用) 服务器目前无法使用（由于超载或停机维护）。 通常，这只是暂时状态。 504 Gateway Timeout (网关超时) 服务器作为网关或代理，但是没有及时从上游服务器收到请求。 505 HTTP Version Not Supported (HTTP 版本不受支持) 服务器不支持请求中所用的 HTTP 协议版本。]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>HTTP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微信小程序开发]]></title>
    <url>%2F2017%2F08%2F09%2F%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91%2F</url>
    <content type="text"><![CDATA[今天研究了一下微信小程序使用微信小程序开发一个仿qq音乐播放器模板：WXML提供模板(template),可以在模板中定义代码片段，然后在不同的地方调用在使用模板时需要注意的几个问题例如index.wxml需要引用recommend.wxml的模板recommend.wxml代码12345&lt;template name=&quot;recommend&quot;&gt; &lt;view&gt; &#123;&#123;title&#125;&#125; &lt;/view&gt;&lt;/template&gt; 在index.wxml使用recommend模板12&lt;import src=&quot;recommend.wxml&quot; /&gt;&lt;template is=&quot;recommend&quot; data=&quot;&#123;&#123;title=&quot;title&quot;&#125;&#125;&quot; /&gt; 这里需要注意的是import和template必须紧挨着]]></content>
      <categories>
        <category>微信小程序</category>
      </categories>
      <tags>
        <tag>微信</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端优化-雅虎35条]]></title>
    <url>%2F2017%2F08%2F06%2F%E5%89%8D%E7%AB%AF%E4%BC%98%E5%8C%96-%E9%9B%85%E8%99%8E35%E6%9D%A1%2F</url>
    <content type="text"><![CDATA[1. 尽量减少HTTP请求个数合并图片(如css sprites,内置图片使用数据)、合并CSS、JS，这一点很重要，但是要考虑合并后的文件体积。 2. 使用CDN(内容分发网络)这里可以关注CDN的三类实现：镜像、高速缓存、专线，以及智能路由器和负载均衡； 3. 为文件头指定Exprice或Cache-Control，是内容具有缓存性区分静态内容和动态内容，避免以后页面访问中不必要的HTTP请求。 4. 避免空的src和href留意具有这两个属性的标签如link，script，img，iframe等； 5. 使用gzip压缩内容Gzip压缩所有可能的文件类型来减少文件体积 6.把css放到顶部实现页面有秩序地加载，这对于拥有较多内容的页面和网速较慢的用户来说更为重要，同时，HTML规范清楚指出样式表要放在包含页面的head区域内； 7. 把js放到底部HTTP/1.1规范建议，浏览器每个主机名的并行下载内容不超过两个，而问题在于脚本阻止了页面的平行下载，即便是主机名不相同 8.避免使用CSS表达式页面显示和缩放，乃至移动鼠标时，css表达式的计算频率是我们要关注的。可以考虑一次性的表达式或者使用事件句柄来代替CSS表达式。 9. 将CSS和JS放到外部文件中我们需要权衡内置代码带来的HTTP请求减少与通过使用外部文件进行缓存带来好处的折中点 10. 减少DNS查找次数我们需要权衡减少DNS查找次数和保持较高程度下并行下载两者之间的关系。 11. 精简CSS和JS目的就是减少下载的文件体积，可考虑压缩工具JSMin和YUI Compressor 12. 避免跳转为了确保“后退”按钮可以正确的使用，使用标准的3XXHTTP状态代码；同域中注意避免反斜杠”/“的跳转；跨域使用Alisa或者mod_rewirte建立CNAME(保存一个域名和另外一个域名之间关系的DNS记录) 13. 剔除重复的JS和CSS重复调用脚本，除了增加额外的HTTP请求外，多次运算也会浪费时间。在IE和Firefox中不管脚本是否可缓存，他们都存在重复运算JavaScript的问题。 14.配置ETagsEntity tags(ETags)(实体标签)是Web服务器和浏览器用于判断浏览器缓存中的内容和服务器中的原始内容是否匹配的一种机制(“实体”就是所说的”内容”，包括图片、脚本、样式表等)，是比last-modified date更加灵活的机制，单位时间内文件被修过多次，Etag可以综合Inode(文件的索引节点(inode)数)，MTime(修改时间)和Size来精准的进行判断，避开UNIX记录MTime只能精确到秒的问题。服务器集群使用，可以取后两个参数。使用ETags减少Web应用带宽和负载。 15. 使Ajax可缓存利用时间戳，更精巧的实现相应可缓存与服务器数据同步更新。 16. 尽早刷新输出缓冲尤其对于css，js文件的并行下载更有意义 17. 使用GET来完成Ajax请求当使用XMLHttpRequest时，浏览器中的POST方法是一个“两步走”的过程：首先发送文件头，然后才发送数据。在URL小于2k时使用GET获取数据时更加有意义。 18. 延迟加载确定页面运行正常后，在加载脚本来实现如拖放和动画，或者是隐藏部分的内容以及折叠内容等。 19. 预加载关注下无条件加载，有条件加载和有预期的加载 20. 减少DOM元素个数使用更适合或者在语意是更贴切的标签，要考虑大量DOM元素中循环的性能开销。 21. 根据域名划分页面内容很显然， 是最大限度地实现平行下载 22. 尽量减少iframe的个数考虑即使内容为空，加载也需要时间，会阻止页面加载，没有语意，注意iframe相对于其他DOM元素高出1-2个数量级的开销，它会在典型方式下阻塞onload事件，IE和Firefox中主页面样式表会阻塞它的下载。 23. 避免404HTTP请求时间消耗是很大的，有些站点把404错误响应页面改为“你是不是要找*”，这虽然改进了用户体验但是同样也会浪费服务器资源（如数据库等）。最糟糕的情况是指向外部 JavaScript的链接出现问题并返回404代码。首先，这种加载会破坏并行加载；其次浏览器会把试图在返回的404响应内容中找到可能有用的部分当作JavaScript代码来执行。 24. 减少Cookie的大小去除不必要的coockie使coockie体积尽量小以减少对用户响应的影响注意在适应级别的域名上设置coockie以便使子域名不受影响设置合理的过期时间。较早地Expire时间和不要过早去清除coockie，都会改善用户的响应时间。 25. 使用无cookie的域确定对于静态内容的请求是无coockie的请求。创建一个子域名并用他来存放所有静态内容。 26. 减少DOM访问缓存已经访问过的有关元素线下更新完节点之后再将它们添加到文档树中避免使用JavaScript来修改页面布局 27. 开发智能事件处理程序有时候我们会感觉到页面反应迟钝，这是因为DOM树元素中附加了过多的事件句柄并且些事件句病被频繁地触发。这就是为什么说使用event delegation（事件代理）是一种好方法了。如果你在一个div中有10个按钮，你只需要在div上附加一次事件句柄就可以了，而不用去为每一个按 钮增加一个句柄。事件冒泡时你可以捕捉到事件并判断出是哪个事件发出的。你同样也不用为了操作DOM树而等待onload事件的发生。你需要做的就是等待树结构中你要访问的元素出现。你也不用等待所有图像都加载完毕。你可能会希望用DOMContentLoaded事件来代替 事件应用程序中的onAvailable方法。 28. 用代替@import在IE中，页面底部@import和使用作用是一样的，因此最好不要使用它。 29. 避免使用滤镜完全避免使用AlphaImageLoader的最好方法就是使用PNG8格式来代替，这种格式能在IE中很好地工作。如果你确实需要使用 AlphaImageLoader，请使用下划线_filter又使之对IE7以上版本的用户无效。 30. 优化图像尝试把GIF格式转换成PNG格式，看看是否节省空间。在所有的PNG图片上运行pngcrush（或者其它PNG优化工具） 31. 优化CSS Spirite在Spirite中水平排列你的图片，垂直排列会稍稍增加文件大小；Spirite中把颜色较近的组合在一起可以降低颜色数，理想状况是低于256色以便适用PNG8格式；便于移动，不要在Spirite的图像中间留有较大空隙。这虽然不大会增加文件大小但对于用户代理来说它需要更少的内存来把图片解压为像素地图。 100×100的图片为1万像素，而1000×1000就是100万像素。 32. 不要在HTML中缩放图像——须权衡不要为了在HTML中设置长宽而使用比实际需要大的图片。如果你需要：1&lt;img width=”100″ height=”100″ src=”mycat.jpg” alt=”My Cat” /&gt; 那么你的图片（mycat.jpg）就应该是100×100像素而不是把一个500×500像素的图片缩小使用。这里在下文有更有趣的分析。 33. favicon.ico要小而且可缓存favicon.ico是位于服务器根目录下的一个图片文件。它是必定存在的，因为即使你不关心它是否有用，浏览器也会对它发出请求，因此最好不要返回一 个404 Not Found的响应。由于是在同一台服务器上，它每被请求一次coockie就会被发送一次。这个图片文件还会影响下载顺序，例如在IE中当你在 onload中请求额外的文件时，favicon会在这些额外内容被加载前下载。因此，为了减少favicon.ico带来的弊端，要做到：文件尽量地小，最好小于1K在适当的时候（也就是你不要打算再换favicon.ico的时候，因为更换新文件时不能对它进行重命名）为它设置Expires文件头。你可以很安全地 把Expires文件头设置为未来的几个月。你可以通过核对当前favicon.ico的上次编辑时间来作出判断。Imagemagick可以帮你创建小巧的favicon。 34. 保持单个内容小于25K因为iPhone不能缓存大于25K的文件。注意这里指的是解压缩后的大小。由于单纯gizp压缩可能达不要求，因此精简文件就显得十分重 要。 35. 打包组件成复合文本页面内容打包成复合文本就如同带有多附件的Email，它能够使你在一个HTTP请求中取得多个组件（切记：HTTP请求是很奢侈的）。当你使用这条规 则时，首先要确定用户代理是否支持（iPhone就不支持）。]]></content>
      <categories>
        <category>前端笔记</category>
      </categories>
      <tags>
        <tag>性能优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JSX简介]]></title>
    <url>%2F2017%2F08%2F05%2FJSX%E7%AE%80%E4%BB%8B%2F</url>
    <content type="text"><![CDATA[JSX简介JSX(JavaScript XML)是js内定义的一套XML语法，可以解析出目标js代码，颠覆传统js写法。实质上HTML也是XML协议，有由浏览器解析，而JSX是由js解析。当然也可以通过构建工具解析生成，如grunt、webpack，这样可以减少代码这行中js解析JSX的时间。JSX原本是使用官方自己提供的方法处理，React JS和React Native已经全部采用第三方Babel的JSX编译器实现。 基本语法JSX必须严格闭合。12345//错误&lt;div&gt;//正确&lt;div/&gt;&lt;div&gt;&lt;/div&gt; 可以把JSX标签当做一个变量，可以在任何位置使用和使用变量装起来。12var div = &lt;div&gt;123&lt;/div&gt;ReactDom.render(div) JSX一个标签就是一个组件，当存在两个组件在同一级时，必须使用一个标签(组件)包起来错误的写法：12&lt;div&gt;&lt;/div&gt;&lt;div&gt;&lt;/div&gt; 正确的写法1234&lt;div&gt; &lt;div&gt;&lt;/div&gt; &lt;div&gt;&lt;/div&gt;&lt;/div&gt; 自定义组件使用必须首字母大写，首字母不大写直接解析为同名HTML标签123&lt;Test /&gt;//自定义&lt;div&gt;&lt;/div&gt;//直接解析为&lt;div&gt;&lt;/div&gt;&lt;test /&gt;//直接解析为&lt;test&gt;&lt;/test&gt;,在浏览器是不识别的，无法显示 JSX使用JavaScript上面代码体现了JSX的基本语法规则：遇到HTML标签(以&lt;开头)，就用HTML规则解析；遇到代码块(以{开头},就用JavaScript规则解析。不是什么JavaScript语法都可以用的)，想if语句就不可以用，下面列举一些用法 在JSX中使用变量12var name = &quot;test&quot;;&lt;div&gt;&#123;name+&quot;666&quot;&#125;&lt;/div&gt; 在JSX中使用Array(特殊变量)这个方式，很方便12345678var arr = [ &lt;h1&gt;Hello world!&lt;/h1&gt;, &lt;h2&gt;React is awesome&lt;/h2&gt;];ReactDom.render( &lt;div&gt;&lt;/div&gt;, document.getElementById(&apos;example&apos;)) 在JSX中使用函数因为上面可以直接使用数组，就方便了下面map方法的使用。其实就是相当于函数返回了一个结果，这个结果没有绑在变量上，直接使用了。12345678var name = [&quot;Alice&quot;,&quot;Emily&quot;,&quot;Kate&quot;];&lt;div&gt; &#123; names.map(function(value,key)&#123; return &lt;div&gt;Hello,&#123;name&#125;!&lt;/div&gt; &#125;) &#125;&lt;/div&gt; 条件判断直接使用if语句目前是不支持的。1&lt;div className=&#123;if(isComplete)&#123;&apos;is-complete&apos;&#125;&#125;&gt;&lt;/div&gt; 而解决方法是使用一下方法： 使用三目运算符 1&lt;div className=&#123;this.state.isComplete?&apos;is-complete&apos;:&apos;&apos;&#125;&gt;&lt;/div&gt; 设置一个变量并在属性中引用它 将逻辑转化到函数中 使用&amp;&amp;运算符1&lt;div className=&#123;this.state.isComplete&amp;&amp;&apos;is-complete&apos;&#125;&gt;&lt;/div&gt; 在JSX中使用…操作符…操作符是ES6新语法，JSX使用了它的特点，但并不是真正的ES6语法。1234var props = &#123;&#125;;props.foo = x;props.bar = y;var component = &lt;Component &#123;...props&#125; /&gt;; 相当于1var component = &lt;Component foo=&#123;props.foo&#125; bar=&#123;props.bar&#125; /&gt;; 如果override，该怎么做呢?很简单：12var component = &lt;Component &#123;...props&#125; foo=&quot;override&quot; /&gt;console.log(this.props.foo)//输出override JSX注释JSX的注释，下面的注释是错误的，只要把JSX关键部分注释是没有效果的。12//&lt;div&gt;&lt;/div&gt;&lt;div&gt;//&lt;/div&gt; 下面有两种方式可以生效 括号注释，跟JavaScript差不多 123456&lt;div&gt; &#123; /*sdw */ &#125;&lt;/div&gt; 内嵌属性注释 12345678&lt;input /* 多行注释 */ name=&quot;email&quot; /&gt; &lt;input name=&quot;email //单行注释 placeholder=&quot;ddd&quot; /&gt; 所以像注释某个或多个JSX整个标签，要在花括号中注释1234&#123; //必须有空字符串，要不会包含错误语法 //&lt;div&gt;dewdwqe&lt;/div&gt;&#125; JSX优点和特点 更加熟悉，语法跟HTML非常相似(90以上相似度) 更加语义化，允许自定义标签及组件。 更加直观，标签处理方式，更加可读。 抽象化，React的升级，不需要改动任何JSX代码 关注点分离，模块化，JSX以干净且简洁的方式保证了组件中标签与所有业务逻辑的相互分离 JSX与HTML有何不同JSX跟HTML很像，但却不是HTML语法的完美复制。实际上，JSX规范中这样声明：这个规范（JSX）并不尝试去遵循任何XML或HTML规范。JSX是作为一种ECMAScript特性来设计的，至于大家觉得JSX像XML这一事实，那仅仅是因为大家比较熟悉XML。下面我们探索下JSX与HTML语法上的几点关键区别。 JSX可以使用变量属性首先看看HTML的例子JSX以同样的方式实现了属性的设置，同时还提供了将属性设置为动态JavaScript变量的便利。要设置动态属性，你只需要包原本的引号括起来的文本替换为花括号包囊的JavaScript变量或函数。看例子： 123456var id = this.props.id;function getId()&#123; return &quot;test&quot;;&#125;&lt;div id=&#123;id&#125; &gt;&lt;/div&gt;//变量&lt;div id=&#123;this.getId()&#125; &gt;&lt;/div&gt;//函数也可以 其中使用到HTML的class在JSX中是className 12//在js中写css属性当然要遵守语法，就像写js对象一样。&lt;div className=&quot;test&quot;&gt;&lt;/div&gt; 事件要使用驼峰式写法。 123456789var add = funtion()&#123;&#125;&lt;div className=&quot;test&quot; onClick=&#123;add&#125; style=&#123;style&#125;&gt;&lt;/div&gt;sytle的css属性要使用驼峰式写法。//在js中写css属性当然要遵守语法，就像写js对象一样。var style= &#123; fontSize: 13, bold: normal,&#125;&lt;div style=&#123;style&#125;&gt;&lt;/div&gt; 非DOM属性下面的特殊属性是JSX中存在 key ref dangerouslySetInnerHTML]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
        <tag>JSX</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jQuery-$.ready()实现原理]]></title>
    <url>%2F2017%2F08%2F02%2FjQuery-%24.ready()%E5%8E%9F%E7%90%86%E4%B8%8E%E7%94%A8%E6%B3%95%2F</url>
    <content type="text"><![CDATA[要了解$.ready()的实现，先要了解浏览器加载页面的顺序 解析HTML结构 加载外部脚本和样式表文件 解析并执行脚本代码 构造HTML DOM模型==ready() 加载图片等组件 页面加载完毕==onload() ready事件是在DOM模型构造完毕时触发load事件是在页面加载完毕后触发实现原理：在jquery脚本加载的时候，会设置一个isReady的标记，监听DOMContentLoaded事件（这个不是什么浏览器都有的，不同浏览器，jQuery运作方式不一样），当遇到调用ready函数的时候，如果isReady未被设置，那就是说页面未加载，就会把要执行的函数用一个数组缓存起来，当页面加载完后，再把缓存的函数一一执行 完整的代码在 jQuery 中完整的代码如下所示。位于 jQuery 1.8.3 源代码的 #842 行。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657jQuery.ready.promise = function( obj ) &#123; if ( !readyList ) &#123; readyList = jQuery.Deferred(); // Catch cases where $(document).ready() is called after the browser event has already occurred. // we once tried to use readyState &quot;interactive&quot; here, but it caused issues like the one // discovered by ChrisS here: http://bugs.jquery.com/ticket/12282#comment:15 if ( document.readyState === &quot;complete&quot; ) &#123; // Handle it asynchronously to allow scripts the opportunity to delay ready setTimeout( jQuery.ready, 1 ); // Standards-based browsers support DOMContentLoaded &#125; else if ( document.addEventListener ) &#123; // Use the handy event callback document.addEventListener( &quot;DOMContentLoaded&quot;, DOMContentLoaded, false ); // A fallback to window.onload, that will always work window.addEventListener( &quot;load&quot;, jQuery.ready, false ); // If IE event model is used &#125; else &#123; // Ensure firing before onload, maybe late but safe also for iframes document.attachEvent( &quot;onreadystatechange&quot;, DOMContentLoaded ); // A fallback to window.onload, that will always work window.attachEvent( &quot;onload&quot;, jQuery.ready ); // If IE and not a frame // continually check to see if the document is ready var top = false; try &#123; top = window.frameElement == null &amp;&amp; document.documentElement; &#125; catch(e) &#123;&#125; if ( top &amp;&amp; top.doScroll ) &#123; (function doScrollCheck() &#123; if ( !jQuery.isReady ) &#123; try &#123; // Use the trick by Diego Perini // http://javascript.nwbox.com/IEContentLoaded/ top.doScroll(&quot;left&quot;); &#125; catch(e) &#123; return setTimeout( doScrollCheck, 50 ); &#125; // and execute any waiting functions jQuery.ready(); &#125; &#125;)(); &#125; &#125; &#125; return readyList.promise( obj );&#125;; 调用ready函数123456ready: function( fn ) &#123; // Add the callback jQuery.ready.promise().done( fn ); return this;&#125;]]></content>
      <categories>
        <category>前端笔记</category>
      </categories>
      <tags>
        <tag>jQuery</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jQuery.extend()和jQuery.fn.extend()]]></title>
    <url>%2F2017%2F08%2F01%2FjQuery.extend%E5%92%8CjQuery.fn.extend%2F</url>
    <content type="text"><![CDATA[jQuery.extend()、jQuery.fn.extend()1. 定义方法jQuery.extend()和jQuery.fn.extend()用于合并两个或多个对象的属性到第一个对象。 2.语法 jQuery.extend([deep],target,object1[,objectN]) jQuery.fn.extend([deep],target,object1[,objectN])其中，参数deep是可选的布尔值，表示是否进行深度合并(即递归合并)。合并行为默认是不递归的，如果第一个参数的属性本身是一个对象或数组，他会被第二个或后面的其他参数的同名属性完全覆盖。如果为true，表示进行深度合并，合并过程是递归的。参数target是目标对象；参数Object1和objectN是源对象，包含了待合并的属性。如果提供了两个或者多个对象，所有源对象的属性将会合并到目标对象；如果仅提供一个对象，意味着参数target被忽略，jQuery或jQuery.fn被当做目标对象，通过这种方式可以在jQuery或jQuery.fn上添加新的属性和方法，jQuery的其他模块大都是这么实现的。方法jQuery.extend()和jQuery.fn.extend()常用于编写插件和处理函数的参数。 3. 源码分析方法jQuery.extend()和jQuery.fn.extend()执行的关键步骤如下所示： 1.修正参数deep、target、源对象的起始下标。2.逐个遍历源对象： 遍历源对象的属性 覆盖目标对象的同名属性；如果是深度合并，则先递归调用jQuery.extend() 下面分析方法jQuery.extend()和jQuery.fn.extend()相关代码如下所示：定义jQuery.extend()和jQuery.fn.extend()1jQuery.extend = jQuery.fn.extend = function() &#123; 因为参数的个数是不确定的，可以有任意多个，所以没有列出可接受的参数定义局部变量12345var options, name, src, copy, copyIsArray, clone,truetarget = arguments[ 0 ] || &#123;&#125;,truei = 1,truelength = arguments.length,truedeep = false; 定义一组局部变量，他们的含义和用途如下： 变量options:指向某个源对象 变量name:表示某个源对象的某个属性名。 变量src:表示目标对象的某个属性的原始值 变量copy:表示某个源对象的某个属性的值 变量copyIsArray：指示变量copy是否是数组 变量clone:表示深度复制时原始值的修正值 变量target:指向目标对象 变量i:表示源对象的起始下标 变量length:表示参数的个数，用于修正变量的target。 变量deep：指示是否执行深度复制，默认为false。 3.修正目标对象target、源对象起始下标i12345678// Handle a deep copy situationif ( typeof target === &quot;boolean&quot; ) &#123;truedeep = target;true// Skip the boolean and the targettruetarget = arguments[ i ] || &#123;&#125;;truei++;&#125; 上面代码:如果第一个参数是布尔值，则修正第一个参数为deep，修正第二个参数为目标对象target，并且期望源对象从第三个元素开始。变量i的初始值为1，表示期望源对象从第二个元素开始；当第一个参数为布尔值时，变量i变为2，表示期望值源对象从第三个元素开始。1234// Handle case when target is a string or something (possible in deep copy)trueif ( typeof target !== &quot;object&quot; &amp;&amp; !jQuery.isFunction( target ) ) &#123;truetruetarget = &#123;&#125;;true&#125; 如果目标对象target不是对象，不是函数，而是一个字符串或其他的基本类型，则统一替换为空对象{},因为在基本类型上设置非原生属性是无效的12345// Extend jQuery itself if only one argument is passedif ( i === length ) &#123;truetarget = this;truei--;&#125; 变量i表示源对象开始的下标，变量length表示参数个数，如果二者相等，表示期望的源对象没有传入，则把jQuery或jQuery.fn作为目标对象，并且把源对象的开始下标减一，从而使得传入的对象被当做源对象。变量length等于i可能有两种情况 1. extend(object),只传入了一个参数 2. extend(deep,object),传入了两个参数，第一个参数是布尔值 4.逐个遍历源对象 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364truefor ( ; i &lt; length; i++ ) &#123; //循环变量i表示源对象开始的下标，和巧妙的用法truetrue// Only deal with non-null/undefined values //遍历源对象的属性truetrueif ( ( options = arguments[ i ] ) != null ) &#123; /**arguments是一个类似数组的对象，包含了传入的参数，可以通过整型下标访问指定位置的参数。 这行代码把获取源对象和对源对象的判断合并为一条语句，只有源对象不是null、undefined时才会继续执行。 **/ // Extend the base objecttruetruetruefor ( name in options ) &#123; //开始遍历单个源对象的属性 //覆盖目标对象的同名属性truetruetruetruesrc = target[ name ];truetruetruetruecopy = options[ name ];truetruetruetrue// Prevent never-ending looptruetruetruetrueif ( target === copy ) &#123;truetruetruetruetruecontinue;truetruetruetrue&#125; /** 变量src是原始值，变量copy是复制值。 如果复制值copy与目标对象target相等， 为了避免深度遍历时死循环，因此不会覆盖目标对象的同名属性。 如果注释掉上面的continue,下面的代码会抛出堆栈溢出异常 Uncaught:RangeError:Maxinum call stack size exceede 注意，判断target===copy时使用的是&quot;====&quot;,强制不做类型转换； 如果使用&quot;==&quot;则可能因自动类型转换而导致错误 **/truetruetruetrue// Recurse if we&apos;re merging plain objects or arraystruetruetruetrueif ( deep &amp;&amp; copy &amp;&amp; ( jQuery.isPlainObject( copy ) ||truetruetruetruetrue( copyIsArray = Array.isArray( copy ) ) ) ) &#123;truetruetruetruetrueif ( copyIsArray ) &#123;truetruetruetruetruetruecopyIsArray = false;truetruetruetruetruetrueclone = src &amp;&amp; Array.isArray( src ) ? src : [];truetruetruetruetrue&#125; else &#123;truetruetruetruetruetrueclone = src &amp;&amp; jQuery.isPlainObject( src ) ? src : &#123;&#125;; truetruetruetruetrue&#125; /**复制值是数组时，如果原始src不是数组，则修正为空数组； 复制copy是普通JavaScript对象时，如果原始src不是普通JavaScript对象，则修正为空对象&#123;&#125;。 把原始src或修正后的值赋值给原始值副本clone。 通过调用方法jQuery.isPlainObject( copy )判断复制copy是否是“纯粹”的JavaScript对象， 只有通过对象直接量&#123;&#125;或new Object()创建的对象，才会返回true **/truetruetruetruetrue// Never move original objects, clone themtruetruetruetruetruetarget[ name ] = jQuery.extend( deep, clone, copy //先把复制值copy递归合并到原始值副本clone中，然后覆盖目标对象的同名属性 /** 如果是深度合并，并且复制copy是普通JavaScript对象或数组，则递归合并 **/truetruetruetrue// Don&apos;t bring in undefined valuestruetruetruetrue&#125; else if ( copy !== undefined ) &#123;truetruetruetruetruetarget[ name ] = copy;truetruetruetrue&#125; /**如果不是深度合并，并且复制值copy不是undefined，则直接覆盖目标对象的同名属性**/truetruetrue&#125;truetrue&#125;true&#125;true// Return the modified objecttruereturn target;&#125;;]]></content>
      <categories>
        <category>前端笔记</category>
      </categories>
      <tags>
        <tag>jQuery</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Promise]]></title>
    <url>%2F2017%2F07%2F31%2FPromise%2F</url>
    <content type="text"><![CDATA[Promise对象是一种异步编程的解决方案，比传统的解决方案——回调函数和事件——更合理和强大。Promise有三种状态：Pending(进行中)，Resolved(Fulfilled,已完成)和Rejected(已失败)；而且状态一旦改变了，就不会发生改变，Promise从对象的状态只有两种可能：从Pending变为Resolved和Pending变为Rejected。只要这两种情况发生了，状态就凝固了，不会再变了。Promise有一些缺点，就是无法取消，一旦创建它就会执行，无法中途取消；其次如果不设置回调函数，Promise内部抛出的错误，不会反应到外部；第三Pending状态时，无法得知目前进展到哪一个阶段。 基本用法Promise构造函数接收一个函数作为参数，该参数分别是resolve和reject方法。如果成功，则用resolve将Promise的状态改为成功，即从Pending变为resolved;如果异步失败，则从Pending改为rejected。 基本用法123456789101112var promise = new Promise(function(resolve,reject)&#123; if(/*异步操作成功*/)&#123; resolve(value); &#125;else&#123; reject(error); &#125;&#125;);promise.then(function(value)&#123; //success&#125;,function(value)&#123; //failure&#125;); 一个简单的例子12345678function timeout(ms)&#123; return new Promise((resolve)+&gt;&#123; setTimeout(resolve,ms); &#125;);&#125;timeout(1000).then(()=&gt;&#123; console.log(&quot;done&quot;);&#125;) 如果用Promise对象实现Ajax操作1234567891011121314151617181920212223242526var getJSON = function(url)&#123; var promise = new Promise(function(resolve, reject)&#123; var client = new XMLHttpRequest(); client.open(&quot;GET&quot;, url); client.onreadystatechange = handler; client.responseType = &quot;json&quot;; client.setRequestHeader(&quot;Accept&quot;, &quot;application/json&quot;); client.send(); function handler()&#123; if(this.status == 200)&#123; resolve(this.response); &#125;else &#123; reject(new Error(this.statusText)); &#125; &#125; return promise; &#125;)&#125;getJSON(&quot;/posts.json&quot;).then(function(json)&#123; console.log(&quot;Contents:&quot; + json);&#125;, function(error)&#123; console.error(&apos;出错了&apos;, error);&#125;) 在resolve的方法参数除了正常值以为，还可以能是另一个Promise实例。 Promise的链式操作：Promise.prototype.thenPromise.prototype.then返回的是一个新的Promise对象，因此可以写成链式的。12345getJSON(&quot;/posts.json&quot;).then(function(json)&#123; return json.post;&#125;).then(function()&#123; //proceed&#125;) 上面的代码指定了两个回调函数，第一个回调函数完成以后，会将结果作为参数传入到第二个回调函数。如果第一个回调函数返回的是Promise对象，这样后一个函数调用就将等待该Promise对象有了运行结果，才会进一步调用。12345getJSON(&quot;/post/1.json&quot;).then(function(post)&#123; return getJSON(post.commentURL);&#125;).then(function(comments)&#123; //对comments进行处理&#125;) 捕捉错误：Promise.prototype.catch方法1Promise.prototype.catch其实是对Promise.prototype.then(null, rejection)的调用，用于指定发生错误时的回调函数。 Promise.prototype.catch 对错误具有“冒泡”性质，会一直向后传递，直到被捕获，也就是错我总是被下一个catch语句捕获。1234567getJSON(&quot;/post/1.json&quot;).then(function(post) &#123; return getJSON(post.commentURL);&#125;).then(function(comments) &#123; // some code&#125;).catch(function(error) &#123; // 处理前两个回调函数的错误&#125;); Promise.all方法var p = Promise.all([p1,p2,p3]); 这个方法接受一个数组作为参数,p1,p2,p3都是Promise对象的实例。p的最终状态取决于参数对象数组的状态，上例中就是p1,p2,p3来决定的。如果这三个都是fulfilled,那么p的状态就是fulfilled;如果p1,p2,p3中有一个是rejected,p的状态就是rejected.那么p的状态就是reject，会传递给p的回调函数。 12345678910// 生成一个Promise对象的数组var promises = [2, 3, 5, 7, 11, 13].map(function(id)&#123; return getJSON(&quot;/post/&quot; + id + &quot;.json&quot;);&#125;);Promise.all(promises).then(function(posts) &#123; // ... &#125;).catch(function(reason)&#123; // ...&#125;); Promise.resolve方法，Promise.reject方法将现有对象转我Promise对象，Promise.resolve方法就起到这个作用。1var jsPromise = Promise.resolve($.ajax(&apos;/whatever.json&apos;)); 上面jQuery生成defferred对象，转为一个新的ES6的Promise对象。如果Promise.resolve方法的参数，不具有then方法的对象（又称thenable对象），则返回一个新的Promise对象，且他的状态为fulfilled.12345var p = Promise.resolve(&apos;Hello&apos;);p.then(function(s)&#123; console.log(s)&#125;)//Hello 上面生成一个新的Promise对象的实例p，它的状态为fulfilled。Promise.reject(reason)方法也会返回一个新的Promise实例，该实例的状态为rejected，Promise.reject方法的参数reason,会被传递给实例的回调函数。 async函数async函数是用来取代回调函数的另一种方法。只要函数之前加上async的关键字，就表明该函数内部有异步操作。该异步操作返回一个Promise对象，前面用await关键字注明。当函数执行的时候，一旦遇到await就立马返回，等接触到异步操作完成，再接着执行函数体内后面的语句。1234async function getStockPrice(symbol, currency) &#123; let price = await getStockPrice(symbol); return convert(price, currency);&#125; 函数前面加了一个async表明该函数将返回一个Promise对象，调用该函数时，遇到await关键字，立刻返回后面的表达式产生的Promise对象，不再执行函数体后面的语句。等getStockPrice完成，在自动回到函数体内，执行剩下的语句。12345678910function timeout(ms) &#123; return new Promise((resolve) =&gt; &#123; setTimeout(resolve, ms); &#125;);&#125;async function asyncValue(value) &#123; await timeout(50); return value;&#125; 上面代码中，asyncValue函数前面有async关键字，表明函数体内有异步操作。执行的时候，遇到await语句就会先返回，等到timeout函数执行完毕，再返回value。]]></content>
      <categories>
        <category>前端笔记</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jQuery-$.proxy()原理与用法]]></title>
    <url>%2F2017%2F07%2F31%2FJQuery-proxy-%E5%8E%9F%E7%90%86%E4%B8%8E%E7%94%A8%E6%B3%95%2F</url>
    <content type="text"><![CDATA[再写一些jQuery插件时，往往需要在回调函数上下文中注入调用者对象，也就是改变函数上下文中this的引用 从jQuery1.4开始便可以使用jQuery.proxy方法解决这个问题 定义和用法$.proxy方法接收一个已有的函数，并返回一个带特定上下文的新的函数。该方法通常用于向上下文指向不同对象的元素添加事件。 两种用法 jQuery.proxy(function,context) 参数function是将被改变上下文的函数，参数context是上下文。指定参数function的上下文始终为参数content。 jQuery.proxy(context,name) 参数name是参数context的属性。指定参数name对应的函数上下文始终为参数context。jQuery.proxy方法的相关代码如下：123456789101112131415161718192021222324proxy: function( fn, context ) &#123; var tmp, args, proxy; if ( typeof context === &quot;string&quot; ) &#123; tmp = fn[ context ]; context = fn; fn = tmp; &#125; // Quick check to determine if target is callable, in the spec // this throws a TypeError, but we will just return undefined. if ( !jQuery.isFunction( fn ) ) &#123; return undefined; &#125; // Simulated bind args = core_slice.call( arguments, 2 ); proxy = function() &#123; return fn.apply( context, args.concat( core_slice.call( arguments ) ) ); &#125;; // Set the guid of unique handler to the same of original handler, so it can be removed proxy.guid = fn.guid = fn.guid || jQuery.guid++; return proxy;&#125;,]]></content>
      <categories>
        <category>前端笔记</category>
      </categories>
      <tags>
        <tag>jQuery</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React简介]]></title>
    <url>%2F2017%2F07%2F29%2Freact%2F</url>
    <content type="text"><![CDATA[react Native React简介特点： 声明式设计 -React采用声明式，可以轻松描述应用。声明式是告诉计算机要去做什么而不管怎么做，而命令式是要描述如何去做。 高效 -React通过对DOM的模拟(虚拟DOM)，最大限度地减少与DOM的交互。 灵活 -React可以与已知的库或框架很好地配合。 JSX -JSX是JavaScript语法的扩展。(对比模板引擎) 组件 -通过React构建组件，使得代码更加容易得到复用，能够很好的应用在大项目的开发中 单向响应的数据流 -React实现了单向响应的数据流，这也是它为什么比传统的数据绑定更简单。 环境搭建使用webpack搭建React开发环境常用命令：打包：webpack启动测试服务器：webpack-dev-server 安装webpacknpm install webpack –dev–save 安装webpack-dev-servernpm install webpack-dev-server –dev–save webpack打包的入口文件是root.js 打包完成后生成build文件夹生成app.js babel 是把ES6转成ES5的代码,目的是让代码能够在浏览器运行，但是随着时间的发展babel不仅可以处理ES6的转码还可以处理其他的一些转码，比如在react里面有自己的一套语法，浏览器是不认得，babel可以把它转化成浏览器认的。 使用了babel等一些loader,需要用npm安装这些loader webpack-plugin有点类似钩子 HtmlWebpackPlugin这个插件帮助我们在打包生成builder文件夹下自动生成一个html文件并把打包生成好的app.js引入到里面 安装HtmlWebpackPlugin inline:true HRM(Hot Moudule Replacement)热模块替换，配置热模块加载的 MVVM的框架都是由数据驱动的JSX中使用js要用{}getIntialState是react组建中非常重要的点state用来存储组件内的数据 React组件拆分父组件向子组件传值通过属性传，子组件通过props获得父组件传过来的值子组件向父组件传值，执行父组件传过来的方法 React创建组件三种方式 ES5原生方式 React.createClass定义的组件React.createClass是react刚开始推荐创建组件的方式，这是ES5 的原生的JavaScript来实现的React组件，其形式如下：12345678910111213141516171819202122232425262728293031323334353637var InputControlES5 = React.createClass(&#123; propTypes:&#123; //定义传入的props中的属性各种类型 initialValue:React.PropTypes.string &#125;, defaultProps:&#123; //组件默认的props对象 initialValue:&quot;&quot; &#125;, //设置initial state getIntialState:function()&#123; //组件相关的状态对象 return &#123; text:this.props.initialValue||&apos;placeholder&apos; &#125;; &#125;, handleChange:function(e)&#123; this.setState(&#123; //this represents react component instance text:e.target.value &#125;); &#125;, render:function()&#123; return( &lt;div&gt; Type someting:&lt;input onChange=&#123;this.handleChange&#125; value=&#123;this.state.text&#125; /&gt; &lt;/div&gt; ) &#125;&#125;);InputControlES5.propTypes = &#123; initialValue:React.PropTypes.string&#125;;InputControlES5.defaultProps = &#123; initialValue:&apos;&apos;&#125; 与无状态组件相比，React.createClass和后面要描述的React.Component都是创建有状态的组件，这些组件都是要被实例化的，并且可以访问组件的生命周期方法。但是随着React的发展，React.createClass形式自身的问题暴露出来：React.createClass会自绑定函数方法(不像React.Component只绑定需要关心的函数)导致不必要的性能开销，增加代码过时的可能性。React.createClass的mixins不够自然、直观;React.Component形式非常适合高阶组件(Higher Order Components-HOC),它以更直观的形式展示了比mixins更强大的功能，并且HOC是纯净的JavaScript，不用担心会被废弃。H ES6形式的extends React.Component定义的组件 React.Component是以ES6的形式来创建react的组件的，是React目前极为推荐的创建有状态组件的方式，最终会取代React.createClass形式；相对于 React.createClass可以更好实现代码复用。将上面React.createClass的形式改为React.Component形式如下：1234567891011121314151617181920212223242526272829303132333435class InputControlES6 extends React.Component&#123; constructor(props) &#123; super(props); // 设置 initial state this.state = &#123; text: props.initialValue || &apos;placeholder&apos; &#125;; // ES6 类中函数必须手动绑定 this.handleChange = this.handleChange.bind(this); &#125; handleChange(event) &#123; this.setState(&#123; text: event.target.value &#125;); &#125; render() &#123; return ( &lt;div&gt; Type something:&lt;input onChange=&#123;this.handleChange&#125; value=&#123;this.state.text&#125;/&gt; &lt;/div&gt; ); &#125;&#125;InputControlES6.propTypes = &#123; initialValue: React.PropTypes.string&#125;;InputControlES6.defaultProps = &#123; initialValue: &apos;&apos;&#125;; 函数式定义的无状态组件创建无状态函数式组件形式是从React 0.14版本开始出现的。它是为了创建纯展示组件，这种组件只负责根据传入的props来展示，不涉及到要state状态的操作。具体的无状态函数式组件，其官方指出：在大部分React代码中，大多数组件被写成无状态的组件，通过简单组合可以构建成其他的组件等；这种通过多个简单然后合并成一个大应用的设计模式被提倡。无状态函数组件形式上表现为一个只带有一个render方法的组件类，通过函数形式或者ES6 arrow function的形式在创建，并且该组件是无state状态的。具体的创建形式如下：1234function HelloComponent(props,/*context*/)&#123; return &lt;div&gt;Hello &#123;props.name&#125;&lt;/div&gt;&#125;ReactDOM.render(&lt;HelloComponent name=&quot;Sebastian&quot; /&gt;,montNode); 无状态组件的创建形式使代码的可读性更好，并且减少了大量冗余的代码，精简至只有一个render方法，大大的增强了编写一个组件的便利，无状态组件的特点： 组件不会被实例化，整体渲染性能得到提升 因为组件被精简成一个render方法的函数来实现的，由于是无状态组件。所以无状态组件就不会在有组件实例化的过程，无实例化的过程也就不需要分配多余的内存，从而性能得到一定的提升。 组件不能范文this对象 无状态组件由于没有实例化过程，所以无法访问组件this中的对象，例如：this.ref,this.state等均不能访问。若想访问就不能使用这种形式来创建组件 组件无法访问生命周期的方法因为无状态组件是不需要组件生命周期管理和状态管理，所以底层实现这种形式的组件时是不会实现组件的生命周期方法。所以无状态组件是不能参与组件的各个生命周期管理 无状态组件只能访问输入的props，同样的props会得到同样的渲染结果，不会有副作用 无状态组件被鼓励在大型项目中尽可能以简单的写法来分割原本庞大的组件，未来React也会在这种面向无状态组件在譬如无意义的检查和内存分配领域进行一系列优化，所以只要有可能，尽量使用无状态组件。 无生命周期，无this，性能优势里面没有state，只有render函数可以使用无状态组件使用方式1function(props)&#123;&#125;]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript变量赋值]]></title>
    <url>%2F2017%2F07%2F26%2FJavaScript%E5%8F%98%E9%87%8F%E8%B5%8B%E5%80%BC%2F</url>
    <content type="text"><![CDATA[JavaScript中数据类型：ECMAScript变量包含两种不同类型的值：基本数据类型和引用类型。 - 基本数据类型保存在栈内存中的简单数据段Number;String;Boolean;Undefined;Null - 引用数据类型保存在堆内存中的对象，意思是，变量中保存的实际上只是一个指针，这个指针指向内存堆中实际的值；Function;Array;Date;RegExp;Error;Map;Set…… 值和引用在将一个值赋值给变量时，解析器必须确定这个值是基本数据类型还是引用类型值如果从一个变量向另一个变量赋值基本类型的值，会在变量对象上创建一个新值，然后把该值复制到为新变量分配的位置上,例如：12345var num1=5;var num2=num1;//在此，num1中保存的值是5.当使用num1的值来初始化num2时，num2中也保存了值5。//但num2中的5与num1中的5是完全独立的，该值只是num1中5的一个副本。//此后，这两个变量可以参与任何操作而不会相互影响 当一个变量向另一个变量复制引用类型的值时，同样也会将存储在变量对象中的值复制一份放到为新变量分配的空间中。不同的是，这个值得副本实际上是一个指针，而这个指针指向存储在堆中的一个对象。复制操作结束后，两个变量实际上将引用同一个对象。因此，改变其中一个变量，就会影响另一个变量，如下面的例子所示:1234var obj1=new Object();var obj2=obj1;obj1.name=&quot;小明&quot;;console.log(obj2.name)//小明 首先，变量obj1 保存了一个对象的新实例。然后，这个值被复制到了obj2 中；换句话说，obj1和obj2 都指向同一个对象。这样，当为obj1 添加name 属性后，可以通过obj2 来访问这个属性，因为这两个变量引用的都是同一个对象。]]></content>
      <categories>
        <category>前端笔记</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javaScript设计模式-(Observer)观察者模式]]></title>
    <url>%2F2017%2F07%2F25%2FjavaScript%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-(Observer)%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[观察者模式对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被zidonggengxin。 观察者要素 抽象主题(Subject)角色：把所有对观察者对象的引用保存在一个集合中，每个抽象主题角色都可以有任意数量的观察者。抽象主题提供一个接口，可以增加和删除观察者角色。一般用一个抽象类和接口来实现。 抽象观察者(Observer)角色：为所有具体的观察者定义一个接口，在得到主题的通知时更新自己。 具体主题(ConcreteSubject)角色：在具体主题内部状态改变时，给所有登记过的观察者发出通知。具体主题角色通常用一个子类实现。 具体观察者(ConcreteObserver)角色：该角色实现抽象观察者角色所要求的更新接口，以便使本身的状态与主题的状态相协调。通常用一个子类实现。如果需要，具体观察者角色可以保存一个指向具体角色的引用。 例子模拟拥有的一系列依赖Observer1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859function ObserverList()&#123; this.observerList = [];&#125;ObserverList.prototype.Add = function(obj)&#123; return this.observerList.push(obj);&#125;;ObserverList.prototype.Remove = function(obj)&#123; return this.observerList.pop(obj);&#125;;ObserverList.prototype.Empty = function()&#123; this.observerList = [];&#125;;ObserverList.prototype.Count = function()&#123; return this.observerList.length;&#125;;ObserverList.prototype.Get = function(index)&#123; if(index &gt; -1 &amp;&amp; index &lt; this.observerList.length)&#123; return this.observerList[index]; &#125;&#125;;ObserverList.prototype.Insert = function(obj,index)&#123; var pointer = -1; if(index === 0)&#123; this.observerList.unshift(obj); pointer = index; &#125;else if(index === this.observerList.length)&#123; this.observerList.push(obj); pointer = index; &#125; return pointer;&#125;;ObserverList.prototype.IndexOf = function(obj,startIndex)&#123; var i = startIndex, pointer = -1; while(i &lt; this.observerList.length)&#123; if(this.observerList[i] === obj)&#123; pointer = i; &#125; i++; &#125; return pointer;&#125;;ObserverList.prototype.RemoveIndexAt = function(index)&#123; if(index === 0)&#123; this.observerList.shift(); &#125;else if(index === this.observerList.length - 1)&#123; this.observerList.pop(); &#125;&#125;;//使用extension扩展对象function extend(obj,extension)&#123; for(var key in obj)&#123; extension[key] = obj[key]; &#125;&#125;;var liuyidi = &#123;&#125;;var observer = new ObserverList();extend(observer,liuyidi);console.log(liuyidi); 模拟目标(Subject)和在观察者列表上添加、删除或通知观察者123456789101112131415161718function Subject()&#123; this.observers = new ObserverList();&#125;Subject.prototype.AddObserver = function(observer)&#123; this.observers.Add(observer);&#125;;Subject.prototype.RemoveObserver = function(observer)&#123; this.observers.RemoveIndexAt(this.observers.IndexOf(observer,0));&#125;;Subject.prototype.Notify = function(context)&#123; var observerCount = this.observers.Count(); for(var i = 0; i &lt; observerCount; i++)&#123; this.observers.Get(i).Update(context); &#125;&#125;; 观察者模式的优点 观察者和被观察者是抽象耦合的。 建立一套触发机制。 观察者模式缺点 如果一个被观察者对象有很多直接和间接的观察者的话，将所有的观察者都通知到会花费很多时间。 如果在观察者和观察者目标之间有循环依赖的话，观察目标会触发他们之间进行循环调用，可能导致系统崩溃。 观察模式没有相应的机制让观察者知道所观察的目标对象是怎么发生变化的，而仅仅只是知道观察目标发生了变化。 适用场景 当一个抽象模型有两个方面, 其中一个方面依赖于另一方面。将这二者封装在独立的对象中以使它们可以各自独立地改变和复用。 当对一个对象的改变需要同时改变其它对象, 而不知道具体有多少对象有待改变。 当一个对象必须通知其它对象，而它又不能假定其它对象是谁。换言之, 你不希望这些对象是紧密耦合的。]]></content>
      <categories>
        <category>前端笔记</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript设计模式--代理模式模式]]></title>
    <url>%2F2017%2F07%2F25%2FjavaScript%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[代理模式代理模式(Proxy),为其他对象提供一种代理以控制对这个对象的访问。 在现实生活中，可以找到很多代理模式使用的场景。明星都有经纪人作为代理。如果请明星来演出，就要先同他的经纪人沟通，谈好相应的细节与报酬。再交给明星。 代理模式代码实现1234567891011121314151617181920212223//演唱会var Concert=function()&#123;&#125;//公司var Company=&#123; askforconcert:function(target)&#123; var concert=new Concert(); target.openconcert(concert); &#125;&#125;//明星var star = &#123; openconcert:function(concert)&#123; console.log(&quot;明星同意开一场演唱会&quot;); &#125;&#125;//经纪人代理var agent = &#123; openconcert:function(concert)&#123; star.opentconcert(consert) &#125;&#125;//执行Company.askforconcert(agent);//明星同意开一场演唱会 这样company直接把请求发送给agent,agent在转给star,这样就完成了一个简单的代理模式(compan=&gt;agent=&gt;satr) 保护代理和虚拟代理 保护代理 经纪人可以帮助明星过滤掉一些请求，比如钱不够或者场地不够好，这种请求可以直接在经济人处被过滤拒绝掉。这种代理模式就叫做保护代理，由经纪人agent来控制对明星star的访问。 虚拟代理 如果A通过B送花给C，我们可以在A的时候new 一个 flower传递给代理B,再由B决定什么时候或者是否要在转交给最终的target C,new Flower这个操作可以交给B,B决定可以送花给C的时候再由B做new Flower的操作。这种模式就叫做虚拟代理。虚拟代理把一些开销很大的对象，延迟到真正需要他的时候才去创建1234567891011121314151617181920212223var Flower = function()&#123; this.price = 150&#125;var a = &#123; sendFlower:function(taget)&#123; var flower=new Flower(); target.recevieFlower(flower); &#125;&#125;var b = &#123; receiveFlower:function()&#123; if(flower.price&lt;100)&#123; console.log(&quot;太便宜了，嫌弃&quot;); &#125;else&#123; c.receiveFlower(flower); &#125; &#125;&#125;var c = &#123; receiveFlower:function()&#123; console.log(&quot;接受了鲜花&quot;); &#125;&#125; 实现图片预加载 不用代理模式的实现 1234567891011121314var preLoadImage = (function()&#123; var imgNode = document.createElement(&apos;img&apos;); document.body.append(imgNode); var img = new Image(); img.onload = function()&#123; imgNode.src = img.src &#125;; return &#123; setSrc:function(src)&#123; imgNode.src = &quot;loading.gif&quot;; img.src = src; &#125; &#125;&#125;)(); 使用代理模式的实现 12345678910111213141516171819202122var image = (function()&#123;var imgNode = document.createElement(&apos;img&apos;);document.body.append(imgNode);return &#123; setSrc: function(src)&#123; imgNode.src = src; &#125;&#125;&#125;)();//代理var proxyImage = (function()&#123; var img = new Image(); img.onload = function()&#123; image.setSrc = img.src; &#125; return &#123; setSrc: function(src)&#123; image.setSrc = &quot;loading.gif&quot;; img.src = src; &#125; &#125;&#125;) 单一职责原则单一职责指的是，对一个类而言，应该仅有一个引起他变化的原因。如果一个对象承担了多个原则，就意味着这个对象将变得巨大，引起他变化的原因可能也会有多个。面向对象设计鼓励将行为分不到细粒度的对象之中，如果一个对象承担的职责过多，等于把这些值得耦合到了一起，这种耦合会导致脆弱和低内聚的设计。当变化发生时，设计可能会遭到意外的破坏。 preLoadImage方法，承担了添加img标签，还有预加载两个功能，代码耦合到了一起，当我修改添加标签时，可能会影响到另一部分功能。 而用代理方法重构后，image方法只负责创建标签，设置src,预加载功能交给了proxyImage，解除了耦合的代码，两个功能互不干扰。]]></content>
      <categories>
        <category>前端笔记</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript设计模式--单例模式]]></title>
    <url>%2F2017%2F07%2F25%2FjavaScript%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[设计模式(Design Pattern)是一套被反复使用，多数人知晓的，经过分类编目的、代码设计经验总结。使用设计模式是为了可重用代码，让代码更容易被他人理解、保证代码的可靠性。 单例模式单例：对象只能实例化一次就叫单例 单例模式，字面量的对象声明，其实在设计模式中可以看做是一种单例模式 所谓单例模式，就是永远保持对象的一个实例1234567891011function Dog()&#123;&#125;var d1 = new Dog();var d2 = new Dog();alert(d1==d2);//falsefunction Cat(name)&#123; this.name =name;&#125;var c1 = new Cat(&quot;黑猫&quot;);var c2 = new Cat(&quot;白猫&quot;);alert(c1 == c2);//false 每一次都是通过new出来一个新的对象所以两个对象不相等 单例模式实现思路 将第一次new出来的对象this保存到一个变量中，返回这个变量 再次创建对象时，判断这个变量中是否含有值，如果有值，就直接将这个变量返回 如何实现单例模式，例如1234567891011function Engine()&#123; if(Engine.instance)&#123; return Engine.instance; &#125; Engine.instance = this; //instance变量中保存的是第一次new出来的对象 return Engine.instance;&#125;var e1 = new Engine();var e2 = new Engine();alert(e1 == e2); //true]]></content>
      <categories>
        <category>前端笔记</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Canvas笔记]]></title>
    <url>%2F2017%2F07%2F24%2Fcanvas%2F</url>
    <content type="text"><![CDATA[创建画布在html里面创建一个canvas标签（若浏览器不支持canvas则会显示“你的浏览器不支持canvas”）,除width和height属性外，其还支持h5的标准属性，但是canvas不是块级元素，在设置居中的时候，要么外层包一个div，要么设置body的text-align为center。123&lt;canvas id=&quot;canvas&quot; width=&quot;300&quot; height=&quot;300&quot;&gt;你的浏览器不支持canvas&lt;/canvas&gt; 获取画笔canvas是画布元素，context可以简单地理解为画笔。canvas本身是一块画布，没有画图的能力，需要使用js来画图12var canvas=document.getElementById(&quot;canvas&quot;);var context=canvas.getContext(&apos;2d&apos;); 画图步骤12345context.save();//用来保存Canvas的状态，save()方法之后的代码，可以调用canvas的平移，缩放，旋转，裁剪等操作context.beginPath();//这里面可以写要绘制的图形代码;context.closePath();context.reStore();//用来恢复canvas之前保存的状态，防止save()方法代码之后对canvas执行的操作，继续对后续的绘制产生影响，通过该方法可以避免连带的影响 canvas中的绘制方法（如stroke,fill）,都会以“上一次beginPath”之后的所有路径为基础进行绘制。 不管用moveTo把画笔移动到哪里，只要不beginPath,那你一直都在画一条路径。 fillRect与strokeRect这种直接画出独立区域的函数，也不会打断当前的path。 如果你画的图形和你想象出来的不一样，记得查看是否有合理的beginPath beginPath和closePath有联系吗？几乎没有关系，closePath的意思不是结束路径，而是关闭路径，他会试图从（MoveTo点之后）当前路径的终点连一条路径到起点，让整个路径闭合起来。但是，这并不意味着他以后的路径就是新路径了 总而言之，就是不要企图通过闭合现有路径，而开始一条新路径，而开始一条新路径，以前的路径也不会闭合 Canvas路径 绘制路径：在Canvas上画线，有以下两种方法： moveTO(x,y)定义线条开始坐标 lineTo(x,y)定义线条结束坐标绘制线条必须用到context.stroke()方法 矩形123fillRect(x,y,width,height)//绘制一个填充的矩形strokeRect(x,y,width,height)//绘制一个矩形的边框(也就是一个带边框的矩形啦)clearRect(w,y,width,height)//清除指定矩形区域，让清楚部分完全透明 画圆12context.arc(x,y,r,start,stop)//画一个以(x,y)为圆心，r为半径，从start开始到endAngle结束，按照stop给定的方向(默认为顺时针)来生成，需要注意的是start和stop的单位是弧度，不是度数，角度与弧度的js表达式：radians=(Math.PI/180)*degress Canvas文本 绘制文本12345fillText(text,x,y [,maxWidth])//在指定的位置填充指定文本，最大宽度可选strokeText(text,x,y [,maxWidth])//在指定的位置绘制文本边框(也就是空心的文字啦)，最大宽度可选举例：ctx.font = &quot;48px serif&quot;;ctx.fillText(&apos;Hello world&apos;,10,50) 文本的样式1234font //设置字体大小和字体名称textAlign //文本对齐选项，值start/end/left/right/center，默认starttextBaseline //基线对齐选项。值top/hanging/middle/alphabetic,ideographic,bottom,默认alphabeticdirection //文本方向，值ltr/rtl/inherit,默认inherit 测量文本measureText()返回一个textMetrics对象的宽度，所在像素，体现文本特性的属性 12var text = ctx.measureText(&apos;foo&apos;);text.width;//就可以输出宽度了 变形变形操作都是在对一个图像设置好属性之后。绘制之前用的 状态的保存和恢复 save(),用来保存canvas状态，canvas状态保存在一个栈中，保存一次，当前的状态就入站，返回上一步的操作，就是restore,恢复状态 移动1234translate(offsetx,offsety)//offsetx是左右偏移量，//offsety是上下偏移量，//变形前保存状态是个很好的习惯,translate移动的是canvas和他的原点到一个不同的位置（也就是将canvas的原点进行了偏移） 旋转1rotate(angle)//angle是以顺时针为方向、以弧度为单位的值 缩放123456scale(x,y)//x，y是横轴和纵轴的缩放因子，必须为正值，//比1小是缩小，比1大是放大，默认情况下，canvas 的 1 单位就是 1 个像素。//举例说，如果我们设置缩放因子是 0.5，1 个单位就变成对应 0.5 个像素，//这样绘制出来的形状就会是原先的一半。//同理，设置为 2.0 时，1 个单位就对应变成了 2 像素，绘制的结果就是图形放大了 2 倍。 transform 12345678transform(a,b,c,d,e,f)//参数：// a:水平缩放绘图// b: 水平倾斜绘图// c:chu垂直倾斜绘图// d:垂直缩放绘图// e:水平移动绘图// f:垂直移动绘图]]></content>
      <categories>
        <category>前端笔记</category>
      </categories>
      <tags>
        <tag>Canvas</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Angular过滤器]]></title>
    <url>%2F2017%2F07%2F24%2Fangular-%E8%BF%87%E6%BB%A4%E5%99%A8%2F</url>
    <content type="text"><![CDATA[filter里面可以使用service过滤器一般用来进行数据处理(数据格式化) currency:货币格式化 1&#123;&#123;50 | currency:&apos;￥&apos;&#125;&#125; ￥50 uppercase:大写 1&#123;&#123; &apos;Hello&apos; | uppercase &#125;&#125; HELLO lowercase:小写 1&#123;&#123;&apos;Hello&apos; | lowercase &#125;&#125; hello number: 定义小数的位数 1&#123;&#123;50 | number:2&#125;&#125; 50.00 json:让数据以json格式展示pre标签可以保留文本和换行p标签会忽略换行和空格 1234567$scope.name=&#123;a:1,b:2&#125;&lt;pre&gt;&#123;&#123;name | json&#125;&#125;&lt;/pre&gt;====&gt;&#123; a: 1, b: 2&#125; limitTo截取数组或字符串、数字(当做字符串)只能从头截取 12&#123;&#123;[1,2,3] | limitTo:1&#125;&#125; ===&gt;[1]&#123;&#123;[1,2,3] | limitTo:2&#125;&#125; ===&gt;[1,2] 默认是数组或字符串的长度写负数可以从后面截取 filter:匹配子串用来处理一个数组，然后可以过滤出含有某个子串的元素，作为一个子数组来返回。可以是字符串数组，也可以是对象数组。如果是对象数组，可以匹配属性的值。它接收一个参数，用来定义子串的匹配规则html12345678复制代码&lt;ul&gt; &lt;li&gt;filter 匹配子串(以下写法只是方便观察)&lt;/li&gt; &lt;li&gt;&#123;&#123; webArr | filter : &apos;n&apos; &#125;&#125; &lt;!--匹配属性值中含有n的--&gt;&lt;/li&gt; &lt;li&gt;&#123;&#123; webArr | filter : 25 &#125;&#125; &lt;!--匹配属性值中含有25的--&gt;&lt;/li&gt; &lt;li&gt;&#123;&#123; webArr | filter : &#123;name : &apos;l&apos;&#125; &#125;&#125; &lt;!--//参数是对象，匹配name属性中含有l的--&gt;&lt;/li&gt; &lt;li&gt;&#123;&#123; webArr | filter : fun &#125;&#125; &lt;!--/参数是函数，指定返回age&gt;25的--&gt;&lt;/li&gt;&lt;/ul&gt; js1234567$scope.webArr = [ &#123;name:&apos;nick&apos;,age:25&#125;, &#123;name:&apos;ljy&apos;,age:28&#125;, &#123;name:&apos;xzl&apos;,age:28&#125;, &#123;name:&apos;zyh&apos;,age:30&#125; ];$scope.fun = function(e)&#123;return e.age&gt;25;&#125;; 结果1234[&#123;&quot;name&quot;:&quot;nick&quot;,&quot;age&quot;:25&#125;][&#123;&quot;name&quot;:&quot;nick&quot;,&quot;age&quot;:25&#125;][&#123;&quot;name&quot;:&quot;ljy&quot;,&quot;age&quot;:28&#125;,&#123;&quot;name&quot;:&quot;xzl&quot;,&quot;age&quot;:28&#125;][&#123;&quot;name&quot;:&quot;ljy&quot;,&quot;age&quot;:28&#125;,&#123;&quot;name&quot;:&quot;xzl&quot;,&quot;age&quot;:28&#125;,&#123;&quot;name&quot;:&quot;zyh&quot;,&quot;age&quot;:30&#125;] orderBy以什么属性来排序123&#123;&#123;data | orderBy:&quot;key&quot;&#125;&#125; 以key键来排序，从小到大&#123;&#123;data | orderBy:&quot;-key&quot;&#125;&#125; 以key键来排序，从大到小&#123;&#123;data | orderBy:&quot;key&quot;：true&#125;&#125; 以key键来排序 从大到小]]></content>
      <categories>
        <category>Angular</category>
      </categories>
      <tags>
        <tag>Angular</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Angular自定义指令]]></title>
    <url>%2F2017%2F07%2F23%2FAngular%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8C%87%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[angular自定义指令语法12345myapp.directive(&apos;ngName&apos;,function()&#123; return&#123; &#125;&#125;) 写一个简单的自定义指令例子123456789myapp.directive(&quot;hello&quot;,function() &#123; return &#123; scope: &#123;&#125;, restrict: &quot;AECM&quot;, template: &quot;&lt;div&gt;新数据&lt;span ng-transclude&gt;&lt;/span&gt;&lt;/div&gt;&quot;, replace: true, transclude: true &#125; &#125;) scope:创建指令自己独立作用域，与父级毫无关系restrict值： E: 作为元素名使用 A: 作为属性使用 C: 作为类名使用 M: 作为注释使用 restrict的值可以是ECMA内的任何一种也可以是多个，restrict默认值是”EA”,即可以通过元素名和属性名来调用指令 注意： 如果replace属性不为true的话，那么会在调用指令名的标签内部去添加template的内容，这个时候注释调用不能用 定义自定义指令名字中间有 ‘-‘的时候，在js里面要去掉’-‘,后面字母大写例如:定义指令名称myDrictive调用时可以写成 1&lt;div my-drictive&gt;&lt;/div&gt; 如果使用了replace true的话，那么template属性里必须是标签包含的 templateUrl可以设置替换的模板地址，注意如果使用了replace：true，那么一定要在模板页面最外层包一个标签 模板里也可以使用当前控制器里挂载的数据，transclude可以用来保存指令标签内本来有的内容在html里面使用12345678//属性调用&lt;div hello&gt;原有数据&lt;/div&gt;//标签调用&lt;hello&gt;&lt;/hello&gt;//类名调用&lt;div class=&quot;hello&quot;&gt;&lt;/div//注释调用&lt;!-- directive:hello --&gt; angularjs对于指令的编译过程 遍历dom,找到所有指令 根据template、templateUrl、replace、transclude来转换dom结构，如果有compile函数的话就执行compile函数 对每一条指令执行link函数并绑定作用域 angular不建议在控制器里操作dom，操作dom的事情例如添加事件更改样式都应该在指令compile函数及link函数里执行 compile函数常用参数有element和attrs，分别是当前指令的dom和当前dom指令的值，如果设置了compile的话，必须写上返回值，它返回的函数即为link函数link函数的常用参数有scope,element,attrs,scope就是当前指令标签所处的作用域 compile和link使用时机compile: 想在dom渲染前对它进行变形，并且不需要scope参数，例如ng-style link: 需要用到scope参数来实现dom元素的一些行为，例如ng-model]]></content>
      <categories>
        <category>Angular</category>
      </categories>
      <tags>
        <tag>Angular</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浏览器兼容性问题]]></title>
    <url>%2F2017%2F07%2F22%2F%E6%B5%8F%E8%A7%88%E5%99%A8%E5%85%BC%E5%AE%B9%E6%80%A7%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[主流浏览器：Internet Explorer，Safari，Goggle Chrome，opera，Mozilla Firefox，360、遨游、世界之窗 浏览器历史浏览器内核及代表作品 trident(MSHTML) IE、360 Gecko Mozilla FireFox Presto opera webkit Safari chrome内核原型，它是苹果公司自己的内核，Safari、Chrome Blink 由goggle和opera software开发的浏览器排版引擎 浏览器兼容问题的由来常见的浏览器bug以及解决方法 图片下方3像素 123hack1:将div与img写在一行上可以解决 IE6/7hack2:将img转换为块状元素，给img添加声明：display:block;hack3:给div加overflow：hidden; 换行3像素 12hack1:不换行将元素放在一行内显示hack2:给元素加浮动 鼠标指针bug 12描述：cursor属性的hand属性值只有IE浏览器识别，其他浏览器不识别该声明，cursor属性的pointer属性值IE6以上版本及其他浏览器都识别该声明。hack1:如统一某元素鼠标指针形状为手型，应添加声明cursor:pointer; li里a加display:block;出现行高不一致 12hack1:给a加display:inline-block;hack2:给a加display:inline; 超链接图片边框一半 1hack1:给&lt;a&gt;声明：display:inline-block; 图片超链接边框 1hack1:给img声明：border:none; 表单元素不对齐 123hack1:给表单元素加float;hack2:把图片按钮换成普通按钮hack3:用a标签伪装按钮 margin值叠加（FireFox、Chrome） 12hack1:给子元素加floathack2:给父元素加padding或者border 导航在IE7以下呈阶梯状 1hack:给li加浮动 IE6常见兼容问题以及解决方法 双倍浮向（双倍边距） 描述：当一个元素里浮动方向与外边距方向一样是，会错误地把margin值显示为双倍 12hack1:给元素添加声明：display:inline;hack2:添加声明 _margin-left:1/2; 部分元素拥有默认高度（一个字的高度） 12hack1:给元素添加声明：font-size:0;hack2:给元素添加声明：overflow-hidden; 百分比bug 描述：在解析百分比时，会按照四舍五入方式计算从而导致50%加50%大于100%； 1hack1:给右面的浮动元素添加声明:clear:right; ie6元素高度会被撑大 1hack:给元素添加overflow:hidden ie6下文字重复 1hack:元素之间有html注释影响，删除注释]]></content>
      <categories>
        <category>前端笔记</category>
      </categories>
      <tags>
        <tag>浏览器</tag>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jQuery选择器]]></title>
    <url>%2F2017%2F07%2F22%2FjQuery%E9%80%89%E6%8B%A9%E5%99%A8%2F</url>
    <content type="text"><![CDATA[jQuery选择器基本选择器 $(“#id”) 根据给定的id查找要操作的元素 $(“.class”) 根据给定的类名查找要操作的元素 $(“div”) 根据元素标签名查找 $(“*”) 查找所有元素 $(“#id,.class”) 组合选择器中间用逗号隔开 层级选择器： 空格 $(“div p”)查找div里面所有后代元素p &#62; $(“div&gt;p”)查找div里面所有子代元素p ~ $(“div~p”)查找div下面所有的兄弟元素 +$(“div+p”)查找div下面紧挨着的元素p 简单选择器 :first $(“li:first”)查找li第一个元素 :last $(“li:last”)查找li最后一个元素 :not $(“li:not(“.box”)”)查找li类名不是box的li元素 :eq$(“li:eq(n)”) n&gt;=0 查找第几个li :odd$(“li:odd”) 查找下标为奇数的行 :even $(“li:even”) 查找下标为偶数的行 :gt $(“li:gt(n)”) n&gt;=0 查找下标大于某个数的行 :lt $(“li:gt(n)”) n&gt;=0 查找下标小于于某个数的行 :has $(“li:has(ul)”) 查找包含ul的li元素 查找过滤： .first() $(“p”).first() 查找p第一个元素 .last() $(“li”).last() 查找li最后一个元素 .eq() $(“li”).eq(n) 查找第n个li元素 find() $(“div”).find(“span”)查找div中所有的span元素 等价于 $(“div span”) children() $(“div”).children()查找div中所有的子元素$(“div”).children(“span”)查找div中所有的子元素span 等价于 $(“div&gt;span”) filter() 1234567$(&quot;p&quot;).filter(&quot;.box&quot;) 查找p中带有box类名的p 等价于 $(&quot;p.box&quot;)$(&quot;p&quot;).filter(function(index)&#123;//根据函数的返回值查找元素,如果返回值为true,表示按照该条件查找到了某个元素，如果返回false，表示没有找到任何元素//参数index表示p的下标&#125;) next():$(“#box”).next() 查找id为box的下一个兄弟元素$(“#box”).next(“p”) 查找id为box的下一个兄弟元素p nextAll():$(“#box”).nextAll() 查找id为box的所有兄弟元素$(“#box”).nextAll(“p”) 查找id为box后面所有的兄弟元素p siblings() 除了本身之外的所有兄弟元素 prev() 同next() 也有两种情况 带参数和不带参数 prevAll() 同nextAll() 也有两种情况 带参数和不带参数 parent() 查找某个元素的父节点 可见性过滤选择器 $(“li:hidden”) 匹配所有不可见元素，或type为hidden的元素 $(“li:visible”) 匹配所有可见元素 属性过滤选择器 $(“div[id]”) 所有含有 id 属性的 div 元素 $(“div[id=’123’]”) id属性值为123的div 元素 $(“div[id!=’123’]”) id属性值不等于123的div 元素 $(“div[id^=’qq’]”) id属性值以qq开头的div 元素 $(“div[id$=’zz’]”) id属性值以zz结尾的div 元素 $(“div[id*=’bb’]”) id属性值包含bb的div 元素 $(“input[id][name$=’man’]”) 多属性选过滤，同时满足两个属性的条件的元素 状态过滤选择器 $(“input:enabled”) 匹配可用的 input $(“input:disabled”) 匹配不可用的 input $(“input:checked”) 匹配选中的 input $(“option:selected”) 匹配选中的 option 表单选择器 $(“:input”) 匹配所有 input, textarea, select 和 button 元素 $(“:text”) 所有的单行文本框，$(“:text”) 等价于$(“[type=text]”)，推荐使用$(“input:text”)效率更高，下同 $(“:password”) 所有密码框 $(“:radio”) 所有单选按钮 $(“:checkbox”) 所有复选框 $(“:submit”) 所有提交按钮 $(“:reset”) 所有重置按钮 $(“:button”) 所有button按钮 $(“:file”) 所有文件域]]></content>
      <categories>
        <category>前端笔记</category>
      </categories>
      <tags>
        <tag>jQuery</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jQuery初步认识]]></title>
    <url>%2F2017%2F07%2F22%2FjQuery%E5%88%9D%E6%AD%A5%E8%AE%A4%E8%AF%86%2F</url>
    <content type="text"><![CDATA[jQuery概述1. jQuery概念 javaScript概念：基于JS语言的API和语法组织逻辑，通过内置window和document对象，来操作内存中的DOM元素 jQuery概念：基于javaScript的，同上，提高了代码的效率 2. jQuery是什么？ jQuery是一个JavaScript代码仓库，我们称之为JavaScript框架。 jQuery是一个快速简洁的JavaScript框架，可以简化查询DOM对象，处理事件，制作动画、处理按键按下交互过程 优点 轻量级、体积小，使用灵巧（只需引入一个js文件） 强大的选择器 出色的DOM操作的封装 出色的浏览器兼容性 可靠的事件处理机制 完善的Ajax 链式操作、隐式迭代 方便选择页面元素（模仿css选择器更精确灵活） 控制响应事件（动态添加响应事件） 提供基本网页特效（提供已封装的网页特效方法） 快速实现通信（ajax） 易扩展、插件丰富 3. 引包12&lt;script src=&quot;js/jquery.min.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;js/jquery.js&quot;&gt;&lt;/script&gt; 同版本两个文件的区别：min:压缩版，压缩过后，体积会更小 压缩指的是：把注释、空格、换行全部去掉,把变量名称尽可能的换成更加简短的字符。 平时开发过程中，这两个文件使用哪个都可以；但是，项目上线的时候，推荐使用压缩版 引包注意 第一点：在使用jQuery之前，先把jQuery文件引到页面中来，如果在使用jQuery之前，没有引用jQuery文件，会报错 第二点：src路径一定要写正确 如果src路径写错，也会报错 4. js和jQuery的区别 jQuery是js的类库 js是前端脚本语言 使用jQuery能实现的js原生一定能实现、反过来js原生能实现的jQuery可能实现不了 5. jQuery的入口函数入口函数就是指程序运行的时候最开始调用的函数，也是程序开始的地方 jQuery入口函数第一种方式1$(document).ready(function()&#123;&#125;) 第二种方式1$(function()&#123;&#125;) 以上两种写法，作用完全相同，用那个都可以 js入口函数1window.onload=function()&#123;&#125; jQuery入口函数和js入口函数的区别 执行时机不同 jQuery的入口函数，是在文档加载完成后就执行。文档加载完成指的是：DOM数加载完成后，就可以操作DOM了，不用等到所有的外部资源都加载完成。 js入口函数是在所有资源加载完成后，才执行。（包括：页面、外部js文件、外部css文件、图片） 书写个数不同 jQuery的入口函数可以有多个，不会覆盖 js入口函数只能出现一次，出现多次会存在事件覆盖的问题]]></content>
      <categories>
        <category>前端笔记</category>
      </categories>
      <tags>
        <tag>jQuery</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1.Angular是什么]]></title>
    <url>%2F2017%2F07%2F22%2F1-Angular%E6%98%AF%E4%BB%80%E4%B9%88%2F</url>
    <content type="text"><![CDATA[angular是一个javascript framework，一个js的框架，帮助我们创建WebApplication，属于下一代js应用框架 AngularJs是由谷歌公司创建，遵循MIT协议，开源开放。 网址：https://angularjs.org/中文网：http://www.apjs.net/中文社区：http://www.angularjs.cn/www.bootcdn.cn/angular.js/ AngularJs这套js框架针对于SPA应用以及商业业务流程应用的开发具有特别的优势。 比较难学，学习途径比较陡峭，因为用到了很多的后台逻辑代码的思维 适用于：SPA（singel page app）应用：单页面应用 –路由机制 CRUD应用： 增加(Create)、查询(Retrieve)(重新得到数据)、更新(Update)和删除(Delete)，例如后台管理界面。购物车逻辑—数据双向绑定 不适用：游戏、图形界面编辑器，这种频繁DOM操作也很复杂的应用 版本介绍：1.3版本是一个分水岭，最稳定的是1.5.4-1.5.8的版本，这个时候就更新的很少了 2.0版本现在还没有一个正式版，从2.0版本开始已经全部不一样了，但是没关系，现在市场上使用2.0版本还是很少的，预计17年年底才能完美面世。 ps：ionic .，这个是要和angular配合使用的，因为angular并没有自己的一个样式组件，并且在移动端有很多水土不服的地方，于是，ionic横空出世把移动端一些个angular做的不好的地方全部克服掉，抢占了部分市场和用户。 angular的特性： MVC模式 model view controller 模块系统 指令系统 依赖注入 数据双向绑定 angular缺点 对dom操作支持较弱，当然也可以使用jq； Html中过多指令、事件绑定的操作，耦合度较高 为什么需要MVC,js模块化？ 代码规模越来越大，切分职责是大势所趋 为了复用代码，很多逻辑都是一样的，封装 为了方便后期的维护，修改一块功能不影响其他功能]]></content>
      <categories>
        <category>Angular</category>
      </categories>
      <tags>
        <tag>Angular</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[nodejs Web模块]]></title>
    <url>%2F2017%2F07%2F21%2Fnode.js%20Web%E6%A8%A1%E5%9D%97%2F</url>
    <content type="text"><![CDATA[什么是Web服务器?Web服务器一般指网站服务器，是指驻留于因特网上某种类型计算机的程序，Web服务器的基本功能就是提供Web信息浏览服务。他只需支持http协议，HTML文档格式级url，与客户端的网络浏览配合。大多数Web服务器都支持服务端的脚本语言（php、Python、ruby）等，并通过脚本语言从数据库获取数据，将结果返回给客户端浏览器。 目前最主流的三个Web服务器是Apache、Nginx、IIS。 Web应用架构 client-客户端，一般指浏览器，浏览器可以通过HTTP协议向服务器请求数据。 Server-服务端，一般指Web服务器，可以接受客户端请求，并向客户端发送响应数据。 Business-业务层，通过Web服务器处理应用程序，如与数据库交互，逻辑运算，调用外部程序等。 Data-数据层，一般由数据库组成。 使用node创建Web服务器NodeJs提供了http模板，http模块主要用于搭建HTTP服务端和客户端，使用HTTP服务器或客户端功能必须调用http模块，代码如下：1var http=require(&apos;http&apos;); 一下是演示一个最基本的HTTP服务器架构（使用8081端口），创建server.js文件，代码如下所示：1234567891011121314151617181920212223242526var http=require(&apos;http&apos;);var fs=require(&apos;fs&apos;);var url=require(&apos;url&apos;);//创建服务器http.createServer(function(request,response)&#123; //解析请求，包括文件名 var pathname=url.parse(request.url).pathname; //输出请求的文件名 console.log(&quot;Request for&quot;+pathname+&quot;received&quot;); //从系统文件中读取请求的文件内容 fs.readFile(pathname.substr(1),function(err,data)&#123; if(err)&#123; console.log(err); //HTTP状态码：404：NOT FOUND //Content Type:text/plain response.writeHead(200,&#123;&apos;Content-type&apos;:&apos;text/html&apos;&#125;); //响应文件内容 response.write(data.toString()); &#125; //发送响应数据 response.end(); &#125;);&#125;).listen(8081);//控制台会输出以下信息console.log(&apos;server runing at http://127.0.0.1:8081/&apos;) 接下来我们在该目录下创建一个index.html文件，代码如下：12345678&lt;html&gt;&lt;head&gt;&lt;title&gt;Sample Page&lt;/title&gt;&lt;/head&gt;&lt;body&gt;Hello World!&lt;/body&gt;&lt;/html&gt; 执行server.js文件：12$ node server.jsServer running at http://127.0.0.1:8081/ 使用node创建Web客户端123456789101112131415161718192021var http=require(&apos;http&apos;);//用于请求的选项var options=&#123; host:&apos;localhost&apos;, port:&apos;8081&apos;, path:&apos;/index.html&apos;&#125;;//处理响应的回调函数var callback=function(response)&#123; //不断更新数据 var body=&apos;&apos;; response.on(&apos;data&apos;,function(data)&#123; body+=data; &#125;); response.on(&apos;end&apos;,function()&#123; //数据接收完成 console.log(body); &#125;)&#125;//]]></content>
      <categories>
        <category>前端笔记</category>
      </categories>
      <tags>
        <tag>nodejs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[nodejs模块系统]]></title>
    <url>%2F2017%2F07%2F21%2Fnodejs%E6%A8%A1%E5%9D%97%E7%B3%BB%E7%BB%9F%2F</url>
    <content type="text"><![CDATA[什么是模块? 在node中，文件和模块是一一对应的，也就是一个文件就是一个模块 每个模块都有自己的作用域 我们使用var来申明的一个变量。他并不是全局的，而是属于当前模块下 模块的加载与使用 模块的引入在node中，我们使用require(‘模块’)的形式将一个模块引入到我们的当前的文件夹中。关于require路径的写法也有如下几种 模块路径可以是一个以/开头，表示一个绝对路径 模块路径以./开头，表示当前目录出发的相对路径 模块如果没有以/或./开头，那么这个模块要么是核心模块要么是通过npm安装在node_modules文件下的。 看到上面的不同路径写法,我们就想起来在web中引入当前文件夹中的文件时是不需要加上./的, 但在 node 中使用 ./ 或 / 开头的路径和不使用时,有着很大的差别。 模块的加载机制 首先按照加载模块的文件名进行查找 如果没有找到，则会在模块文件名称后加上.js的后缀，进行查找 如果还没有找到，则会在文件名称后加上.json的后缀，进行查找 如果还没有，则会在文件名称后加上.node的后缀，进行查找 最终未找到，抛出异常 模块数据的使用与浏览器中不同，在node中，每一个模块都有自己的作用域，在模块中使用var申明的变量的作用域范围是在该模块内，而不是node全局的但是你忘记使用var进行变量声明，恭喜你这时和浏览器中忘记使用的效果是一致的。该变量也将挂在全局对象上。只不过在node中，全局对象是global，而不是浏览器中的window]]></content>
      <categories>
        <category>前端笔记</category>
      </categories>
      <tags>
        <tag>nodejs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javaScript基本概念]]></title>
    <url>%2F2017%2F07%2F15%2FJavaScript%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%2F</url>
    <content type="text"><![CDATA[JavaScript发展历史1995年，JavaScript由Netscape（网景公司）开发的，是一种基于对象和事件驱动的脚本语言 ，并且可在所有主要的浏览器中运行JavaScript 被设计用来向 HTML 页面添加交互行为 ，无需编译，可由浏览器直接解释运行 JavaScript是一种弱类型语言 特点1. 交互性(他可以做的就是信息的动态交互) 2. 安全性(不允许直接访问本地硬盘) 3. 跨平台性(只要是可以解释js的浏览器都可以执行，和平台无关) 语法ECMAScript 的语法大量借鉴了C 及其他类C 语言（如Java 和Perl）的语法。因此，熟悉这些语言的开发人员在接受ECMAScript 更加宽松的语法时，一定会有一种轻松自在的感觉。 1. 区分大小写要理解的第一个概念就是ECMAScript 中的一切（变量、函数名和操作符）都区分大小写。这也就意味着，变量名test 和变量名Test 分别表示两个不同的变量，而函数名不能使用typeof，因为它是一个关键字，但typeOf 则完全可以是一个有效的函数名。 2. 标识符所谓标识符，就是指变量、函数、属性的名字，或者函数的参数。标识符可以是按照下列格式规则组合起来的一个或多个字符： 第一个字符必须是一个字母。下划线(_)或一个美元符号($) 其他字符可以是字母、下划线、美元符号或数字。标识符中的字母也可以包含扩展的ASCII 或Unicode 字母字符（如À和Æ），但我们不推荐这样做。按照惯例，ECMAScript 标识符采用驼峰大小写格式，也就是第一个字母小写，剩下的每个单词的首字母大写，例如：firstSecond、myCar、doSomethingImportant虽然没有谁强制要求必须采用这种格式，但为了与ECMAScript 内置的函数和对象命名格式保持一致，可以将其当作一种最佳实践。 3. 注释12345//单行注释/**这是一个多行*(块级)注释*/ 虽然上面注释中的第二和第三行都以一个星号开头，但这不是必需的。之所以添加那两个星号，纯粹是为了提高注释的可读性（这种格式在企业级应用中用得比较多）。 4. 严格模式ECMAScript 5引入了严格(strict mode)的概念。严格模式是为JavaScript定义了一种不同的解析与执行模型。在严格模式下，ECMAScript 3中的一些不确定的行为将得到处理，而且对某些不安全的操作也会抛出错误。要在整个脚本中启用严格模式。可以在顶部添加如下代码：1&quot;user strict&quot;; 这行代码看起来像是字符串，而且也没有赋值给任何变量，但其实它是一个编译指示(pragma),用于告诉支持的JavaScript引擎切换到严格模式。这是为不破坏ECMAScript 3语法而特意选定的语法。 在函数内部的上方包含这条编译指示，也可以指定函数在严格模式下执行：1234function doSomething()&#123;&quot;use strict&quot;;//函数体&#125; 严格模式下，JavaScript 的执行结果会有很大不同，因此本书将会随时指出严格模式下的区别。支持严格模式的浏览器包括IE10+、Firefox 4+、Safari 5.1+、Opera 12+和Chrome。]]></content>
      <categories>
        <category>前端笔记</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript-深拷贝和浅拷贝]]></title>
    <url>%2F2017%2F07%2F09%2FJavaScript%E4%B8%AD%E6%B5%85%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B7%B1%E6%8B%B7%E8%B4%9D%2F</url>
    <content type="text"><![CDATA[在JavaScript中，对于Object和Array这类引用类型值，当一个变量向另一个变量复制引用类型值时，这个值的副本其实是一个指针，两个变量指向同一个堆对象，改变其中一个变量，另一个也会受到影响。这种拷贝分为两种情况：拷贝引用和拷贝实例，也就是我们说的浅拷贝和深拷贝 浅拷贝(shallow copy)拷贝源对象的引用，这是最简单的拷贝。123456789101112var o1 = &#123;a: 1&#125;;var o2 = o1;console.log(o1 === o2); //=&gt;trueo2.a = 2;console.log(o1.a); //=&gt;2//数组var o1 = [1,2,3];var o2 = o1;console.log(o1 === o2); // =&gt; trueo2.push(4);console.log(o1); // =&gt; [1,2,3,4] 拷贝原对象的实例，但是对其内部的引用类型值，拷贝的是其引用，常用的就是如jquey中的$.extend({}, obj); Array.prototype.slice()和Array.prototype.concat()都会返回一个数组或者对象的浅拷贝，举个例子：12345678910var o1 = [&apos;darko&apos;, &#123;age: 22&#125;];var o2 = o1.slice(); // 根据Array.prototype.slice()的特性，这里会返回一个o1的浅拷贝对象console.log(o1 === o2); // =&gt; false，说明o2拷贝的是o1的一个实例o2[0] = &apos;lee&apos;;console.log(o1[0]); // =&gt; &quot;darko&quot; o1和o2内部包含的基本类型值，复制的是其实例，不会相互影响o2[1].age = 23;console.log(o1[1].age); // =&gt;23 o1和o2内部包含的引用类型值，复制的是其引用，会相互影响 可以通过Array.prototype.slice()或jQuery中的$.extend({}, obj)完成对一个数组或者对象的浅拷贝，我们也可以自己写一个简单浅拷贝函数来加深对浅拷贝的理解12345678910111213 // 浅拷贝实现，仅供参考function shallowClone(source) &#123; if (!source &amp;&amp; typeof source !== &apos;object&apos;) &#123; throw new Error(&apos;error arguments&apos;); &#125; var targetObj = source.constructor === Array ? [] : &#123;&#125;; for (var keys in source) &#123; if (source.hasOwnProperty(keys)) &#123; targetObj[keys] = source[keys]; &#125; &#125; return targetObj;&#125; 深拷贝（deep copy）深拷贝也就是拷贝出一个新的实例，新的实例和之前的实例互不影响，深拷贝的实现有几种方法，首先我们可以借助jQuery，lodash等第三方库完成一个深拷贝实例。在jQuery中可以通过添加一个参数来实现递归extend，调用$.extend(true, {}, …)就可以实现一个深拷贝。 我们也可以自己实现一个深拷贝的函数，通常有两种方式，一种就是用递归的方式来做，还有一种是利用JSON.stringify和JSON.parse来做，这两种方式各有优劣，先来看看递归的方法怎么做。 jQuery中的extend方法基本的就是按照这个思路实现的，但是没有办法处理源对象内部循环引用的问题，同时对Date，Funcion等类型值也没有实现真正的深度复制，但是这些类型的值在重新定义的时候一般都是直接覆盖，所以也不会对源对象产生影响，从一定程度上来说也算是实现了一个深拷贝。1234567891011121314151617181920212223242526272829303132// 递归实现一个深拷贝function deepClone(source)&#123; if(!source &amp;&amp; typeof source !== &apos;object&apos;)&#123; throw new Error(&apos;error arguments&apos;, &apos;shallowClone&apos;); &#125; var targetObj = source.constructor === Array ? [] : &#123;&#125;; for(var keys in source)&#123; if(source.hasOwnProperty(keys))&#123; if(source[keys] &amp;&amp; typeof source[keys] === &apos;object&apos;)&#123; targetObj[keys] = source[keys].constructor === Array ? [] : &#123;&#125;; targetObj[keys] = deepClone(source[keys]); &#125;else&#123; targetObj[keys] = source[keys]; &#125; &#125; &#125; return targetObj;&#125;// test examplevar o1 = &#123; arr: [1, 2, 3], obj: &#123; key: &apos;value&apos; &#125;, func: function()&#123; return 1; &#125;&#125;;var o3 = deepClone(o1);console.log(o3 === o1); // =&gt; falseconsole.log(o3.obj === o1.obj); // =&gt; falseconsole.log(o2.func === o1.func); // =&gt; true 还有一种实现深拷贝的方式是利用JSON对象中的parse和stringify，JOSN对象中的stringify可以把一个js对象序列化为一个JSON字符串，parse可以把JSON字符串反序列化为一个js对象，通过这两个方法，也可以实现对象的深复制。 我们从下面的例子就可以看到，源对象的方法在拷贝的过程中丢失了，这是因为在序列化JavaScript对象时，所有函数和原型成员会被有意忽略，这个实现可以满足一些比较简单的情况，能够处理JSON格式所能表示的所有数据类型，同时如果在对象中存在循环应用的情况也无法正确处理。123456789101112131415// 利用JSON序列化实现一个深拷贝function deepClone(source)&#123; return JSON.parse(JSON.stringify(source));&#125;var o1 = &#123; arr: [1, 2, 3], obj: &#123; key: &apos;value&apos; &#125;, func: function()&#123; return 1; &#125;&#125;;var o2 = deepClone(o1);console.log(o2); // =&gt; &#123;arr: [1,2,3], obj: &#123;key: &apos;value&apos;&#125;&#125;]]></content>
      <categories>
        <category>前端笔记</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript-类型检测]]></title>
    <url>%2F2017%2F07%2F06%2FJavaScript-%E6%A3%80%E6%B5%8B%E7%B1%BB%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[typeof操作符鉴于 ECMAScript 是松散类型的，因此需要有一种手段来检测给定变量的数据类型——typeof 就 是负责提供这方面信息的操作符。对一个值使用 typeof 操作符可能返回下列某个字符串： “undefined”——如果这个值未定义； “boolean”——如果这个值是布尔值； “string”——如果这个值是字符串； number”——如果这个值是数值； “object”——如果这个值是对象或 null； “function”——如果这个值是函数。ES6 引入了一种新的原始数据类型Symbol,表示独一无二的值。它是JavaScript语言的第七种数据类型1typeof Symbol() === &apos;symbol&apos; 下面是几个使用 typeof 操作符的例子：1234var message = &quot;some string&quot;;alert(typeof message); // &quot;string&quot;alert(typeof(message)); // &quot;string&quot;alert(typeof 95); // &quot;number&quot; 以上例子说明，typeof操作符的操作数可以是变量(message),也可以是数值字面量。注意 typeof是一个操作符而不是函数，因此例子中的圆括号尽管可以使用，但不是必须的。虽然在检测基本数据类型时 typeof 是非常得力的助手，但在检测引用类型的值时，这个操作符的用处不大。通常，我们并不是想知道某个值是对象，而是想知道它是什么类型的对象。为此，ECMAScript提供了 instanceof 操作符，其语法如下所示：1result = variable instanceof constructor 如果变量是给定引用类型（根据它的原型链来识别；第 6 章将介绍原型链）的实例，那么 instanceof 操作符就会返回 true。请看下面的例子：123alert(person instanceof Object); // 变量 person 是 Object 吗？alert(colors instanceof Array); // 变量 colors 是 Array 吗？alert(pattern instanceof RegExp); // 变量 pattern 是 RegExp 吗？ 根据规定，所有引用类型的值都是 Object 的实例。因此，在检测一个引用类型值和 Object 构造 函数时，instanceof 操作符始终会返回 true。当然，如果使用 instanceof 操作符检测基本类型的 值，则该操作符始终会返回 false，因为基本类型不是对象。 使用 typeof 操作符检测函数时，该操作符会返回”function”。在 Safari 5 及 之前版本和 Chrome 7 及之前版本中使用 typeof 检测正则表达式时，由于规范的原 因，这个操作符也返回”function”。ECMA-262 规定任何在内部实现[[Call]]方法 的对象都应该在应用 typeof 操作符时返回”function”。由于上述浏览器中的正则 表达式也实现了这个方法，因此对正则表达式应用 typeof 会返回”function”。在 IE 和 Firefox 中，对正则表达式应用 typeof 会返回”object”]]></content>
      <categories>
        <category>前端笔记</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo原理及其常用命令]]></title>
    <url>%2F2017%2F07%2F01%2FHexo%E5%8E%9F%E7%90%86%E5%8F%8A%E5%85%B6%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[Hexo原理及其常用命令 Hexo原理使用 Node.js 编写，在 Hexo 的官网上是这样描述 Hexo 的： A fast, simple &amp; powerful blog framework 意为「快速、简洁且高效的博客框架」 ，通俗的来说，Hexo 是一个静态博客生成引擎，用户可以使用文本编辑器写作，然后再用 Hexo 生成 Html 文件。相比 Jekyll，Hexo 的速度更快，而且有众多风格的主题供用户选择，比如我的博客用的就是 Next。Hexo 的作者是来自台湾的 Tommy Chen。 hexo命令 npm install hexo -g #安装npm update hexo -g #升级hexo init #初始化 简写 hexo n “我的博客” == hexo new “我的博客” #新建文章hexo p == hexo publishhexo g == hexo generate#生成hexo s == hexo server #启动服务预览hexo d == hexo deploy#部署 服务器 hexo server #Hexo 会监视文件变动并自动更新，您无须重启服务器。hexo server -s #静态模式hexo server -p 5000 #更改端口hexo server -i 192.168.1.1 #自定义 IPhexo clean #清除缓存 网页正常情况下可以忽略此条命令hexo g #生成静态网页hexo d #开始部署 监视文件变动 hexo generate #使用 Hexo 生成静态文件快速而且简单hexo generate –watch #监视文件变动 完成后部署两个命令的作用是相同的 hexo generate –deployhexo deploy –generatehexo deploy -ghexo server -g 草稿 hexo publish [layout] 模版 hexo new “postName” #新建文章hexo new page “pageName” #新建页面hexo generate #生成静态页面至public目录hexo server #开启预览访问端口（默认端口4000，’ctrl + c’关闭server）hexo deploy #将.deploy目录部署到GitHub]]></content>
      <categories>
        <category>前端笔记</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[7.sass分支结构、循环结构、函数]]></title>
    <url>%2F2017%2F06%2F21%2F7.%E5%88%86%E6%94%AF%E7%BB%93%E6%9E%84%E3%80%81%E5%BE%AA%E7%8E%AF%E7%BB%93%E6%9E%84%E3%80%81%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[分支结构在sass里，可以使用@if让我们根据一些条件来应用特定的样式 结构： 123@if 条件 &#123; &#125; 如果条件为真的话，括号里的代码就会释放出来 例如： 12345678910$use-refixes:true;.rounded&#123; @if $use-refixes &#123; -webkit-border-radius:5px; -moz-border-radius:5px; -ms-border-radius:5px; -o-border-radius:5px; &#125; border-radius:5px;&#125; —&gt;1234567.rounded &#123; -webkit-border-radius: 5px; -moz-border-radius: 5px; -ms-border-radius: 5px; -o-border-radius: 5px; border-radius: 5px;&#125; 如果是另外一种情况 1$use-refixes:false; —》123.rounded &#123; border-radius: 5px;&#125; if else在sass里的写法是： 123456789body&#123;true@if $theme == dark &#123;truetruebackground:black;true&#125; @else if $theme == light &#123;truetruebackground:white;true&#125; @else &#123;truetruebackground:gray;true&#125;&#125; for循环在sass里的for循环是这样的 123@for $var form &lt;开始值&gt; through &lt;结束值&gt; &#123; ...&#125; 还有一种是 123@for $var form &lt;开始值&gt; to &lt;结束值&gt; &#123; ...&#125; 注意，开始值和结束值的关系可以是升序也可以是倒序，但是每次只能+1或者-1 这两种有什么区别呢？ 区别就是 from 1 to 4 的话是执行三次，i的变化是 1 2 3 from 1 through 4 的话是执行四次，i的变化是 1 2 3 4 如： from to 123456$columns:4;@for $i from 1 to $columns&#123;true.col-#&#123;$i&#125;&#123;truetruewidth:100% / $columns * $i;true&#125;&#125; —》 1234567891011.col-1 &#123; width: 25%;&#125;.col-2 &#123; width: 50%;&#125;.col-3 &#123; width: 75%;&#125; from through 123456$columns:4;@for $i from 1 through $columns&#123;true.col-#&#123;$i&#125;&#123;truetruewidth:100% / $columns * $i;true&#125;&#125; —&gt; 123456789101112131415.col-1 &#123; width: 25%;&#125;.col-2 &#123; width: 50%;&#125;.col-3 &#123; width: 75%;&#125;.col-4 &#123; width: 100%;&#125; each 遍历list类型在sass里可以利用each方法来遍历咱们的list类型的数据 list类型在js里类似于数组，那么each类似于for in遍历，结构如下： 123@each $item in $list&#123; ...&#125; 例如： 1234567$colors:success error warning;$map:(success:green,warning:yellow,error:red);@each $color in $colors&#123;true.bg-#&#123;$color&#125;&#123;truetruebackground:map-get($map,$color);true&#125;&#125; —&gt; 1234567891011.bg-success &#123; background: green;&#125;.bg-error &#123; background: red;&#125;.bg-warning &#123; background: yellow;&#125; @while 循环在sass里，拥有@while循环，比@for会更好用一些,@for循环只能从一个数到另一个数变化之间执行，每次变化都是1，while设置循环结构的话更为灵活； 结构： 123@while 条件&#123; &#125; eq： 12345678$i:6;@while $i&gt;0&#123;true.item-#&#123;$i&#125;&#123;truetruewidth:$i*5px;true&#125;true$i:$i - 2;&#125; 注意：$i - 2 需要用空格隔开哟 ———》 1234567891011.item-6 &#123; width: 30px;&#125;.item-4 &#123; width: 20px;&#125;.item-2 &#123; width: 10px;&#125; 自定义函数在sass里也可以定义函数，并且也可以有返回值 结构： 123@function 名称 (参数1，参数2)&#123; @return ...&#125; 例如，我们做一个返回map里key对应的值的函数： 1234567891011$colors:(light:#ffffff,dark:#000000,gray:#555555);@function color($key)&#123;true@return map-get($colors,$key);&#125;body&#123;truebackground:color(light);truecolor:color(dark);trueborder-color:color(gray);&#125; —》 12345body &#123; background: #ffffff; color: #000000; border-color: #555555;&#125;]]></content>
      <categories>
        <category>前端笔记</category>
      </categories>
      <tags>
        <tag>sass</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[6.数据类型与函数]]></title>
    <url>%2F2017%2F06%2F20%2F6.%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[数据类型在sass里有数字、字符串、列表、颜色等类型 在cmd里 输入 1sass -i 就会进入到交互模式，输入的计算可以马上得到结果 type-of()可以用来得到数据类型，如： 1type-of(5) -&gt; number 注意数字类型的可以包含单位，如： 1type-of(5px) -&gt; number 字符串类型： 123type-of(hello) -&gt; stringtype-of(&apos;hello&apos;) -&gt; string list类型： 123type-of(1px solid red) -&gt; listtype-of(5px 10px) -&gt; list 颜色： 123type-of(red) -&gt; colortype-of(rgb(255,0,0) -&gt; colortype-of(#333) -&gt; color number 计算1232+9 -》102*8 -》16(8/2) -&gt;4 //除法要写括号 也可以包含单位 1234567895px + 5px -&gt; 10px5px -2 -&gt;3px5px *2 -&gt;10px5px * 2px -&gt;10px*px //这样就不对了哟（10px/2px） -&gt; 5//除法单位取消3+2*5px-&gt;13px 好吧，都是一些小学的数学题，很简单对吧处理数字的函数绝对值 123abs(10) -&gt; 10;abs(10px) -&gt; 10px;abs(-10px) -&gt; 10px; 四舍五入相关 1234567891011121314round(3.4)-&gt;3 //四舍五入round(3.6)-&gt;4ceil(3.2)-&gt;4 //向上取整ceil(3.6)-&gt;4floor(3.2)-&gt;3 //向下取整floor(3.9)-&gt;3percentage(600px/1000px) -&gt;65% //百分之min(1,2,3) -&gt; 1 //最小值max(2,3,4,5) -&gt; 5 //最大值 字符串相关12345678910111213//带引号和不带引号的字符串想加为带引号的字符串&quot;a&quot; + b -&gt;&quot;ab&quot;a + &quot;b&quot; -&gt;&quot;ab&quot;//字符串+数字&quot;ab&quot; + 1 -&gt;&quot;ab1&quot;//字符串 - 和 / 字符串&quot;a&quot; - b -&gt;&quot;a-b&quot;&quot;a&quot; / b -&gt;&quot;a/b&quot;//注意字符串不能相乘 字符串函数大写： 12$word:&quot;hello&quot;;to-upper-case($word) -&gt; &quot;HELLO&quot; 小写： 12$word:&quot;Hello&quot;;to-lower-case($word) -&gt; &quot;hello&quot; 得到length： 12$word:&quot;Hello&quot;;str-length($word) -&gt; 5 得到字符串在字符串里的位置： 12$word:&quot;Hello&quot;;str-index($word,&quot;el&quot;) -&gt; 2 字符串中插入字符串： 12$word:&quot;Hello&quot;;str-insert($word,&quot;aa&quot;,2) -&gt; &quot;Haaello&quot; 颜色相关在sass里除了关键字、十六进制、rgb和rgba之外还有一种颜色是HSL 分别表示的是 色相 0-360（deg） 饱和度 0-100% 明度 0-100% 例如： 123456789body &#123;truebackground-color:hsl(0,100%,50%);&#125;-》body &#123; background-color: red;&#125; 123456789body &#123;truebackground-color:hsl(60,100%,50%);&#125;body &#123; background-color: yellow;&#125; 也可以有透明哟123456789body &#123;truebackground-color:hsl(60,100%,50%，0.5);&#125;body &#123; background-color: rgba(255,255,0,0.5);&#125; 颜色函数lighten函数和darken函数可以把颜色加深或减淡，即调整明度，第一个参数为颜色，第二个参数为百分比，例如： 1234567891011$color:#ff0000;$light-color:lighten($color,30%);$dark-color:darken($color,30%);.a&#123;truecolor:$color;truebackground:$light-color;trueborder-color:$dark-color;&#125; 12345.a &#123; color: #ff0000; background: #ff9999; border-color: #660000;&#125; saturate和desaturate函数可以调整颜色的纯度 1234567891011$color:hsl(0,50%,50%);$saturate-color:saturate($color,50%);$desaturate-color:desaturate($color,30%);.a&#123;truecolor:$color;truebackground:$saturate-color;trueborder-color:$desaturate-color;&#125; 12345.a &#123; color: #bf4040; background: red; border-color: #996666;&#125; 用transparentize来让颜色更透明 用opatify来让颜色更不透明 1234567891011$color:rgba(255,0,0,0.5);$opacify-color:opacify($color,0.3);$transparentize-color:transparentize($color,0.3);.a&#123;truecolor:$color;truebackground:$opacify-color;trueborder-color:$transparentize-color;&#125; 12345.a &#123; color: rgba(255, 0, 0, 0.5); background: rgba(255, 0, 0, 0.8); border-color: rgba(255, 0, 0, 0.2);&#125; 列表类型在sass里，用空格或者逗号隔开的值就是列表类型如： 1231px solid redCourier,microsoft yahei 列表函数sass里的列表类似与数组 1234567891011121314获取列表的长度length(5px 10x) 2获取列表中的第几个元素nth(5px 10px,2) 10px获取一个元素在一个列表里的下标index(1px solid red,solid) 2给列表里加入新的元素append(5px 10px,5px) 5px 10px 5px连接两个列表join(5px 10px,5px 0) 5px 10px 5px 0 map类型sass里的map类型类似与js里的object 1$map:(key1:value1,key2:value2,key3:value3); map 函数12345678910111213141516171819202122232425//定义一个map$color:(light:#ffffff,dark:#000000);//获取map 的lengthlength($color) -&gt;2//得到map里key对应的值map-get($color,dark) -&gt;#000000获取map里的所有键的列表map-keys($color) -&gt;(&quot;light&quot;,&quot;dark&quot;) //列表类型获取map里的所有值的列表map-values($color) -&gt; (&quot;#ffffff&quot;,&quot;#000000&quot;) //列表类型判断map里是否含有这个keymap-has-key($color,light) -&gt;true给map里添加键值对map-merge($color,(light-gray:#cccccc))-&gt;(light:#ffffff,dark:#000000,light-gray:#cccccc)移除map里的某个键值对map-remove($colors,light) -&gt;(dark:#000000,light-gray:#cccccc) boolean类型在sass里通过&gt; &lt; 比较得到的值就是布尔值 true 和false 1235px&gt;3px -&gt; true5px&lt;2px -&gt; false 在sass里也可以有或 且 非 且： 12(5px &gt; 3px) and (5px &lt; 2px) -&gt; false(5px &gt; 3px) and (5px &gt; 2px) -&gt; true 或： 12(5px &gt; 3px) or (5px &lt; 2px) -&gt; true(5px &lt; 3px) and (5px &gt; 2px) -&gt; false 非： 1not(5px&gt;3px) -&gt; false interpolation在sass里可以通过interpolation的方式来在变量名和属性名上拼接变量值，例如 123456$name:&quot;info&quot;;$attr:&quot;border&quot;;.alert-#&#123;$name&#125;&#123;true#&#123;$attr&#125;-color:red;&#125; 123.alert-info &#123; border-color: red;&#125;]]></content>
      <categories>
        <category>前端笔记</category>
      </categories>
      <tags>
        <tag>sass</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[5.sass变量、嵌套、混合（mixin）、继承拓展、@import、comment]]></title>
    <url>%2F2017%2F06%2F19%2F5.%E5%8F%98%E9%87%8F%E3%80%81%E5%B5%8C%E5%A5%97%E3%80%81%E6%B7%B7%E5%90%88%EF%BC%88mixin%EF%BC%89%E3%80%81%E7%BB%A7%E6%89%BF%E6%8B%93%E5%B1%95%E3%80%81%40import%E3%80%81comment%2F</url>
    <content type="text"><![CDATA[变量的意义在sass里我们可以定义多个变量来存放颜色、边框等等的样式，这样就可以在下面想要使用样式的时候使用变量了 这样的优点就是便于维护，更改方便 变量的使用可以通过$来定义变量，在变量名字中可以使用-和来作为连接，并且-和是可以互通的，就是用起来一模一样。 变量的值可以是字符串、数字、颜色等等，在变量里还可以使用其他变量，使用的时候直接写变量名就好了 例如12345678910$primary-color:#ff6600;$primary-border:1px solid $primary_color;div.box&#123;truebackground:$primary-color;&#125;h1.page-header&#123;trueborder:$primary-border;&#125; —》 1234567div.box &#123; background: #ff6600;&#125;h1.page-header &#123; border: 1px solid #ff6600;&#125; 嵌套的使用合理的使用嵌套语法，可以使我们编写代码更为快捷 假设我们想写这样的css： 1234567891011.nav &#123; height: 100px;&#125;.nav ul &#123; margin: 0;&#125;.nav ul li &#123; float: left; list-style: none; padding: 5px;&#125; 在sass里我们可以这样写 1234567891011.nav&#123;trueheight:100px;trueul&#123;truetruemargin:0;truetrueli &#123;truetruetruefloat:left;truetruetruelist-style:none;truetruetruepadding:5px;truetrue&#125;true&#125;&#125; 大家会发现，写出来的代码父和子之间都有空格隔开，如果我们需要给a加上伪类的话我们这样写 123456789.nav&#123; height:100px; a&#123; color:#fff; :hover&#123; color:#ff6600; &#125; &#125;&#125; 在里面就会出现这样的情况 123.nav a :hover &#123; color: #ff6600;&#125; 我们发现在a和:hover之间有了空格，这样是不好的，所以我们需要在写的时候在：hover之前把a加上，这样就需要用到在之类里引用父类选择器的方式，我们可以用&amp;符号代替父类 例如： 123456789.nav&#123; height:100px; a&#123; color:#fff; &amp;:hover&#123; color:#ff6600; &#125; &#125;&#125; 这样就好了，下面来个完整的代码： 1234567891011121314151617181920212223.nav&#123; height:100px; ul&#123; margin:0; li&#123; float:left; list-style:none; padding:5px; &#125; a&#123; display:block; color:#000; &amp;:hover&#123; color:#f60; background:red; &#125; &#125; &#125; &amp; &amp;-text&#123; font-size:15px; &#125;&#125; —–》 12345678910111213141516171819202122.nav &#123; height: 100px;&#125;.nav ul &#123; margin: 0;&#125;.nav ul li &#123; float: left; list-style: none; padding: 5px;&#125;.nav ul a &#123; display: block; color: #000;&#125;.nav ul a:hover &#123; color: #f60; background: red;&#125;.nav .nav-text &#123; font-size: 15px;&#125; 嵌套属性我们可以把一些个复合属性的子属性来嵌套编写，加快编写速度，例如 1234567891011121314151617181920body&#123;truefont:&#123;truetruefamily:Helvitica;truetruesize:15px;truetrueweight:bold;true&#125;&#125;.nav&#123;trueborder:1px solid red&#123;truetrueleft:none;truetrueright:none;true&#125;&#125;.page-next&#123;truetransition:&#123;truetrueproperty:all;truetruedelay:2s;true&#125;&#125; —–》 12345678910111213141516body &#123; font-family: Helvitica; font-size: 15px; font-weight: bold;&#125;.nav &#123; border: 1px solid red; border-left: none; border-right: none;&#125;.page-next &#123; transition-property: all; transition-delay: 2s;&#125; mixin 混合 你可以把它想象成一个有名字的定义好的样式 每一个mixin都有自己的名字，类似于js里的函数定义方法如下 123@mixin 名字(参数1，参数2...)&#123; ...&#125; 使用方法是在其他选择器css样式里通过@include引入，其实就相当于将mixin里的代码写入到这个选择器的css里，如下： 1234567891011121314@mixin alert &#123;truecolor:#f60;truebackground-color:#f60;truea&#123;truetruecolor:pink;true&#125;true&amp;-a&#123;truetruecolor:red;true&#125;&#125;.alert-warning&#123;true@include alert;&#125; —–》 12345678910.alert-warning &#123; color: #f60; background-color: #f60;&#125;.alert-warning a &#123; color: pink;&#125;.alert-warning-a &#123; color: red;&#125; 刚才是没有参数的mixin，mixin也可以拥有参数，需要注意的是： 形参的名字前要加$ 传参的时候只写值的话要按顺序传 传参的时候不想按顺序的话需要加上形参名字 例如： 123456789101112131415@mixin alert($color,$background) &#123;truecolor:$color;truebackground-color:$background;truea&#123;truetruecolor:darken($color,10%);//把颜色加深百分之十true&#125;&#125;.alert-warning&#123;true@include alert(red,blue);&#125;.alert-info&#123;true@include alert($background:red,$color:blue);&#125; ——》 123456789101112131415.alert-warning &#123; color: red; background-color: blue;&#125;.alert-warning a &#123; color: #cc0000;&#125;.alert-info &#123; color: blue; background-color: red;&#125;.alert-info a &#123; color: #0000cc;&#125; 继承拓展 extend如果我们有一个选择器想要拥有另一个选择所有的东西，不管是样式还是子元素等等，可以使用@extend来继承 大家需要注意的是，++b继承a的时候，a的子元素设置了样式，也会给b的子元素设置样式++，达到完全一样的情况，例如： 123456789101112131415.alert &#123;truepadding:5px;&#125;.alert a &#123;truefont:&#123;truetrueweight:bold;truetruesize:15px;true&#125;&#125;.alert-info &#123;true@extend .alert;truebackgournd:skyblue;&#125; —-》 123456789101112.alert, .alert-info &#123; padding: 5px;&#125;.alert a, .alert-info a &#123; font-weight: bold; font-size: 15px;&#125;.alert-info &#123; backgournd: skyblue;&#125; partials在以前咱们编写css的时候，一个css引入另一个css需要使用@import，其实这是不好的，会多发一次http请求，影响咱们站点的响应速度。 在sass里，咱们可以把小的sass文件分出去，叫做partials，在某个sass里通过@import ‘partials名’去引入，注意路径哟，这样的话就可以把partials里的代码引到咱们大的sass里一起编译 需要注意的是 partials的文件名前要加_ _base.sass :1234body&#123;truemargin:0;truepadding:0;&#125; style.sass :1234567891011121314151617@import &quot;base&quot;;.alert &#123;truepadding:5px;&#125;.alert a &#123;truefont:&#123;truetrueweight:bold;truetruesize:15px;true&#125;&#125;.alert-info &#123;true@extend .alert;truebackgournd:skyblue;&#125; ———–&gt; 1234567891011121314151617body &#123; margin: 0; padding: 0;&#125;.alert, .alert-info &#123; padding: 5px;&#125;.alert a, .alert-info a &#123; font-weight: bold; font-size: 15px;&#125;.alert-info &#123; backgournd: skyblue;&#125; 这样的话我们就可以把模块化的思想引入到sass里了 comment注释sass里的注释有三种 多行注释 单行注释 强制注释 多行注释：压缩后不会出现在css里 / / 单行注释: 不会出现在css里 // 强制注释：压缩后也会出现在css里 /! /]]></content>
      <categories>
        <category>前端笔记</category>
      </categories>
      <tags>
        <tag>sass</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[4.sass与scss]]></title>
    <url>%2F2017%2F06%2F18%2F4.sass%E4%B8%8Escss%2F</url>
    <content type="text"><![CDATA[sass的两个语法版本sass一开始用的是一种缩进式的语法格式 采用这种格式文件的后缀名是.sass 在sass3.0版本后我们常用的是sassy css语法，扩展名是.scss，更接近与css语法 两个版本的区别 后缀名不同 .sass和.scss 语法不同，请看下面 新版： 1234567891011121314151617181920212223/*新版本多行文本注释*///新版本//单行文本注释@import &quot;base&quot;;@mixin alert&#123;truecolor:red;truebackground:blue;&#125;.alert-warning&#123;true@include alert;&#125;ul&#123;truefont-size:15px;trueli&#123;truetruelist-style:none;true&#125;&#125; 老版本： 123456789101112131415161718192021/*新版本多行文本注释//新版本 单行文本注释@import &quot;base&quot;=alerttruecolor:redtruebackground:blue.alert-warningtrue+alertultruefont-size:15pxtruelitruetruelist-style:none]]></content>
      <categories>
        <category>前端笔记</category>
      </categories>
      <tags>
        <tag>sass</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[3.sass四种风格]]></title>
    <url>%2F2017%2F06%2F17%2F3.sass%E5%9B%9B%E7%A7%8D%E9%A3%8E%E6%A0%BC%2F</url>
    <content type="text"><![CDATA[sass编译的格式sass编译输出的css有四种格式 nested 嵌套 compact 紧凑 expanded 扩展 compressed 压缩 这些样式会影响输出的css的格式 简单介绍一下： css默认输出的嵌套 123456ul&#123;truefont-size:15px;trueli&#123;truetruelist-style:none;true&#125;&#125; —》 1234ul &#123; font-size: 15px; &#125; ul li &#123; list-style: none; &#125; 紧凑compact在编译的时候需要执行 1sass --watch scss:css --style compact 这个时候输出的代码就是 12ul &#123; font-size: 15px; &#125;ul li &#123; list-style: none; padding: 5px; &#125; compressed 压缩在编译的时候需要执行 1sass --watch scss:css --style compressed —&gt; 1ul&#123;font-size:15px&#125;ul li&#123;list-style:none;animation:all 0.4s&#125; expanded 扩展更像是平时写的css一样 在编译的时候需要执行1sass --watch scss:css --style expanded —&gt;1234567ul &#123; font-size: 15px;&#125;ul li &#123; list-style: none; animation: all 0.3s;&#125; compressed 压缩更像是平时写的css一样 在编译的时候需要执行1sass --watch scss:css --style compressed —&gt;1.a&#123;width:100px;height:100px;border:1px solid red&#125;.a .b&#123;background:red&#125;]]></content>
      <categories>
        <category>前端笔记</category>
      </categories>
      <tags>
        <tag>sass</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2.编译sass文件的方式]]></title>
    <url>%2F2017%2F06%2F16%2F2.%E7%BC%96%E8%AF%91sass%E6%96%87%E4%BB%B6%E7%9A%84%E6%96%B9%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[1.命令行编译 可以通过cmd命令行执行sass方法来编译 例如： 1sass scss/a.scss:css/a.css sass 后面写要编译的sass文件的路径，‘：’后面写的是要输出的目录及名字 需要注意的是：必须有这个文件夹才能在里面生成css 这样的话写一句执行一次编译一次有些太麻烦 可以开启一个watch来监听文件变化来进行编译1sass --watch scss:css –watch表示要监听 ：前后的两个都是文件夹，表示scss文件夹的文件改变就编译到css文件夹 2.其他方式编译除了命令行工具其实还可以用考拉、gulp等工具进行编译，但是ruby和sass是必须要安装的 考拉的方式就不多做介绍了，大家i自己去看一下 gulp的话呢是需要gulp-sass的模块来编译，使用方式类似于gulp-less 这里是网址，点击查看]]></content>
      <categories>
        <category>前端笔记</category>
      </categories>
      <tags>
        <tag>sass</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1.安装ruby]]></title>
    <url>%2F2017%2F06%2F15%2F1.%E5%AE%89%E8%A3%85sass%2F</url>
    <content type="text"><![CDATA[1.安装ruby 因为sass是用ruby语言写的，所以需要安装ruby环境 打开安装包去安装ruby，记住要勾选 下面选项来配置环境路径 [x] Add Ruby executables to your PATH 安装完成之后继续下一步操作 2.安装sass在cmd里通过gem安装sass gem是ruby的包管理工具，类似于nodejs 的npm 1gem install sass 这个时候如果不翻墙的话是会出问题的，因为： 由于国内网络原因（你懂的），导致 rubygems.org 存放在 Amazon S3 上面的资源文件间歇性连接失败。这时候我们可以通过gem sources命令来配置源，先移除默认的https://rubygems.org源，然后添加淘宝的源https://ruby.taobao.org/，然后查看下当前使用的源是哪个，如果是淘宝的，则表示可以输入sass安装命令gem install sass了 12345678$ gem sources --remove https://rubygems.org/$ gem sources -a https://ruby.taobao.org/ 【如果你系统不支持https，请将淘宝源更换成：gem sources -a http://gems.ruby-china.org】$ gem sources -l*** CURRENT SOURCES ***https://ruby.taobao.org# 请确保只有 ruby.taobao.org$ gem install sass 安装好之后执行sass -v就可以看到sass的版本了 实在实在不行，就安装离线文件吧,但是失败率也很高 gem install ./…/sass-3.4.22.gem]]></content>
      <categories>
        <category>前端笔记</category>
      </categories>
      <tags>
        <tag>ruby</tag>
        <tag>sass</tag>
      </tags>
  </entry>
</search>
